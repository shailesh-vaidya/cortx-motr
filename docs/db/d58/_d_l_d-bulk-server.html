<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Motr: DLD of Bulk Server</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Motr
   &#160;<span id="projectnumber">M0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('db/d58/_d_l_d-bulk-server.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">DLD of Bulk Server </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-ovw">Overview</a></li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-def">Definitions</a></li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-req">Requirements</a></li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-design-ovw">Design Overview</a></li>
<li><a class="el" href="../../d2/d7d/_d_l_d-bulk-server-fspec.html#DLD-bulk-server-fspec">Functional Specification</a> <br />
- <a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-lspec">Logical Specification</a><ul>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-lspec-seq">Sequence diagram</a></li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-lspec-state">State Transition Diagrams</a></li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-lspec-buffers-mgnt">Buffers Management</a></li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-lspec-service-registration">Service Registration</a></li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-lspec-thread">Threading and Concurrency Model</a></li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-lspec-numa">NUMA optimizations</a></li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-lspec-depends">Dependencies</a></li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-lspec-conformance">Conformance</a></li>
</ul>
</li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-ut">Unit Tests</a></li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-it">Integration Tests</a></li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-st">System Tests</a></li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-O">Analysis</a></li>
<li><a class="el" href="../../db/d58/_d_l_d-bulk-server.html#DLD-bulk-server-ref">References</a></li>
</ul>
<hr/>
 <h1><a class="anchor" id="DLD-bulk-server-ovw"></a>
Overview</h1>
<p>This document contains the detailed level design of the Bulk I/O Service.</p>
<p><b>Purpose</b><br />
 The purpose of this document is to:</p><ul>
<li>Refine higher level designs</li>
<li>To be verified by inspectors and architects</li>
<li>To guide the coding phase</li>
</ul>
<hr/>
 <h1><a class="anchor" id="DLD-bulk-server-def"></a>
Definitions</h1>
<p>Terms used in this document defined as below :</p>
<ul>
<li><b>Bulk I/O Service</b> Motr ioservice which process read/write FOPs.</li>
<li><b>FOP</b> File operation packet, a description of file operation suitable for sending over network or storing on a storage device. File operation packet (FOP) identifies file operation type and operation parameters.</li>
<li><b>FOM</b> FOP state machine (FOM) is a state machine that represents current state of the FOP's execution on a node. FOM is associated with the particular FOP and implicitly includes this FOP as part of its state.</li>
<li><b>zero-copy</b> Copy between a source and destination takes place without any intermediate copies to staging areas.</li>
<li><b>STOB</b> Storage object (STOB) is a basic M0 data structure containing raw data.</li>
<li><b>COB</b> Component object (COB) is a component (stripe) of a file, referencing a single storage object and containing metadata describing the object.</li>
<li><b>rpc_bulk</b> Generic interface for zero-copy.</li>
<li><b>buffer_pool</b> Pre-allocated &amp; pre-registered pool of buffers. Buffer pool also provides interfaces to get/put buffers. Every Bulk I/O Service initiates its buffer_pool.</li>
<li><b>Configuration cache</b> Configuration data being stored in nodeâ€™s memory.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="DLD-bulk-server-req"></a>
Requirements</h1>
<ul>
<li><b>r.bulkserver.async</b> Bulk I/O server runs asynchronously.</li>
<li><b>r.non-blocking.few-threads</b> Motr service should use a relatively small number of threads: a few per processor.</li>
<li><b>r.non-blocking.easy</b> Non-blocking infrastructure should be easy to use and non-intrusive.</li>
<li><b>r.non-blocking.extensibility</b> Addition of new "cross-cut" functionality (e.g., logging, reporting) potentially including blocking points and affecting multiple fop types should not require extensive changes to the data-structures for each fop type involved.</li>
<li><b>r.non-blocking.network</b> Network communication must not block handler threads.</li>
<li><b>r.non-blocking.storage</b> Storage transfers must not block handler threads.</li>
<li><b>r.non-blocking.resources</b> Resource acquisition and release must not block handler threads.</li>
<li><b>r.non-blocking.other-block</b> Other potentially blocking conditions (page faults, memory allocations, writing trace records, etc.) must never block all service threads.</li>
</ul>
<hr/>
 <h2><a class="anchor" id="DLD-bulk-server-design-ovw"></a>
Design Overview</h2>
<p>Bulk I/O Service will be available in the form of state machine to process bulk I/O request. It uses generic rpc_bulk interface to use zero-copy RDMA mechanism from transport layer to copy data from source to destination. It also use STOB I/O interface to complete the I/O operation.</p>
<p>Bulk I/O Service implements I/O FOMs to process I/O FOPs <a class="el" href="../../d9/dc2/group__io__foms.html">Fop State Machines for IO FOPs</a>.</p>
<ul>
<li>Bulk read FOM process FOP of type <a class="el" href="../../d4/d9c/structm0__fop__cob__readv.html">m0_fop_cob_readv</a></li>
<li>Bulk write FOM process FOP of type <a class="el" href="../../df/d6e/structm0__fop__cob__writev.html">m0_fop_cob_writev</a></li>
</ul>
<p>The Bulk I/O Service interface <a class="el" href="../../da/dda/io__fops_8c.html#a0cca6aa7b5ba93a18bbc8d9657d030ee">m0_ioservice_fop_init()</a> registers and initiates I/O FOPs with it. Following are the Bulk I/O Service FOP type.</p>
<ul>
<li><a class="el" href="../../d4/d9c/structm0__fop__cob__readv.html">m0_fop_cob_readv</a>,</li>
<li><a class="el" href="../../df/d6e/structm0__fop__cob__writev.html">m0_fop_cob_writev</a>,</li>
<li><a class="el" href="../../d0/dea/structm0__fop__cob__readv__rep.html">m0_fop_cob_readv_rep</a>,</li>
<li><a class="el" href="../../da/d1c/structm0__fop__cob__writev__rep.html">m0_fop_cob_writev_rep</a></li>
</ul>
<p>The Bulk I/O Service initiates buffer_pool during its initialization. Bulk I/O Service gets buffers required from buffer_pool and pass it to rpc_bulk for zero-copy. Buffers then returns back to buffer pool after data written on STOB.</p>
<p>The Bulk I/O Service initialization done by request handler during its startup.</p>
<hr/>
 <h1><a class="anchor" id="DLD-bulk-server-lspec"></a>
Logical Specification</h1>
<h2><a class="anchor" id="DLD-bulk-server-lspec-seq"></a>
Sequence diagram</h2>
<p>This section describes how client and server communications happens while processing read/write FOPs. This also shows usage of zero-copy in I/O FOP processing.</p>
<p><b> Write operation with zero-copy data transfer </b> </p><div class="mscgraph">
<img src="../../msc_inline_mscgraph_6.png" alt="msc_inline_mscgraph_6" border="0" usemap="#msc_inline_mscgraph_6.map"/>
<map name="msc_inline_mscgraph_6.map" id="msc_inline_mscgraph_6.map"></map>
</div>
<ul>
<li>Client sends write FOP to server. Write FOP contains the network buffer descriptor list and indexvecs list instead of actual data.</li>
<li>To process write FOP, request handler creates &amp; initiates write FOM and puts it into run queue for execution.</li>
<li>State transition function go through generic and extended phases <a class="el" href="../../d9/dc2/group__io__foms.html#gacf3e8267965bf1e5956d0ef3ece85292">m0_io_fom_cob_rw_phases</a> defined for I/O FOM (write FOM).<ul>
<li>Gets as many buffers as it can from buffer_pool to transfer data for all descriptors. If there are insufficient buffers with buffer_pool to process all descriptors then its goes by batch by batch. At least one buffer is needed to start bulk transfer. If no buffer available then bulk I/O Service will wait till buffer_pool becomes non-empty.</li>
<li>Initiates zero-copy using rpc_bulk on acquired buffers and wait for zero-copy to complete for all descriptors on which it initiated.</li>
<li>Zero-copy completes</li>
<li>Initiates write data on STOB for all indexvec and wait for STOB I/O to complete</li>
<li>STOB I/O completes</li>
<li>Returns back some of buffers to buffer_pool if they are more than remaining descriptors.</li>
</ul>
</li>
<li>Enqueue response in fo_rep_fop for the request handler to send the response back to the client</li>
</ul>
<p><b> Read operation with zero-copy data transfer </b> </p><div class="mscgraph">
<img src="../../msc_inline_mscgraph_7.png" alt="msc_inline_mscgraph_7" border="0" usemap="#msc_inline_mscgraph_7.map"/>
<map name="msc_inline_mscgraph_7.map" id="msc_inline_mscgraph_7.map"></map>
</div>
<ul>
<li>Client sends read FOP to server. Read FOP contains the network buffer descriptor list and indexvecs list instead of actual data.</li>
<li>To process read FOP, request handler creates &amp; initiates read FOM and puts it into run queue for execution.</li>
<li>State transition function go through generic and extended phases m0_io_fom_readv_phases defined for read FOM.<ul>
<li>Gets as many buffers as it can from buffer_pool to transfer data for all descriptors. If there are insufficient buffers with buffer_pool to process all descriptors then its goes by batch by batch. At least one buffer is needed to start bulk transfer. If no buffer available then bulk I/O Service will wait till buffer_pool becomes non-empty.</li>
<li>Initiates read data from STOB for all indexvecs and wait for STOB I/O to completes</li>
<li>STOB I/O completes</li>
<li>Initiates zero-copy using rpc_bulk on acquired buffers and wait for zero-copy to complete for all descriptors on which it initiated.</li>
<li>Zero-copy completes</li>
<li>Returns back some of buffers to buffer_pool if they are more than remaining descriptors.</li>
</ul>
</li>
<li>Enqueue response in fo_rep_fop for the request handler to send the response back to the client</li>
</ul>
<p>On the basis of steps involved in these operations enumeration called <a class="el" href="../../d9/dc2/group__io__foms.html#gacf3e8267965bf1e5956d0ef3ece85292">m0_io_fom_cob_rw_phases</a> will be defined, that extends the standard FOM phases (enum m0_fom_standard_phase) with new phases to handle the state machine that sets up and executes read/write operations respectively involving bulk I/O.</p>
<hr/>
 <h2><a class="anchor" id="DLD-bulk-server-lspec-state"></a>
State Transition Diagrams</h2>
<p>State Diagram For Write FOM : </p><div class="dotgraph">
<img src="../../dot_inline_dotgraph_16.png" alt="dot_inline_dotgraph_16.png" border="0" usemap="#dot_inline_dotgraph_16.map"/>
<map name="dot_inline_dotgraph_16.map" id="dot_inline_dotgraph_16.map"></map>
</div>
<p>Bulk I/O Service FOMs will be placed in wait queue for all states which needs to wait for task complete.</p>
<p>State Diagram For Read FOM : </p><div class="dotgraph">
<img src="../../dot_inline_dotgraph_17.png" alt="dot_inline_dotgraph_17.png" border="0" usemap="#dot_inline_dotgraph_17.map"/>
<map name="dot_inline_dotgraph_17.map" id="dot_inline_dotgraph_17.map"></map>
</div>
<p>Bulk I/O Service FOMs will be placed in wait queue for all states which needs to wait for task complete.</p>
<h2><a class="anchor" id="DLD-bulk-server-lspec-buffers-mgnt"></a>
Buffers Management</h2>
<ul>
<li>Buffers Initialization &amp; De-allocation :</li>
</ul>
<p>I/O service maintains m0_buf_pool instance with data structure <a class="el" href="../../da/d3c/structm0__reqh__service.html">m0_reqh_service</a>. Buffer pool m0_reqh_service::m0_buf_pool will be initialized in Bulk I/O Service start operation vector m0_io_service_start(). Bulk I/O service will use m0_buf_pool_init() to allocate and register specified number of network buffers and with specified size.</p>
<p>Bulk I/O Service needs following parameters from configuration database to initialize buffer pool -</p>
<p>IO_BULK_BUFFER_POOL_SIZE Number of network buffers in buffer pool. IO_BULK_BUFFER_SIZE Size of each network buffer. IO_BULK_BUFFER_NUM_SEGMENTS Number of segments in each buffer.</p>
<p>Buffer pool de-allocation takes place in service operation vector m0_io_service_stop(). I/O service will use m0_buf_pool_fini() to de-allocate &amp; de-register the network buffers.</p>
<p>The buffer pool for bulk data transfer is private to the Bulk I/O service and is shared by all FOM instances executed by the service.</p>
<ul>
<li>Buffer Acquire</li>
</ul>
<p>Bulk I/O Servers acquire the network buffer by calling buffer_pool interface m0_buf_pool_get(). If buffer available with buffer_pool then this function returns network buffer. And if buffer_pool empty the function returns NULL. Then FOM need to wait for _notEmpty signal from buffer_pool.</p>
<p>Bulk I/O Service needs to get lock on buffer_pool instance while its request network buffer. And release lock after it get network buffer.</p>
<ul>
<li>Buffer Release</li>
</ul>
<p>Bulk I/O Servers release the network buffer by calling buffer_pool interface m0_buf_pool_put(). It return back network buffer to buffer_pool.</p>
<p>Bulk I/O Service needs to get lock on buffer_pool instance while it request network buffer. And release lock after it get network buffer.</p>
<ul>
<li>Buffer Pool Expansion <dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000116">Todo:</a></b></dt><dd>If buffer_pool reached to low threshold, Bulk I/O service may expand pool size. This can be done later to minimize waiting time for network buffer.</dd></dl>
</li>
</ul>
<h2><a class="anchor" id="DLD-bulk-server-lspec-service-registration"></a>
Service Registration</h2>
<ul>
<li>Service Type Declaration</li>
</ul>
<p>Bulk I/O Service defines service type as follows -</p>
<p>struct <a class="el" href="../../dd/d10/structm0__reqh__service__type.html">m0_reqh_service_type</a> m0_ios_type = { .rst_name = "M0_CST_IOS", .rst_ops = &amp;ios_type_ops, .rst_level = M0_RS_LEVEL_NORMAL, .rst_typecode = M0_CST_IOS, };</p>
<p>It also assigns service name and service type operations for Bulk I/O Service.</p>
<ul>
<li>Service Type Registration</li>
</ul>
<p>Bulk I/O Service registers its service type with request handler using interface <a class="el" href="../../da/ddc/group__reqhservice.html#gabb668cfa383c0168dd893af4fa2e0507">m0_reqh_service_type_register()</a>. This function registers service type with global service type list for request handler. Service type operation m0_ioservice_alloc_and_init() will do this registration.</p>
<h2><a class="anchor" id="DLD-bulk-server-lspec-thread"></a>
Threading and Concurrency Model</h2>
<ul>
<li>resources<br />
 It uses pre-allocated and pre-registered network buffers. These buffers will not released until zero-copy completes and data from net buffers transfered to/from STOB. Since these buffers are pre-allocated &amp; pre-registered with transport layer there should be some lock on these buffers so that no one can use same buffers.</li>
</ul>
<h2><a class="anchor" id="DLD-bulk-server-lspec-numa"></a>
NUMA optimizations</h2>
<h2><a class="anchor" id="DLD-bulk-server-lspec-depends"></a>
Dependencies</h2>
<ul>
<li><b>r.reqh</b> : Request handler to execute Bulk I/O Service FOM</li>
<li><b>r.bufferpool</b> : Network buffers for zero-copy</li>
<li><b>r.fop</b> : To send bulk I/O operation request to server</li>
<li><b>r.net.rdma</b> : Zero-copy data mechanism at network layer</li>
<li><b>r.stob.read-write</b> : STOB I/O</li>
<li><b>r.rpc_bulk</b> : For using zero-copy mechanism</li>
<li><b>r.configuration.caching</b> : Configuration data being stored in node's memory.</li>
</ul>
<h2><a class="anchor" id="DLD-bulk-server-lspec-conformance"></a>
Conformance</h2>
<ul>
<li><b>i.bulkserver.async</b> It implements state transition interface so to run I/O bulk service asynchronously.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="DLD-bulk-server-ut"></a>
Unit Tests</h1>
<p>For isolated unit tests, each function implemented as part of Bulk I/O Service needs to test separately without communicating with other modules. This is not required to use other modules which are communicating with Bulk I/O Server modules.</p>
<ul>
<li>Test 01 : Call function <a class="el" href="../../d9/dc2/group__io__foms.html#ga9a64af006d04431583d77289fb671b2c">m0_io_fom_cob_rw_create()</a><br />
 Input : Read FOP (in-memory data structure <a class="el" href="../../d5/d01/structm0__fop.html">m0_fop</a>)<br />
 Expected Output : Create FOM of corresponding FOP type.</li>
<li>Test 02 : Call function <a class="el" href="../../d9/dc2/group__io__foms.html#ga9a64af006d04431583d77289fb671b2c">m0_io_fom_cob_rw_create()</a><br />
 Input : Write FOP (in-memory data structure <a class="el" href="../../d5/d01/structm0__fop.html">m0_fop</a>)<br />
 Expected Output : Create FOM of corresponding FOP type.</li>
<li>Test 03 : Call function m0_io_fom_cob_rw_init()<br />
 Input : Read FOP (in-memory data structure <a class="el" href="../../d5/d01/structm0__fop.html">m0_fop</a>)<br />
 Expected Output : Initiates FOM with corresponding operation vectors and other pointers.</li>
<li>Test 04 : Call function m0_io_fom_cob_rw_init()<br />
 Input : Write FOP (in-memory data structure <a class="el" href="../../d5/d01/structm0__fop.html">m0_fop</a>)<br />
 Expected Output : Initiates FOM with corresponding operation vectors and other pointers.</li>
<li>Test 05 : Call <a class="el" href="../../d9/dc2/group__io__foms.html#gab5ec26e2bf6de8d4c556fbe9487221e9">m0_io_fom_cob_rw_tick()</a> with buffer pool size 1<br />
 Input : Read FOM with current phase M0_FOPH_IO_FOM_BUFFER_ACQUIRE<br />
 Expected Output : Gets network buffer and pointer set into FOM with phase changed to M0_FOPH_IO_STOB_INIT and return value M0_FSO_AGAIN.</li>
<li>Test 06 : Call <a class="el" href="../../d9/dc2/group__io__foms.html#gab5ec26e2bf6de8d4c556fbe9487221e9">m0_io_fom_cob_rw_tick()</a> with buffer pool size 0 (empty buffer_pool)<br />
 Input : Read FOM with current phase M0_FOPH_IO_FOM_BUFFER_ACQUIRE<br />
 Expected Output : Should not gets network buffer and NULL pointer set into FOM with phase changed to M0_FOPH_IO_FOM_BUFFER_WAIT and return value M0_FSO_WAIT.</li>
<li>Test 07 : Call <a class="el" href="../../d9/dc2/group__io__foms.html#gab5ec26e2bf6de8d4c556fbe9487221e9">m0_io_fom_cob_rw_tick()</a> with buffer pool size 0 (empty buffer_pool)<br />
 Input : Read FOM with current phase M0_FOPH_IO_FOM_BUFFER_WAIT<br />
 Expected Output : Should not gets network buffer and NULL pointer set into FOM with phase not changed and return value M0_FSO_WAIT.</li>
<li>Test 08 : Call <a class="el" href="../../d9/dc2/group__io__foms.html#gab5ec26e2bf6de8d4c556fbe9487221e9">m0_io_fom_cob_rw_tick()</a><br />
 Input : Read FOM with current phase M0_FOPH_IO_STOB_INIT<br />
 Expected Output : Initiates STOB read with phase changed to M0_FOPH_IO_STOB_WAIT and return value M0_FSO_WAIT.</li>
<li>Test 09 : Call <a class="el" href="../../d9/dc2/group__io__foms.html#gab5ec26e2bf6de8d4c556fbe9487221e9">m0_io_fom_cob_rw_tick()</a><br />
 Input : Read FOM with current phase M0_FOPH_IO_ZERO_COPY_INIT<br />
 Expected Output : Initiates zero-copy with phase changed to M0_FOPH_IO_ZERO_COPY_WAIT return value M0_FSO_WAIT.</li>
<li>Test 10 : Call <a class="el" href="../../d9/dc2/group__io__foms.html#gab5ec26e2bf6de8d4c556fbe9487221e9">m0_io_fom_cob_rw_tick()</a> with buffer pool size 1<br />
 Input : Write FOM with current phase M0_FOPH_IO_FOM_BUFFER_ACQUIRE<br />
 Expected Output : Gets network buffer and pointer set into FOM with phase changed to M0_FOPH_IO_ZERO_COPY_INIT and return value M0_FSO_AGAIN.</li>
<li>Test 11 : Call function <a class="el" href="../../d9/dc2/group__io__foms.html#gaa5ab8fd37c2a3b8952066b5ad6a322ac">m0_io_fom_cob_rw_fini()</a><br />
 Input : Read FOM<br />
 Expected Output : Should de-allocate FOM.</li>
<li>Test 12 : Call <a class="el" href="../../d9/dc2/group__io__foms.html#gab5ec26e2bf6de8d4c556fbe9487221e9">m0_io_fom_cob_rw_tick()</a><br />
 Input : Read FOM with invalid STOB id and current phase M0_FOPH_IO_STOB_INIT.<br />
 Expected Output : Should return error.</li>
<li>Test 13 : Call <a class="el" href="../../d9/dc2/group__io__foms.html#gab5ec26e2bf6de8d4c556fbe9487221e9">m0_io_fom_cob_rw_tick()</a><br />
 Input : Read FOM with current phase M0_FOPH_IO_ZERO_COPY_INIT and wrong network buffer descriptor.<br />
 Expected Output : Should return error.</li>
<li>Test 14 : Call <a class="el" href="../../d9/dc2/group__io__foms.html#gab5ec26e2bf6de8d4c556fbe9487221e9">m0_io_fom_cob_rw_tick()</a><br />
 Input : Read FOM with current phase M0_FOPH_IO_STOB_WAIT with result code of stob I/O m0_fom::m0_stob_io::si_rc set to I/O error.<br />
 Expected Output : Should return error M0_FOS_FAILURE and I/O error set in relay FOP.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="DLD-bulk-server-it"></a>
Integration Tests</h1>
<p>All the tests mentioned in Unit test section will be implemented with actual bulk I/O client.</p>
<h1><a class="anchor" id="DLD-bulk-server-st"></a>
System Tests</h1>
<p>All the tests mentioned in unit test section will be implemented with actual I/O (read, write) system calls.</p>
<hr/>
 <h1><a class="anchor" id="DLD-bulk-server-O"></a>
Analysis</h1>
<ul>
<li>Acquiring network buffers for zero-copy need to be implemented as async operation, otherwise each I/O FOM try to acquire this resource resulting lots of request handler threads if buffers is not available.</li>
<li>Use of pre-allocated &amp; pre-registered buffers could decrease I/O throughput since all I/O FOPs need this resource to process operation.</li>
<li>On other side usage of zero-copy improve the I/O performance.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="DLD-bulk-server-ref"></a>
References</h1>
<p>References to other documents are essential.</p><ul>
<li><a class="el" href="../../d9/dc2/group__io__foms.html">Fop State Machines for IO FOPs</a> For documentation links, please refer to this file : doc/motr-design-doc-list.rst</li>
<li>FOPFOM Programming Guide</li>
<li>High Level Design - FOP State Machine</li>
<li>High level design of rpc layer core </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d3/dd6/_d_l_d_i_x.html">Detailed Designs</a></li>
    <li class="footer">Generated on Thu Apr 14 2022 14:03:25 for Motr by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
