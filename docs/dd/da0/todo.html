<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Motr: Todo List</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Motr
   &#160;<span id="projectnumber">M0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dd/da0/todo.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000045"></a>Global <a class="el" href="../../d2/db5/db_8c.html#a83dc065e5d8c8f993c1c60473c9ef6d4">__confdb_free</a>  (struct <a class="el" href="../../d2/d56/structm0__be__btree.html">m0_be_btree</a> *btree, struct <a class="el" href="../../d4/d9b/structm0__be__seg.html">m0_be_seg</a> *seg, struct <a class="el" href="../../d2/d7e/structm0__be__tx.html">m0_be_tx</a> *tx)</dt>
<dd><p class="startdd">check validity of key and record addresses and sizes. Specifically, check that val.b_addr points to an allocated region in a segment with appropriate size and alignment. Such checks should be done generally by (not existing) beobj interface.</p>
<p class="enddd">also check that key (fid) matches <a class="el" href="../../dd/df9/group__conf__dfspec__obj.html#ga7a9de54bfbfed026c6862370d3cc9999">m0_conf_objx_fid()</a>.  </p>
</dd>
<dt><a class="anchor" id="_todo000064"></a>Global <a class="el" href="../../db/d90/group__rconfc__dlspec.html#gac1793fd3f47c3e3f10dcb73705704bca">_confc_cache_clean</a>  (struct <a class="el" href="../../dd/d03/structm0__confc.html">m0_confc</a> *confc)</dt>
<dd>Confc root pointer is not valid anymore after cache cleanup, so it should be reinitialised. The easiest way would be to reinitialise confc completely, but user can create confc contexts during reelection, so let's reinitialise root object in different way.  </dd>
<dt><a class="anchor" id="_todo000207"></a>Global <a class="el" href="../../dc/d55/group___net_test_u_console_internals.html#gaeb89ffad237177f5ffb76badebd2aed1">addr_check</a>  (const char *addr)</dt>
<dd>additional checks  </dd>
<dt><a class="anchor" id="_todo000297"></a>Module <a class="el" href="../../d9/d6a/group__stob.html#amgrpcc954e979e29e0ca2c81b08d5181220c">adieu</a>  </dt>
<dd>A natural way to extend this design is to introduce additional SIS_PREPARED state and to split IO operation submission into two stages: (i) "preparation" stage that is entered once "IO geometry" is known (i.e., once <a class="el" href="../../d1/d8f/structm0__vec.html">m0_vec</a> of data pages and <a class="el" href="../../d1/d8f/structm0__vec.html">m0_vec</a> storage objects are known) and (ii) "queueing" stage that is entered when in addition to IO geometry, actual data pages are allocated. The motivating example for this refinement is a data server handling read or write RPC from a client. The RPC contains enough information to build IO vectors, while data arrive later through RDMA. To avoid dead-locks, it is crucial to avoid dynamic resource allocations (first of all, memory allocations) in data path after resources are consumed by RDMA. To this end, IO operation must be completely set up and ready for queueing before RMDA starts, i.e., before data pages are available. </dd>
<dt><a class="anchor" id="_todo000297"></a>Module <a class="el" href="../../d9/d6a/group__stob.html#amgrpcc954e979e29e0ca2c81b08d5181220c">adieu</a>  </dt>
<dd>A natural way to extend this design is to introduce additional SIS_PREPARED state and to split IO operation submission into two stages: (i) "preparation" stage that is entered once "IO geometry" is known (i.e., once <a class="el" href="../../d1/d8f/structm0__vec.html">m0_vec</a> of data pages and <a class="el" href="../../d1/d8f/structm0__vec.html">m0_vec</a> storage objects are known) and (ii) "queueing" stage that is entered when in addition to IO geometry, actual data pages are allocated. The motivating example for this refinement is a data server handling read or write RPC from a client. The RPC contains enough information to build IO vectors, while data arrive later through RDMA. To avoid dead-locks, it is crucial to avoid dynamic resource allocations (first of all, memory allocations) in data path after resources are consumed by RDMA. To this end, IO operation must be completely set up and ready for queueing before RMDA starts, i.e., before data pages are available. </dd>
<dt><a class="anchor" id="_todo000297"></a>Module <a class="el" href="../../d9/d6a/group__stob.html#amgrpcc954e979e29e0ca2c81b08d5181220c">adieu</a>  </dt>
<dd>A natural way to extend this design is to introduce additional SIS_PREPARED state and to split IO operation submission into two stages: (i) "preparation" stage that is entered once "IO geometry" is known (i.e., once <a class="el" href="../../d1/d8f/structm0__vec.html">m0_vec</a> of data pages and <a class="el" href="../../d1/d8f/structm0__vec.html">m0_vec</a> storage objects are known) and (ii) "queueing" stage that is entered when in addition to IO geometry, actual data pages are allocated. The motivating example for this refinement is a data server handling read or write RPC from a client. The RPC contains enough information to build IO vectors, while data arrive later through RDMA. To avoid dead-locks, it is crucial to avoid dynamic resource allocations (first of all, memory allocations) in data path after resources are consumed by RDMA. To this end, IO operation must be completely set up and ready for queueing before RMDA starts, i.e., before data pages are available. </dd>
<dt><a class="anchor" id="_todo000169"></a>Global <a class="el" href="../../d7/dde/io__req_8c.html#a8fa6a829b56b53102726a7aa879a2765">application_data_copy</a>  (struct <a class="el" href="../../d0/d55/structpargrp__iomap.html">pargrp_iomap</a> *map, struct <a class="el" href="../../d3/dc5/structm0__obj.html">m0_obj</a> *obj, m0_bindex_t start, m0_bindex_t end, struct <a class="el" href="../../d5/d06/structm0__bufvec__cursor.html">m0_bufvec_cursor</a> *datacur, enum copy_direction dir, enum page_attr filter)</dt>
<dd>reduce the number of arguments to this function, map+obj are in ioo  </dd>
<dt><a class="anchor" id="_todo000095"></a>Global <a class="el" href="../../d0/d55/source__dock__fom_8c.html#a08469fbfa6e4cedb932a50eb63e44e96">apply_filters</a>  (struct <a class="el" href="../../de/d0e/structfdmi__sd__fom.html">fdmi_sd_fom</a> *sd_fom, struct <a class="el" href="../../d4/d48/structm0__fdmi__src__rec.html">m0_fdmi_src_rec</a> *src_rec)</dt>
<dd>Mark FDMI filter as invalid (send HA not?) (phase 2)  </dd>
<dt><a class="anchor" id="_todo000182"></a>Global <a class="el" href="../../d5/d16/group__netsock.html#ga9ba243c1f191db3785f0c9950e95266a">autotm</a>  [1024]</dt>
<dd>Move it to <a class="el" href="../../d5/d1b/structm0.html">m0</a> instance or make per-domain.  </dd>
<dt><a class="anchor" id="_todo000001"></a>Global <a class="el" href="../../de/d8f/group__balloc.html#gga39fca1837c5ce7715cbf571669660c13a9dc17daf2e501bde32b97fc6902c8a99">BALLOC_DEF_CONTAINER_SIZE</a>  </dt>
<dd>should equal to size of HDD  </dd>
<dt><a class="anchor" id="_todo000002"></a>Module <a class="el" href="../../d9/dcf/group__be.html">be</a>  </dt>
<dd>Interface tester </dd>
<dt><a class="anchor" id="_todo000013"></a>Global <a class="el" href="../../d9/dcf/group__be.html#ga6fae36bf4a04f00cd843ab0ba2fcd97f">be_tx_ast_offset</a>  [M0_BTS_NR+1]</dt>
<dd>Find out why M0_BTS_NR + 1 is enough and M0_BTS_NR isn't.  </dd>
<dt><a class="anchor" id="_todo000196"></a>Class <a class="el" href="../../d0/db9/structbuf__status__errno.html">buf_status_errno</a>  </dt>
<dd>add timestamp  </dd>
<dt><a class="anchor" id="_todo000023"></a>Global <a class="el" href="../../de/dd9/capa__ut_8c.html#aa0b50497ac6dc74cc9f286201fabebde">capa_test</a>  (void)</dt>
<dd>struct <a class="el" href="../../df/d40/structm0__capa__issuer.html">m0_capa_issuer</a> is empty, put proper values.  </dd>
<dt><a class="anchor" id="_todo000033"></a>Global <a class="el" href="../../d0/d60/cas_2service_8c.html#a79c10a0c7c0c11a421762bc1d97de840">cas_fom_create</a>  (struct <a class="el" href="../../d5/d01/structm0__fop.html">m0_fop</a> *fop, struct <a class="el" href="../../d9/db7/structm0__fom.html">m0_fom</a> **out, struct <a class="el" href="../../d9/da2/structm0__reqh.html">m0_reqh</a> *reqh)</dt>
<dd>Validity (<a class="el" href="../../d0/d60/cas_2service_8c.html#a392f3a2cdb32b08c2e774d4ffaf78b35">cas_is_valid()</a>) of input records is not checked here, so "out_nr" can be bogus. Cannot check validity at this point, because -&gt;fto_create() errors are silently ignored.  </dd>
<dt><a class="anchor" id="_todo000164"></a>Global <a class="el" href="../../d2/d61/group__index-dix.html#gae310a59891b78f508d45997d9c427e11">cas_next_ast</a>  (struct <a class="el" href="../../d5/d32/structm0__sm__group.html">m0_sm_group</a> *grp, struct <a class="el" href="../../de/d78/structm0__sm__ast.html">m0_sm_ast</a> *ast)</dt>
<dd>Currently there is no way to pass several starting keys along with number of consecutive records for each key through <a class="el" href="../../d2/def/group__client.html#ga94dc4391285a0716a064d19748c53eec">m0_idx_op()</a>.  </dd>
<dt><a class="anchor" id="_todo000126"></a>Module <a class="el" href="../../df/da0/group__chan.html">chan</a>  </dt>
<dd>The next scalability improvement is to allow <a class="el" href="../../d0/d12/structm0__chan.html">m0_chan</a> to use an externally specified mutex instead of a built-in one. This would allow larger state machines with multiple channels to operate under fewer locks, reducing coherency bus traffic. </dd>
<dt><a class="anchor" id="_todo000152"></a>Module <a class="el" href="../../d2/def/group__client.html">client</a>  </dt>
<dd><p class="startdd">A library on top of client for fast scalable identifier allocation will be provided as part of Motr.</p>
<p>an interface to register 8-bit combinations for application use (to introduce application-specific "entity-like" things).</p>
<p>to be described).</p>
<p>entity type structures (to provide constructors, 8-bit identifier tags and an ability to register new entity types).</p>
<p class="enddd">handling of extensible attributes (check-sums, version numbers, etc.), which require interaction with the implementation on the service side. </p>
</dd>
<dt><a class="anchor" id="_todo000035"></a>Global <a class="el" href="../../d0/da4/group___c_m.html#ga6c94080f9e59bd9fc7ad57366334b0a7">cm_id_generate</a>  (void)</dt>
<dd>Rewrite this when mechanism to generate unique ids is in place.  </dd>
<dt><a class="anchor" id="_todo000042"></a>Global <a class="el" href="../../dc/d86/group___c_m_p_r_o_x_y.html#ga7a2507cadda55e8b86812b5bec4d28ce">cm_proxy_invariant</a>  (const struct <a class="el" href="../../d6/d1b/structm0__cm__proxy.html">m0_cm_proxy</a> *pxy)</dt>
<dd>: Add checks for pxy::px_id when uid mechanism is implemented.  </dd>
<dt><a class="anchor" id="_todo000127"></a>Module <a class="el" href="../../da/dea/group__cond.html">cond</a>  </dt>
<dd>Consider supporting other types of locks in addition to <a class="el" href="../../df/d5f/structm0__mutex.html">m0_mutex</a>. </dd>
<dt><a class="anchor" id="_todo000050"></a>Global <a class="el" href="../../df/d59/group__conf__dir.html#gace9e743e37da35c893866a1b9881dce4">conf_dir_id_build</a>  (struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *out, const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *parent, const struct <a class="el" href="../../de/d92/structm0__conf__obj__type.html">m0_conf_obj_type</a> *children_type)</dt>
<dd>This would produce non-unique identifier, if an object has two different directories with the same children types. Perhaps relation fid should be factored in somehow.  </dd>
<dt><a class="anchor" id="_todo000208"></a>Global <a class="el" href="../../dc/d55/group___net_test_u_console_internals.html#gac58d7875a0a1c5bf4da5db67d6efd9ea">config_print</a>  (struct <a class="el" href="../../de/da1/structm0__net__test__console__cfg.html">m0_net_test_console_cfg</a> *cfg)</dt>
<dd>write text  </dd>
<dt><a class="anchor" id="_todo000047"></a>Global <a class="el" href="../../d2/db5/db_8c.html#a9d2cd186e6f4b52a4f340218685815c1">confx_fill</a>  (struct <a class="el" href="../../d7/d00/structm0__confx.html">m0_confx</a> *dest, struct <a class="el" href="../../d2/d56/structm0__be__btree.html">m0_be_btree</a> *btree)</dt>
<dd><p class="startdd">check validity of key and record addresses and sizes. Specifically, check that val.b_addr points to an allocated region in a segment with appropriate size and alignment. Such checks should be done generally by (not existing) beobj interface.</p>
<p>also check that key (fid) matches <a class="el" href="../../dd/df9/group__conf__dfspec__obj.html#ga7a9de54bfbfed026c6862370d3cc9999">m0_conf_objx_fid()</a>. </p>
<p class="enddd">handle iteration errors.  </p>
</dd>
<dt><a class="anchor" id="_todo000209"></a>Global <a class="el" href="../../dc/d55/group___net_test_u_console_internals.html#ga1b2986b0ebc93c8cb4a9966c7dacca1c">console_run</a>  (struct <a class="el" href="../../d4/d46/structm0__net__test__console__ctx.html">m0_net_test_console_ctx</a> *ctx)</dt>
<dd><p class="startdd">make command line parameter </p>
<p class="enddd">can be interrupted  </p>
</dd>
<dt><a class="anchor" id="_todo000255"></a>Global <a class="el" href="../../db/de9/group__rpc.html#ga4d11dea31f4851e5a9c2a13d47303ea1">constraints_are_valid</a>  (const struct <a class="el" href="../../dc/dc5/structm0__rpc__frm__constraints.html">m0_rpc_frm_constraints</a> *constraints)</dt>
<dd>XXX Check whether constraints are consistent  </dd>
<dt><a class="anchor" id="_todo000036"></a>Page <a class="el" href="../../d9/d52/_c_m_d_l_d-fspec.html">Copy Machine Functional Specification</a>  </dt>
<dd><p class="startdd">This would be re-written when configuration api's would be implemented.</p><ul>
<li><a class="el" href="../../d0/dca/group__confc__dfspec.html#gae637e650b3c0655bae3f22b876fd27e8">m0_confc_open()</a> Opens an individual confc object. processing.</li>
</ul>
<p class="enddd">This section would be re-written when the other copy machine functionalities would be implemented.  </p>
</dd>
<dt><a class="anchor" id="_todo000034"></a>Global <a class="el" href="../../d4/d44/group__cas.html#gga73c53bacb25588538843a1dcfe5f382ba2addb49878f50c95dc669e5fdbd130a2">COUNT</a>  </dt>
<dd>Greater number of indices produces -E2BIG error in idx-deleteN test case.  </dd>
<dt><a class="anchor" id="_todo000040"></a>Global <a class="el" href="../../da/d18/group___d_l_d_c_p_internal.html#gaf71e13e80e7b1359eb27c9568e730a81">cp_fom_tick</a>  (struct <a class="el" href="../../d9/db7/structm0__fom.html">m0_fom</a> *fom)</dt>
<dd>Revise it.  </dd>
<dt><a class="anchor" id="_todo000024"></a>Global <a class="el" href="../../d2/d64/group__cas-client.html#ga3e8cff8a85c89338aa4132b23fd5c22d">creq_niter_next</a>  (struct <a class="el" href="../../de/dfe/structcreq__niter.html">creq_niter</a> *it)</dt>
<dd>Validate it.  </dd>
<dt><a class="anchor" id="_todo000120"></a>Global <a class="el" href="../../da/da0/group__io__fops.html#ga8d10b9614668eefefca2362766b06e6f">crw_ivec</a>  </dt>
<dd>Perhaps it would be easier to change client to send io_index_vec as 2 sequences (of the same length): first indices, then counts. Such sequence can be converted to <a class="el" href="../../df/da2/structm0__indexvec.html">m0_indexvec</a> without allocating intermediary structure and it might simplify client code too, if it uses indexvecs.  </dd>
<dt><a class="anchor" id="_todo000161"></a>Global <a class="el" href="../../d7/d99/conf_8c.html#a8f43f2aa7a451a8ef70f02a42701531e">cs_conf_storage_pver_is_actual</a>  (const struct <a class="el" href="../../df/da6/structm0__conf__obj.html">m0_conf_obj</a> *obj)</dt>
<dd>XXX filter only actual pool versions till formulaic pool version creation in place.  </dd>
<dt><a class="anchor" id="_todo000176"></a>Class <a class="el" href="../../d9/dc9/structcs__stob__file.html">cs_stob_file</a>  </dt>
<dd>XXX FIXME: confc has landed ages ago.  </dd>
<dt><a class="anchor" id="_todo000172"></a>Global <a class="el" href="../../df/dca/group__m0d.html#ga14766ef1be99cbb17fb0693ee010c14e">cs_storage_init</a>  (const char *stob_type, const char *stob_path, uint64_t dom_key, struct <a class="el" href="../../d0/dbf/structcs__stobs.html">cs_stobs</a> *stob, struct <a class="el" href="../../d4/d9b/structm0__be__seg.html">m0_be_seg</a> *seg, bool mkfs, bool force, bool disable_direct_io)</dt>
<dd>Use generic mechanism to generate stob ids  </dd>
<dt><a class="anchor" id="_todo000175"></a>Global <a class="el" href="../../df/dca/group__m0d.html#gad22b54ab465ef49ef417a96db8476cdb">cs_storage_setup</a>  (struct <a class="el" href="../../d1/ddd/structm0__motr.html">m0_motr</a> *cctx)</dt>
<dd>Have a generic mechanism to generate unique cob domain id. Handle error messages properly.  </dd>
<dt><a class="anchor" id="_todo000177"></a>Global <a class="el" href="../../d5/ded/cs__ut__main_8c.html#a92571f45006c1b12586b9888483a233a">cs_ut_ep_mixed_dup_cmd</a>  []</dt>
<dd>Remove passing of multiple endpoints to m0d, as is not needed.  </dd>
<dt><a class="anchor" id="_todo000067"></a>Module <a class="el" href="../../dc/d7e/group__desim.html">desim</a>  </dt>
<dd>add m0_ prefixes to sim symbols. </dd>
<dt><a class="anchor" id="_todo000136"></a>Page <a class="el" href="../../d3/df4/rmw_io_dld.html">Detailed Level Design for read-modify-write IO requests.</a>  </dt>
<dd><p class="startdd">In future, optimizations could be done in order to speed up small file IO with the help of client side cache.</p>
<p>IO types like fault IO are not supported yet.</p>
<p>A client cache is missing at the moment. With addition of cache, the states of an IO request might add up.</p>
<p>In future, with introduction of Resource Manager, distributed extent locks have to be acquired or released as needed.</p>
<p class="enddd">However, with all code in kernel and no present UT code for m0t1fs, it is still to be decided how to write UTs for this component. </p>
</dd>
<dt><a class="anchor" id="_todo000075"></a>Page <a class="el" href="../../d2/dcf/dtm.html">Distributed transaction manager</a>  </dt>
<dd><p class="startdd">Internal declarations leak in the global name-space. This should be fixed by making them static and including dtm .c files in a single dtm/dtm.c file.</p>
<p class="enddd">pack, unpack, fop. </p>
</dd>
<dt><a class="anchor" id="_todo000069"></a>Page <a class="el" href="../../dd/d83/_d_i_x_c_m_d_l_d.html">DIX copy machine DLD</a>  </dt>
<dd>It would be nice to find the solution where implementation of any kind of aggregation groups is not necessary.<ul>
<li>For rebalance, the same rule to determine responsible node for data reconstruction can be applied. DIX copy machine uses the same layout as used during DIX repair to map a unit to the target unit on new device. The newly added device may have a new UUID, but will have the same index in the pool and the component catalogues identifiers of the failed device and the replacement device will also be the same. </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000074"></a>Global <a class="el" href="../../dd/d33/group__dix.html#ga2ce8b0a84a9b99c99dbf8c0ccab43a1d">dix_cas_rops_send</a>  (struct <a class="el" href="../../dd/d4f/structm0__dix__req.html">m0_dix_req</a> *req)</dt>
<dd>CAS request should copy cctg_id internally.  </dd>
<dt><a class="anchor" id="_todo000068"></a>Global <a class="el" href="../../da/d88/group___d_i_x_c_m_a_g.html#ga0b8d1184cfaf68af81cb65fdfd56e041">dix_cm_ag_is_frozen_on</a>  (struct <a class="el" href="../../d6/d14/structm0__cm__aggr__group.html">m0_cm_aggr_group</a> *ag, struct <a class="el" href="../../d6/d1b/structm0__cm__proxy.html">m0_cm_proxy</a> *pxy)</dt>
<dd>What to return here?  </dd>
<dt><a class="anchor" id="_todo000070"></a>Global <a class="el" href="../../de/d70/group___d_i_x_c_m.html#ga0e24e450d7b42a43622d4ddba3014ff6">dix_cm_iter_trans</a>  []</dt>
<dd>Revise this array.  </dd>
<dt><a class="anchor" id="_todo000166"></a>Global <a class="el" href="../../d5/db4/structdix__inst.html#a551cf91a995d0905b632247a17b6312a">dix_inst::di_index_pver</a>  </dt>
<dd>This field is temporary. Client interface should be extended, so user can define pool version for an index. Use constant pool version until this is done. Actually, this pool version equals to the one used for root index, which is defined in filesystem configuration object.  </dd>
<dt><a class="anchor" id="_todo000165"></a>Global <a class="el" href="../../d2/d61/group__index-dix.html#gaa41e336a8f6c4ef70712aaf1691aac6d">dix_next_ast</a>  (struct <a class="el" href="../../d5/d32/structm0__sm__group.html">m0_sm_group</a> *grp, struct <a class="el" href="../../de/d78/structm0__sm__ast.html">m0_sm_ast</a> *ast)</dt>
<dd>Currently there is no way to pass several starting keys along with number of consecutive records for each key through <a class="el" href="../../d2/def/group__client.html#ga94dc4391285a0716a064d19748c53eec">m0_idx_op()</a>.  </dd>
<dt><a class="anchor" id="_todo000073"></a>Global <a class="el" href="../../dd/d33/group__dix.html#ga6a08cc7b741ab6390493d1cf7dc2383c">dix_req_trans</a>  []</dt>
<dd>Check it.  </dd>
<dt><a class="anchor" id="_todo000116"></a>Page <a class="el" href="../../db/d58/_d_l_d-bulk-server.html">DLD of Bulk Server</a>  </dt>
<dd>If buffer_pool reached to low threshold, Bulk I/O service may expand pool size. This can be done later to minimize waiting time for network buffer. </dd>
<dt><a class="anchor" id="_todo000055"></a>Page <a class="el" href="../../d2/dd9/conf.html">DLD of configuration caching</a>  </dt>
<dd>Implement cache eviction. </dd>
<dt><a class="anchor" id="_todo000087"></a>Global <a class="el" href="../../d9/d6b/plugin__dock_8c.html#add6efb609c571ac4678a18d836c62f61">enable_filters</a>  (bool enable, struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *filter_ids, uint32_t filter_count)</dt>
<dd>Phase 2: implement posting filter descriptions to filterd  </dd>
<dt><a class="anchor" id="_todo000082"></a>Global <a class="el" href="../../db/d55/flt__eval_8c.html#ad802c69a4c5e8933630af987082ca785">eval_flt_node</a>  (struct <a class="el" href="../../d5/d9d/structm0__fdmi__eval__ctx.html">m0_fdmi_eval_ctx</a> *ctx, struct <a class="el" href="../../d3/d4c/structm0__fdmi__flt__node.html">m0_fdmi_flt_node</a> *node, struct <a class="el" href="../../d6/d0b/structm0__fdmi__flt__operand.html">m0_fdmi_flt_operand</a> *res, struct <a class="el" href="../../d8/d6b/structm0__fdmi__eval__var__info.html">m0_fdmi_eval_var_info</a> *var_info)</dt>
<dd>Free resources from operands?  </dd>
<dt><a class="anchor" id="_todo000292"></a>Global <a class="el" href="../../d6/d2c/group__stobad.html#gaf8949dc21052d88b103d7c0ecc67f715">ext_punch</a>  (struct <a class="el" href="../../d1/d0a/structm0__stob.html">m0_stob</a> *stob, struct <a class="el" href="../../de/d0f/structm0__dtx.html">m0_dtx</a> *tx, struct <a class="el" href="../../dc/d91/structm0__ext.html">m0_ext</a> *todo)</dt>
<dd>the target ext to delete, which will be marked as a hole.  </dd>
<dt><a class="anchor" id="_todo000268"></a>Global <a class="el" href="../../da/d46/parity__math_8c.html#a80336a3c586b8a9809a3c92eb21a57dd">fail_idx_reed_solomon_recover</a>  (struct <a class="el" href="../../dc/d05/structm0__parity__math.html">m0_parity_math</a> *math, struct <a class="el" href="../../de/d06/structm0__buf.html">m0_buf</a> *data, struct <a class="el" href="../../de/d06/structm0__buf.html">m0_buf</a> *parity, const uint32_t failure_index)</dt>
<dd>Iterative reed-solomon decode to be implemented.  </dd>
<dt><a class="anchor" id="_todo000079"></a>Module <a class="el" href="../../d8/de2/group___f_d_m_i___d_l_d__fspec__filter.html">FDMI_DLD_fspec_filter</a>  </dt>
<dd>Insert example of usage here  </dd>
<dt><a class="anchor" id="_todo000062"></a>Global <a class="el" href="../../d3/de4/fdmi__filter_8c.html#abe195d7eab40d6b024241037f09c47b1">fdmi_filter_check</a>  (const void *bob)</dt>
<dd>Phase 2: Do checks  </dd>
<dt><a class="anchor" id="_todo000096"></a>Global <a class="el" href="../../d0/d55/source__dock__fom_8c.html#affe438c1d63a6841728891f2217a2461">fdmi_post_fop</a>  (struct <a class="el" href="../../d5/d01/structm0__fop.html">m0_fop</a> *fop, struct <a class="el" href="../../dd/d65/structm0__rpc__session.html">m0_rpc_session</a> *session)</dt>
<dd>what deadline is better? (phase 2)  </dd>
<dt><a class="anchor" id="_todo000084"></a>Global <a class="el" href="../../dd/dc6/group__fdmi__fol__src.html#ga1b72326f4219f4bcad518494f960af1a">ffs_op_encode</a>  (struct <a class="el" href="../../d4/d48/structm0__fdmi__src__rec.html">m0_fdmi_src_rec</a> *src_rec, struct <a class="el" href="../../de/d06/structm0__buf.html">m0_buf</a> *buf)</dt>
<dd>Q: (for FOL owners) FOL record does not provide API call to calculate record size when encoded. For now, I'll do double allocation. Alloc internal buf of max size, then encode, then alloc with correct size, then copy, then dealloc inernal buf. Can be done properly once FOL record owner exports needed api call.  </dd>
<dt><a class="anchor" id="_todo000083"></a>Global <a class="el" href="../../dd/dc6/group__fdmi__fol__src.html#ga5ee22d1a77f04f6189f029f7b8af5b6f">ffs_op_node_eval</a>  (struct <a class="el" href="../../d4/d48/structm0__fdmi__src__rec.html">m0_fdmi_src_rec</a> *src_rec, struct <a class="el" href="../../d4/dcf/structm0__fdmi__flt__var__node.html">m0_fdmi_flt_var_node</a> *value_desc, struct <a class="el" href="../../d6/d0b/structm0__fdmi__flt__operand.html">m0_fdmi_flt_operand</a> *value)</dt>
<dd>Phase 2: STUB: For now, we will not analyze filter, we just return FOL op code &ndash; always.  </dd>
<dt><a class="anchor" id="_todo000101"></a>Global <a class="el" href="../../da/ddd/group___file_lock_internal.html#gaa57531f8f571425f6c2dc4eda584fcd2">file_lock_encdec</a>  (struct <a class="el" href="../../d8/d89/structm0__file.html">m0_file</a> *file, struct <a class="el" href="../../d5/d06/structm0__bufvec__cursor.html">m0_bufvec_cursor</a> *cur, enum m0_xcode_what what)</dt>
<dd>-&gt;rto_decode() decode for file resource should create an entire ambient object: an inode on client and a cob on server.  </dd>
<dt><a class="anchor" id="_todo000103"></a>Module <a class="el" href="../../d1/d59/group__fom.html">fom</a>  </dt>
<dd><p class="startdd">load balancing is not implemented at the moment).</p>
<p class="enddd">describe intended fom and reqh usage on client. </p>
</dd>
<dt><a class="anchor" id="_todo000106"></a>Global <a class="el" href="../../d1/d59/group__fom.html#ga08dafe949bab75b3ee9bfa51661fe277">fom_failure</a>  (struct <a class="el" href="../../d9/db7/structm0__fom.html">m0_fom</a> *fom)</dt>
<dd>workaround to move be transaction into FAILED state, so that it can be finalised.  </dd>
<dt><a class="anchor" id="_todo000107"></a>Global <a class="el" href="../../d1/d59/group__fom.html#ga608cc6a382afea32599545e65cf7e692">fom_queue_reply</a>  (struct <a class="el" href="../../d9/db7/structm0__fom.html">m0_fom</a> *fom)</dt>
<dd>Implement write back cache, during which we may perform updates on local objects and re-integrate with the server later, in that case we may block while, we caching fop, this requires more additions to the routine.  </dd>
<dt><a class="anchor" id="_todo000256"></a>Global <a class="el" href="../../db/de9/group__rpc.html#gab8b05479a023472290e68ab0d775235a">frm_try_merging_item</a>  (struct <a class="el" href="../../d7/d0f/structm0__rpc__frm.html">m0_rpc_frm</a> *frm, struct <a class="el" href="../../de/d21/structm0__rpc__item.html">m0_rpc_item</a> *item, m0_bcount_t limit)</dt>
<dd>XXX implement item merging  </dd>
<dt><a class="anchor" id="_todo000194"></a>Page <a class="el" href="../../d9/d5d/net-test-fspec.html">Functional Specification</a>  </dt>
<dd>Outdated and not used now </dd>
<dt><a class="anchor" id="_todo000109"></a>Global <a class="el" href="../../db/dec/group__ha.html#gae07ae4e007378c25501fc3504e990235">ha_client_release</a>  (struct <a class="el" href="../../dd/d3f/structm0__ref.html">m0_ref</a> *ref)</dt>
<dd>: Is it possible to move {<a class="el" href="../../d5/d1b/structm0.html">m0</a>}_ha_client_* functions to ha/note.[ch] files? Seems that functionality is related to HA notifications.  </dd>
<dt><a class="anchor" id="_todo000115"></a>Global <a class="el" href="../../de/d4a/group__m0ham.html#ga3f20d0bd202db077d213416a71160173">ha_msg_is_one_way</a>  (const struct <a class="el" href="../../da/d97/structm0__ha__msg.html">m0_ha_msg</a> *msg)</dt>
<dd>Move to ha/msg.[hc].  </dd>
<dt><a class="anchor" id="_todo000098"></a>Global <a class="el" href="../../d0/d0a/fdmi__echo_8c.html#a3d196ce447c5416818e5e2d0b6be1b44">handle_fdmi_rec_not</a>  (struct <a class="el" href="../../d0/db4/structm0__uint128.html">m0_uint128</a> *rec_id, struct <a class="el" href="../../de/d06/structm0__buf.html">m0_buf</a> fdmi_rec, struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> filter_id)</dt>
<dd><p class="startdd">Call decode for fdmi record type (frt_rec_decode) </p>
<p class="enddd">Consider special ret code if processing is complete ?  </p>
</dd>
<dt><a class="anchor" id="_todo000132"></a>Global <a class="el" href="../../db/dcd/m0t1fs_2linux__kernel_2dir_8c.html#a1abb645bd31dbfcfcc37ec2e7e2914c4">if</a>  (rc !=0)</dt>
<dd>When we have rm locking working, this will be changed to revalidate inode with checking cached lock. If lock is cached (not canceled), which means inode did not change, then we don't have to do getattr and can just use  cached data.  </dd>
<dt><a class="anchor" id="_todo000231"></a>Global <a class="el" href="../../d2/deb/group__rm.html#gaa5aa3c8b4ee05f0f28297629e0004645">incoming_check</a>  (struct <a class="el" href="../../d3/db4/structm0__rm__incoming.html">m0_rm_incoming</a> *in)</dt>
<dd>Here we introduce "thundering herd" problem, potentially waking up all requests waiting for reserved credit. It is necessary, because rio_conflict() won't be called for 'in' if waiting requests are not woken up.  </dd>
<dt><a class="anchor" id="_todo000232"></a>Global <a class="el" href="../../d2/deb/group__rm.html#gaf4a42b2356827729b907fbab7b000174">incoming_check_held</a>  (struct <a class="el" href="../../d3/db4/structm0__rm__incoming.html">m0_rm_incoming</a> *in, struct <a class="el" href="../../d6/d46/structm0__rm__credit.html">m0_rm_credit</a> *rest, struct <a class="el" href="../../d6/d46/structm0__rm__credit.html">m0_rm_credit</a> *held, int *wait, bool *cr_used)</dt>
<dd>Ignore borrow requests for held non-conflicting credits. If it is the only credit that can satisfy incoming request, then eventually creditor will revoke it. </dd>
<dt><a class="anchor" id="_todo000233"></a>Global <a class="el" href="../../d2/deb/group__rm.html#ga7273c95e912cde4724ebf9b50c9b998f">incoming_check_with</a>  (struct <a class="el" href="../../d3/db4/structm0__rm__incoming.html">m0_rm_incoming</a> *in, struct <a class="el" href="../../d6/d46/structm0__rm__credit.html">m0_rm_credit</a> *credit)</dt>
<dd>Will be deleted once borrowing held non-conflicting credits is allowed.  </dd>
<dt><a class="anchor" id="_todo000118"></a>Global <a class="el" href="../../da/dda/io__fops_8c.html#a69a053d5bb7f5c25d68a27686209f9e3">io_item_replied</a>  (struct <a class="el" href="../../de/d21/structm0__rpc__item.html">m0_rpc_item</a> *item)</dt>
<dd>Rearrange IO item merging code to work with new formation code.  </dd>
<dt><a class="anchor" id="_todo000224"></a>Global <a class="el" href="../../dd/d7f/group__pool.html#ga8b8775e372ce608995fcd1a9fada5448">is_actual_pver</a>  (const struct <a class="el" href="../../df/da6/structm0__conf__obj.html">m0_conf_obj</a> *obj)</dt>
<dd>XXX filter only actual pool versions till formulaic pool version creation in place.  </dd>
<dt><a class="anchor" id="_todo000135"></a>Global <a class="el" href="../../d0/dec/m0t1fs_2linux__kernel_2file_8c.html#a17a7067918a13e5c4dcd0976998cfe75">is_session_marked</a>  (struct <a class="el" href="../../d6/d09/structio__request.html">io_request</a> *req, struct <a class="el" href="../../dd/d65/structm0__rpc__session.html">m0_rpc_session</a> *session)</dt>
<dd>This code is not required once MOTR-899 lands into dev. Returns true if a given session is already marked as failed. In case a session is not already marked for failure, the functions marks it and returns false.  </dd>
<dt><a class="anchor" id="_todo000170"></a>Global <a class="el" href="../../d7/dde/io__req_8c.html#ae1b86e12c2942a8d327a94f9ad1022aa">is_session_marked</a>  (struct <a class="el" href="../../d0/d6f/structm0__op__io.html">m0_op_io</a> *ioo, struct <a class="el" href="../../dd/d65/structm0__rpc__session.html">m0_rpc_session</a> *session)</dt>
<dd>This code is not required once MOTR-899 lands into dev. Returns true if a given session is already marked as failed. In case a session is not already marked for failure, the functions marks it and returns false.  </dd>
<dt><a class="anchor" id="_todo000071"></a>Global <a class="el" href="../../d0/df1/iter__ut_8c.html#a35a82750c755379ad90addce7bd362d9">iter_ut_pool_init</a>  ()</dt>
<dd>Ugly workaround to do finalisation successfully.  </dd>
<dt><a class="anchor" id="_todo000304"></a>Global <a class="el" href="../../da/da8/group__layout.html#ga4a148931f8df120a1dc437f4f68864dc">layout_demo</a>  (struct <a class="el" href="../../d9/d8c/structm0__pdclust__instance.html">m0_pdclust_instance</a> *pi, struct <a class="el" href="../../d3/d0d/structm0__pdclust__layout.html">m0_pdclust_layout</a> *pl, int R, int I, bool print)</dt>
<dd>Allocate the arrays globally so that it does not result into going beyond the stack limit in the kernel mode.  </dd>
<dt><a class="anchor" id="_todo000303"></a>Global <a class="el" href="../../d9/d6a/group__stob.html#ga93c429e52c48902220420789557ff868">linux_location</a>  []</dt>
<dd>move vars to a context  </dd>
<dt><a class="anchor" id="_todo000128"></a>Global <a class="el" href="../../d7/ded/group__memory.html#gae1f81f1d1e1010185992fcac1fae7a14">m0_arch_alloc</a>  (size_t size)</dt>
<dd>The proper solution is to introduce an additional interface m0_alloc_safe(), to be called outside of critical locks and using GFP_KERNEL.  </dd>
<dt><a class="anchor" id="_todo000003"></a>Class <a class="el" href="../../d7/d1e/structm0__be__io__credit.html">m0_be_io_credit</a>  </dt>
<dd>add bshift  </dd>
<dt><a class="anchor" id="_todo000005"></a>Global <a class="el" href="../../dd/d9f/structm0__be__log.html#afc4a996f7188014c506d7d9f1e8b0ee7">m0_be_log::lg_store</a>  </dt>
<dd>this might be changed to something more complicated to support flexible deployment and grow-able logs. E.g., a log can be stored in a sequence of regions in segments, linked to each other through header blocks.  </dd>
<dt><a class="anchor" id="_todo000006"></a>Class <a class="el" href="../../dc/dbe/structm0__be__log__io.html">m0_be_log_io</a>  </dt>
<dd>document fields owned by <a class="el" href="../../dd/d9f/structm0__be__log.html">m0_be_log</a> and move fields reset there  </dd>
<dt><a class="anchor" id="_todo000007"></a>Global <a class="el" href="../../d9/dcf/group__be.html#ga773aa57c6ed05a422dea06492682a3f5">m0_be_log_store_io_translate</a>  (struct <a class="el" href="../../d7/d2f/structm0__be__log__store.html">m0_be_log_store</a> *ls, m0_bindex_t position, struct <a class="el" href="../../d4/d36/structm0__be__io.html">m0_be_io</a> *bio)</dt>
<dd>s/io_prepare/io_translate/g  </dd>
<dt><a class="anchor" id="_todo000008"></a>Global <a class="el" href="../../d9/dcf/group__be.html#ga8ac74e913cf7803dddc668f37c3fe953">m0_be_log_store_rbuf_write_buf</a>  (struct <a class="el" href="../../d7/d2f/structm0__be__log__store.html">m0_be_log_store</a> *ls)</dt>
<dd>Make interface for redundant buffer simplier. </dd>
<dt><a class="anchor" id="_todo000010"></a>Global <a class="el" href="../../d9/dcf/group__be.html#ga9861d7a063ffbd4d79e06510f62ed575">m0_be_reg__invariant</a>  (const struct <a class="el" href="../../d1/dfe/structm0__be__reg.html">m0_be_reg</a> *reg)</dt>
<dd>make m0_be_reg_copy_to(reg, dst_addr) and m0_be_reg_copy_from(reg, src_addr)  </dd>
<dt><a class="anchor" id="_todo000011"></a>Global <a class="el" href="../../d9/dcf/group__be.html#gaef0e0dd82903d9d1d8803278b8d15721">m0_be_reg_gen_idx</a>  (const struct <a class="el" href="../../d1/dfe/structm0__be__reg.html">m0_be_reg</a> *reg)</dt>
<dd>add UT similar to libm0-ut:time.  </dd>
<dt><a class="anchor" id="_todo000009"></a>Global <a class="el" href="../../d9/dcf/group__be.html#ga4aee752ddf6ee88c1c6d4b82773664c9">m0_be_seg_reserved</a>  (const struct <a class="el" href="../../d4/d9b/structm0__be__seg.html">m0_be_seg</a> *seg)</dt>
<dd>s/bs_reserved/m0_be_seg_reserved/ everywhere  </dd>
<dt><a class="anchor" id="_todo000016"></a>Global <a class="el" href="../../d2/d7e/structm0__be__tx.html#a11466df2ddd9d17c07b5976d101d8b0d">m0_be_tx::t_fast</a>  </dt>
<dd>Remove when <a class="el" href="../../d5/d54/be_2linux__kernel_2stubs_8c.html#ga425a6b9557988c9cf2f48f52baa4ec90">m0_be_tx_close_sync()</a> is removed  </dd>
<dt><a class="anchor" id="_todo000018"></a>Global <a class="el" href="../../d2/d7e/structm0__be__tx.html#aa862e216ae9fbfb04d5ee732a0eacb2e">m0_be_tx::t_fdmi_put_ast</a>  </dt>
<dd>Will be fixed when proper refcounting is implemented in second phase of FDMI work.  </dd>
<dt><a class="anchor" id="_todo000017"></a>Global <a class="el" href="../../d2/d7e/structm0__be__tx.html#ac269a746bd24299acfdb9e6458741e33">m0_be_tx::t_fdmi_ref</a>  </dt>
<dd>Fix this when proper refcounting is implemented.  </dd>
<dt><a class="anchor" id="_todo000015"></a>Global <a class="el" href="../../d2/d7e/structm0__be__tx.html#ab0a367dec7f4197c40b1a07ba3797ddd">m0_be_tx::t_payload</a>  </dt>
<dd><p class="startdd">Don't allocate <a class="el" href="../../d2/d7e/structm0__be__tx.html#ab0a367dec7f4197c40b1a07ba3797ddd">m0_be_tx::t_payload</a> separately. Use <a class="el" href="../../d6/d07/structm0__be__tx__group.html">m0_be_tx_group</a> preallocated payload area. </p>
<p class="enddd">Use <a class="el" href="../../d2/d7e/structm0__be__tx.html#aa5c98203f3269b87146ae01a42485e74">m0_be_tx::t_filler</a> callback to fill <a class="el" href="../../d2/d7e/structm0__be__tx.html#ab0a367dec7f4197c40b1a07ba3797ddd">m0_be_tx::t_payload</a>.  </p>
</dd>
<dt><a class="anchor" id="_todo000014"></a>Global <a class="el" href="../../d9/dcf/group__be.html#gaf5d6d95cec602b664b3917b8a29322b7">m0_be_tx__is_fast</a>  (struct <a class="el" href="../../d2/d7e/structm0__be__tx.html">m0_be_tx</a> *tx)</dt>
<dd>Remove when <a class="el" href="../../d5/d54/be_2linux__kernel_2stubs_8c.html#ga425a6b9557988c9cf2f48f52baa4ec90">m0_be_tx_close_sync()</a> is removed.  </dd>
<dt><a class="anchor" id="_todo000019"></a>Global <a class="el" href="../../d9/dcf/group__be.html#ga44624d657671890cd11fd7cc2a9b7317">m0_be_tx_group_fom_init</a>  (struct <a class="el" href="../../d4/da4/structm0__be__tx__group__fom.html">m0_be_tx_group_fom</a> *m, struct <a class="el" href="../../d6/d07/structm0__be__tx__group.html">m0_be_tx_group</a> *gr, struct <a class="el" href="../../d9/da2/structm0__reqh.html">m0_reqh</a> *reqh)</dt>
<dd>XXX TODO s/gf/m/ in function parameters  </dd>
<dt><a class="anchor" id="_todo000021"></a>Global <a class="el" href="../../dd/d4c/be_2ut_2main_8c.html#a0a45def04e96f4b0eefaa4609ed46e8b">m0_be_ut_log_store_create_simple</a>  (void)</dt>
<dd>use ls_cfg_create and ls_cfg_open to test that create parameters aren't used in open()  </dd>
<dt><a class="anchor" id="_todo000022"></a>Class <a class="el" href="../../df/d40/structm0__capa__issuer.html">m0_capa_issuer</a>  </dt>
<dd>Use proper capability issuer  </dd>
<dt><a class="anchor" id="_todo000038"></a>Global <a class="el" href="../../d0/da4/group___c_m.html#ga0d72f0ea02bcd564badf77bfc2851ff2">m0_cm_configure</a>  (struct <a class="el" href="../../dd/df9/structm0__cm.html">m0_cm</a> *cm, struct <a class="el" href="../../d5/d01/structm0__fop.html">m0_fop</a> *fop)</dt>
<dd>Pass actual configuration fop data structure once configuration interfaces and datastructures are available.  </dd>
<dt><a class="anchor" id="_todo000039"></a>Global <a class="el" href="../../d0/da4/group___c_m.html#ga68b2932d73eb35e41b83fb578eaadace">m0_cm_fail</a>  (struct <a class="el" href="../../dd/df9/structm0__cm.html">m0_cm</a> *cm, int rc)</dt>
<dd>Rewrite this function when new ADDB infrastucture is in place.  </dd>
<dt><a class="anchor" id="_todo000043"></a>Global <a class="el" href="../../d3/d8e/group__cob.html#ga7e88d5c1356b043ef1233196c39a81dd">m0_cob_init</a>  (struct <a class="el" href="../../d5/d0f/structm0__cob__domain.html">m0_cob_domain</a> *dom, struct <a class="el" href="../../de/d54/structm0__cob.html">m0_cob</a> *cob)</dt>
<dd>Get di type from configuration.  </dd>
<dt><a class="anchor" id="_todo000054"></a>Global <a class="el" href="../../df/d22/conf_2helpers_8h.html#a52b0e8fce1b72a4b443ebb1f8d9fee8d">m0_conf_confc_ha_update</a>  (struct <a class="el" href="../../dd/d03/structm0__confc.html">m0_confc</a> *confc)</dt>
<dd>XXX RELOCATEME: This function belongs ha subsystem, not conf. </dd>
<dt><a class="anchor" id="_todo000051"></a>Global <a class="el" href="../../df/d59/group__conf__dir.html#gab086091155a03f0b3ce88e9d07c6bed7">m0_conf_dir_new</a>  (struct <a class="el" href="../../df/da6/structm0__conf__obj.html">m0_conf_obj</a> *parent, const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *relfid, const struct <a class="el" href="../../de/d92/structm0__conf__obj__type.html">m0_conf_obj_type</a> *children_type, const struct <a class="el" href="../../d6/d9f/structm0__fid__arr.html">m0_fid_arr</a> *children_ids, struct <a class="el" href="../../d6/d1b/structm0__conf__dir.html">m0_conf_dir</a> **out)</dt>
<dd>UT transactional property of <a class="el" href="../../df/d59/group__conf__dir.html#gab086091155a03f0b3ce88e9d07c6bed7">m0_conf_dir_new()</a>.  </dd>
<dt><a class="anchor" id="_todo000053"></a>Global <a class="el" href="../../df/d22/conf_2helpers_8h.html#a435e9ce796909b9d277f2043a9d5538a">m0_conf_obj_ha_update</a>  (const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *obj_fid)</dt>
<dd>XXX RELOCATEME: This function belongs ha subsystem, not conf.  </dd>
<dt><a class="anchor" id="_todo000052"></a>Global <a class="el" href="../../df/d22/conf_2helpers_8h.html#a6528cb902ea32bd458cdff4cc1073d2d">m0_conf_objs_ha_update</a>  (struct <a class="el" href="../../d2/d08/structm0__ha__nvec.html">m0_ha_nvec</a> *nvec)</dt>
<dd>XXX RELOCATEME: This function belongs ha subsystem, not conf. </dd>
<dt><a class="anchor" id="_todo000058"></a>Global <a class="el" href="../../d7/d83/structm0__conf__pool.html#a9652e408f913a7de392aa16b226a7842">m0_conf_pool::pl_pver_policy</a>  </dt>
<dd>Replace with m0_conf_root::rt_pool_selection_policy.  </dd>
<dt><a class="anchor" id="_todo000059"></a>Global <a class="el" href="../../d6/d95/structm0__conf__process.html#a8b029eaeef61cc9c70d67690bdb311fd">m0_conf_process::pc_endpoint</a>  </dt>
<dd>Use an array to support several network interfaces.  </dd>
<dt><a class="anchor" id="_todo000056"></a>Global <a class="el" href="../../d5/d7c/structm0__conf__root.html#ac48565c75a7e2ddbf39a2f185107b2aa">m0_conf_root::rt_fdmi_flt_grps</a>  </dt>
<dd>Halon support is yet to be implemented; see HALON-730.  </dd>
<dt><a class="anchor" id="_todo000057"></a>Global <a class="el" href="../../d5/d7c/structm0__conf__root.html#a0e02d5b45a3acd46cf0634536340378b">m0_conf_root::rt_params</a>  </dt>
<dd>Make it an array of name-value pairs (attributes).  </dd>
<dt><a class="anchor" id="_todo000061"></a>Global <a class="el" href="../../db/dca/structm0__conf__sdev.html#a43b3adc11dbaef8a5de1b416d4beed90">m0_conf_sdev::sd_drive</a>  </dt>
<dd>XXX DELETEME  </dd>
<dt><a class="anchor" id="_todo000060"></a>Global <a class="el" href="../../d3/d7c/structm0__conf__service.html#a066f6642679f8099c9024535838b1d00">m0_conf_service::cs_params</a>  </dt>
<dd>Make it an array of name-value pairs (attributes).  </dd>
<dt><a class="anchor" id="_todo000031"></a>Global <a class="el" href="../../d9/d21/group__cas-ctg-store.html#gaad3278e106ec819ea1d978d7c4ecd9c8">m0_ctg_ctidx_delete_sync</a>  (const struct <a class="el" href="../../d9/d1d/structm0__cas__id.html">m0_cas_id</a> *cid, struct <a class="el" href="../../d2/d7e/structm0__be__tx.html">m0_be_tx</a> *tx)</dt>
<dd>Make it asynchronous.  </dd>
<dt><a class="anchor" id="_todo000029"></a>Global <a class="el" href="../../d9/d21/group__cas-ctg-store.html#gabc4234ad8946e2503833059a05d1e385">m0_ctg_ctidx_insert_sync</a>  (const struct <a class="el" href="../../d9/d1d/structm0__cas__id.html">m0_cas_id</a> *cid, struct <a class="el" href="../../d2/d7e/structm0__be__tx.html">m0_be_tx</a> *tx)</dt>
<dd>Make it asynchronous.  </dd>
<dt><a class="anchor" id="_todo000028"></a>Global <a class="el" href="../../d9/d21/group__cas-ctg-store.html#ga576466c3cfa911352a6b0e7402ae6fdd">m0_ctg_ctidx_lookup_sync</a>  (const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *fid, struct <a class="el" href="../../d5/d04/structm0__dix__layout.html">m0_dix_layout</a> **layout)</dt>
<dd>Make it asynchronous.  </dd>
<dt><a class="anchor" id="_todo000026"></a>Global <a class="el" href="../../d9/d21/group__cas-ctg-store.html#ga928178a243e4997ae317baf217352973">m0_ctg_store_init</a>  (struct <a class="el" href="../../d5/d1b/structm0__be__domain.html">m0_be_domain</a> *dom)</dt>
<dd>Use 0type.  </dd>
<dt><a class="anchor" id="_todo000077"></a>Global <a class="el" href="../../de/d0f/structm0__dtx.html#a5c2f69472061943f245a1e9f9c51eec7">m0_dtx::tx_state</a>  </dt>
<dd>placeholder for now.  </dd>
<dt><a class="anchor" id="_todo000090"></a>Global <a class="el" href="../../d6/dc3/group__fdmi__sd__int.html#gacc2caa412499b0d67e20f5882103842e">m0_fdmi__rec_id_gen</a>  (struct <a class="el" href="../../d4/d48/structm0__fdmi__src__rec.html">m0_fdmi_src_rec</a> *src_rec)</dt>
<dd>Phase 2: <a class="el" href="../../d6/dc3/group__fdmi__sd__int.html#gacc2caa412499b0d67e20f5882103842e">m0_fdmi__rec_id_gen()</a> should return unique ID within whole Motr system. Some generic function should be used. For this moment, to provide unique values within several running Motr instances, lets populate hi value part with rand value, low part will be incremented. As a bare minimum, for phase 2 we need to make sure fsdc_instance_id is globally unique, and that re-start generates a new one, again globally unique. (Note this is required, if we leave the same ID over restart, new instance will try to process replies aimed at previous one.  </dd>
<dt><a class="anchor" id="_todo000093"></a>Global <a class="el" href="../../d6/dc3/group__fdmi__sd__int.html#ga3c212c7128d6d40e45207375eb74b4a1">m0_fdmi__src_dock_fom_start</a>  (struct <a class="el" href="../../d3/dbb/structm0__fdmi__src__dock.html">m0_fdmi_src_dock</a> *src_dock, const struct <a class="el" href="../../d1/d1a/structm0__filterc__ops.html">m0_filterc_ops</a> *filterc_ops, struct <a class="el" href="../../d9/da2/structm0__reqh.html">m0_reqh</a> *reqh)</dt>
<dd>FDMI service can't work without filterc. inform ADDB on critical error.  </dd>
<dt><a class="anchor" id="_todo000094"></a>Global <a class="el" href="../../d6/dc3/group__fdmi__sd__int.html#gad0d1bb4ef9276d5469522a6beb9f3079">m0_fdmi__src_dock_fom_wakeup</a>  (struct <a class="el" href="../../de/d0e/structfdmi__sd__fom.html">fdmi_sd_fom</a> *sd_fom)</dt>
<dd>Small possibility of races exist (Phase 2).  </dd>
<dt><a class="anchor" id="_todo000088"></a>Class <a class="el" href="../../d4/ddb/structm0__fdmi__filter__desc.html">m0_fdmi_filter_desc</a>  </dt>
<dd>Phase 2: Internals will be understood during further development  </dd>
<dt><a class="anchor" id="_todo000078"></a>Global <a class="el" href="../../d8/de2/group___f_d_m_i___d_l_d__fspec__filter.html#ga37b58a5da251076e1a674414de3c9928">m0_fdmi_flt_op_node_create</a>  (enum m0_fdmi_flt_op_code op_code, struct <a class="el" href="../../d3/d4c/structm0__fdmi__flt__node.html">m0_fdmi_flt_node</a> *left, struct <a class="el" href="../../d3/d4c/structm0__fdmi__flt__node.html">m0_fdmi_flt_node</a> *right)</dt>
<dd>Per-operation code check for number of operands and its types (phase 2)  </dd>
<dt><a class="anchor" id="_todo000092"></a>Global <a class="el" href="../../d0/de2/group__fdmi__sd.html#ga421c5e68bc554fcc0b0e892c4a65e204">m0_fdmi_source_register</a>  (struct <a class="el" href="../../d8/d9c/structm0__fdmi__src.html">m0_fdmi_src</a> *src)</dt>
<dd>Phase 2: Check that fdmi_rec_type_id exists  </dd>
<dt><a class="anchor" id="_todo000102"></a>Global <a class="el" href="../../d1/d59/group__fom.html#ga936b7451434968fbe9de7f1d58578d88">m0_fom_dom_ops</a>  </dt>
<dd>Support fom timeout functionality.  </dd>
<dt><a class="anchor" id="_todo000105"></a>Global <a class="el" href="../../da/d08/structm0__fom__domain__ops.html#a07a0014ca21c8cca7a6b2d2ba56704fa">m0_fom_domain_ops::fdo_time_is_out</a>  )(const struct <a class="el" href="../../d9/d9f/structm0__fom__domain.html">m0_fom_domain</a> *dom, const struct <a class="el" href="../../d9/db7/structm0__fom.html">m0_fom</a> *fom)</dt>
<dd>fom timeout implementation.  </dd>
<dt><a class="anchor" id="_todo000108"></a>Global <a class="el" href="../../d1/d59/group__fom.html#ga604374b8c983f14fbae8cd5be4791289">m0_fom_tick_generic</a>  (struct <a class="el" href="../../d9/db7/structm0__fom.html">m0_fom</a> *fom)</dt>
<dd>standard fom phases implementation, depends on the support routines for handling various standard operations on fop as mentioned above  </dd>
<dt><a class="anchor" id="_todo000119"></a>Global <a class="el" href="../../da/da0/group__io__fops.html#ga8d10b9614668eefefca2362766b06e6f">m0_fop_cob_rw::crw_ivec</a>  </dt>
<dd>Perhaps it would be easier to change client to send io_index_vec as 2 sequences (of the same length): first indices, then counts. Such sequence can be converted to <a class="el" href="../../df/da2/structm0__indexvec.html">m0_indexvec</a> without allocating intermediary structure and it might simplify client code too, if it uses indexvecs.  </dd>
<dt><a class="anchor" id="_todo000157"></a>Global <a class="el" href="../../d2/def/group__client.html#ga94dc4391285a0716a064d19748c53eec">m0_idx_op</a>  (struct <a class="el" href="../../df/d9e/structm0__idx.html">m0_idx</a> *idx, enum m0_idx_opcode opcode, struct <a class="el" href="../../da/d2c/structm0__bufvec.html">m0_bufvec</a> *keys, struct <a class="el" href="../../da/d2c/structm0__bufvec.html">m0_bufvec</a> *vals, int32_t *rcs, uint32_t flags, struct <a class="el" href="../../d9/d14/structm0__op.html">m0_op</a> **op)</dt>
<dd>For now 'rcs' may be NULL if index backend is not Motr KVS and operation code is not M0_IC_GET. All backends should be updated to fill 'rcs' for all operation codes.  </dd>
<dt><a class="anchor" id="_todo000117"></a>Global <a class="el" href="../../d9/dc2/group__io__foms.html#ga83f94bc807f968a5e6220134c0c315f9">m0_io_cob_stob_create</a>  (struct <a class="el" href="../../d9/db7/structm0__fom.html">m0_fom</a> *fom, struct <a class="el" href="../../d5/d0f/structm0__cob__domain.html">m0_cob_domain</a> *cdom, struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *fid, struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *pver, uint64_t lid, bool crow, struct <a class="el" href="../../de/d54/structm0__cob.html">m0_cob</a> **out)</dt>
<dd>delete stob too.  </dd>
<dt><a class="anchor" id="_todo000121"></a>Global <a class="el" href="../../d3/d94/group___d_l_d__bulk__server__fspec__ios__operations.html#gafdcb68754e497e2781eee6d13097a70c">m0_ios_cdom_get</a>  (struct <a class="el" href="../../d9/da2/structm0__reqh.html">m0_reqh</a> *reqh, struct <a class="el" href="../../d5/d0f/structm0__cob__domain.html">m0_cob_domain</a> **out)</dt>
<dd>: This function is used by copy machine module, but not used by IO service. Corresponding ticket: MOTR-1190.  </dd>
<dt><a class="anchor" id="_todo000123"></a>Global <a class="el" href="../../d7/d3a/structm0__layout__list__enum.html#a87a610272fa7aca4a8748dbbd109528d">m0_layout_list_enum::lle_list_of_cobs</a>  </dt>
<dd>In kernel any allocation over 4KB is not safe. Thus, this array can safely hold only upto 256 number of COB identifiers, (<a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> being 16 bytes in size). This issue is to be addressed later.  </dd>
<dt><a class="anchor" id="_todo000129"></a>Global <a class="el" href="../../d8/dec/group__locality.html#ga3510e3c4243d769c89763a66d4912b4e">M0_LOCKERS_DEFINE</a>  (M0_INTERNAL, <a class="el" href="../../df/d04/structm0__locality.html">m0_locality</a>, lo_lockers)</dt>
<dd>move m0_locality_lockers_type and ldata[] in <a class="el" href="../../d9/d09/structlocality__global.html">locality_global</a>, once lockers are updated to use non-global lockers type.  </dd>
<dt><a class="anchor" id="_todo000148"></a>Global <a class="el" href="../../de/d60/group__mdstore.html#ga559d136beaa0e4fb24612cef69669909">m0_mdstore_close</a>  (struct <a class="el" href="../../dd/d2a/structm0__mdstore.html">m0_mdstore</a> *md, struct <a class="el" href="../../de/d54/structm0__cob.html">m0_cob</a> *cob, struct <a class="el" href="../../d2/d7e/structm0__be__tx.html">m0_be_tx</a> *tx)</dt>
<dd>:<ul>
<li>orphans handling?</li>
<li>quota handling?  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000147"></a>Global <a class="el" href="../../de/d60/group__mdstore.html#gaecdbccfb61c2fbf158c8bfba1ab74248">m0_mdstore_open</a>  (struct <a class="el" href="../../dd/d2a/structm0__mdstore.html">m0_mdstore</a> *md, struct <a class="el" href="../../de/d54/structm0__cob.html">m0_cob</a> *cob, m0_mdstore_locate_flags_t flags, struct <a class="el" href="../../d2/d7e/structm0__be__tx.html">m0_be_tx</a> *tx)</dt>
<dd>: Place cob to open files table.  </dd>
<dt><a class="anchor" id="_todo000178"></a>Global <a class="el" href="../../d0/d50/group__net__pvt.html#ga12df135f261cfd2be817aee51ae5f8a9">m0_net__buffer_add</a>  (struct <a class="el" href="../../d9/d7e/structm0__net__buffer.html">m0_net_buffer</a> *buf, struct <a class="el" href="../../d4/d78/structm0__net__transfer__mc.html">m0_net_transfer_mc</a> *tm)</dt>
<dd>should be <a class="el" href="../../d9/dd2/group__net.html#gab16eda634f902b4235b0107145230c5e">m0_net_desc_free()</a>?  </dd>
<dt><a class="anchor" id="_todo000217"></a>Global <a class="el" href="../../d5/d88/client__server_8c.html#a346a624ca332720ca142dcb177a7b6b7">m0_net_test_client_server_bulk_ut</a>  (void)</dt>
<dd>investigate strange <a class="el" href="../../d9/dd2/group__net.html#ga9858ef0b4919bdf6b5abd5fd4186b53a">m0_net_tm_stop()</a> time on the bulk test client.  </dd>
<dt><a class="anchor" id="_todo000204"></a>Global <a class="el" href="../../db/d3c/group___net_test_stats_m_p_s_d_f_s.html#ga1de99a1781bb0ab1a6e67464438b2a1a">m0_net_test_mps_add</a>  (struct <a class="el" href="../../dd/d01/structm0__net__test__mps.html">m0_net_test_mps</a> *mps, unsigned long messages, m0_time_t timestamp)</dt>
<dd>problem with small mps-&gt;ntmps_time_interval can be here  </dd>
<dt><a class="anchor" id="_todo000190"></a>Global <a class="el" href="../../de/d26/group___net_test_network_d_f_s.html#gae34773d318d4e5ae959892e2b7d0f819">m0_net_test_network_bd_serialize</a>  (enum m0_net_test_serialize_op op, struct <a class="el" href="../../de/d31/structm0__net__test__network__ctx.html">m0_net_test_network_ctx</a> *ctx, uint32_t buf_bulk_index, uint32_t buf_ping_index, m0_bcount_t offset)</dt>
<dd>possible security vulnerability because bounds are not checked  </dd>
<dt><a class="anchor" id="_todo000187"></a>Global <a class="el" href="../../de/d26/group___net_test_network_d_f_s.html#ga9cbe9ee4ae1b99f78c15b0306c9e9bcf">m0_net_test_network_buf_fill</a>  (struct <a class="el" href="../../de/d31/structm0__net__test__network__ctx.html">m0_net_test_network_ctx</a> *ctx, enum m0_net_test_network_buf_type buf_type, uint32_t buf_index, uint8_t fill)</dt>
<dd>use m0_bufvec_cursor_step  </dd>
<dt><a class="anchor" id="_todo000186"></a>Global <a class="el" href="../../de/d26/group___net_test_network_d_f_s.html#gae36d98ef49e452f578713596a2fb48e9">m0_net_test_network_buf_resize</a>  (struct <a class="el" href="../../de/d31/structm0__net__test__network__ctx.html">m0_net_test_network_ctx</a> *ctx, enum m0_net_test_network_buf_type buf_type, uint32_t buf_index, m0_bcount_t new_size)</dt>
<dd>isn't safe because <a class="el" href="../../df/d38/group___net_test_network_internals.html#gac5e9e5052c775ffcd6ae5d641d0e0c7c">net_test_buf_init()</a> can fail  </dd>
<dt><a class="anchor" id="_todo000189"></a>Global <a class="el" href="../../de/d26/group___net_test_network_d_f_s.html#ga7a4ec3c1cbf2bc019165a65f7e9e794c">m0_net_test_network_ctx_init</a>  (struct <a class="el" href="../../de/d31/structm0__net__test__network__ctx.html">m0_net_test_network_ctx</a> *ctx, struct <a class="el" href="../../d0/dc7/structm0__net__test__network__cfg.html">m0_net_test_network_cfg</a> *cfg, const char *tm_addr)</dt>
<dd>create configuration structure instead a lot of parameters  </dd>
<dt><a class="anchor" id="_todo000220"></a>Global <a class="el" href="../../d3/d88/ut_2network_8c.html#a04039edf899d26d765a2c12a40f44aa6">m0_net_test_network_ut_ping</a>  (void)</dt>
<dd>timeddown  </dd>
<dt><a class="anchor" id="_todo000202"></a>Global <a class="el" href="../../d5/d6f/structm0__net__test__nh.html#ab8da2f43ac7abe891b7e7489f327580a">m0_net_test_nh::ntnh_sd</a>  </dt>
<dd>XXX check grammar  </dd>
<dt><a class="anchor" id="_todo000201"></a>Global <a class="el" href="../../d7/d6f/group___net_test_node_helper_d_f_s.html#ga03b3992119969815683e16863d60b60e">m0_net_test_nh_init</a>  (struct <a class="el" href="../../d5/d6f/structm0__net__test__nh.html">m0_net_test_nh</a> *nh, const struct <a class="el" href="../../d6/d41/structm0__net__test__cmd__init.html">m0_net_test_cmd_init</a> *icmd)</dt>
<dd>reset all stats  </dd>
<dt><a class="anchor" id="_todo000195"></a>Global <a class="el" href="../../d5/d60/structm0__net__test__node__ctx.html#a9bb26748dc4afb46ef7f24ed0b8091db">m0_net_test_node_ctx::ntnc_exit_flag</a>  </dt>
<dd>make it atomic  </dd>
<dt><a class="anchor" id="_todo000159"></a>Global <a class="el" href="../../d0/d6f/structm0__op__io.html#ad92f41167d541f73c8178b4f7facf487">m0_op_io::ioo_rc</a>  </dt>
<dd>: remove this  </dd>
<dt><a class="anchor" id="_todo000149"></a>Global <a class="el" href="../../d2/def/group__client.html#gac691966558b0a1cd1f0dada2c3ee4d05">m0_op_kick</a>  (struct <a class="el" href="../../d9/d14/structm0__op.html">m0_op</a> *op)</dt>
<dd>: put pressure on the rpc system to send this rpc message  </dd>
<dt><a class="anchor" id="_todo000226"></a>Global <a class="el" href="../../d8/dec/group__poolmach.html#gac964345ca6edd0cbf103f98702953076">m0_poolmach_state_transit</a>  (struct <a class="el" href="../../dc/dc2/structm0__poolmach.html">m0_poolmach</a> *pm, const struct <a class="el" href="../../d1/df3/structm0__poolmach__event.html">m0_poolmach_event</a> *event)</dt>
<dd><p class="startdd">If this is a new node join event, the index might larger than the current number. Then we need to create a new larger array to hold nodes info. </p>
<p class="enddd">Add ADDB error message here.  </p>
</dd>
<dt><a class="anchor" id="_todo000225"></a>Global <a class="el" href="../../d5/d33/structm0__pools__common.html#a3aec398b098b5870cff1faa6c5fa7707">m0_pools_common::pc_dev2svc</a>  </dt>
<dd>Check whether concurrency needs to be handled after MOTR-1498 is in dev.  </dd>
<dt><a class="anchor" id="_todo000223"></a>Global <a class="el" href="../../dd/d7f/group__pool.html#ga36fcbdcca2295d36cf6b1b06f6def4bf">m0_pools_common_conf_ready_async_cb</a>  (struct <a class="el" href="../../d0/d06/structm0__clink.html">m0_clink</a> *clink)</dt>
<dd>XXX: See if we could do anything with the failed update here. But so far we just cross fingers and hope it succeeds.  </dd>
<dt><a class="anchor" id="_todo000228"></a>Global <a class="el" href="../../d5/d8c/group__reqh.html#ga114bf6bdeff41cef2db128c50959c909">m0_reqh_addb2_init</a>  (struct <a class="el" href="../../d9/da2/structm0__reqh.html">m0_reqh</a> *reqh, const char *location, uint64_t key, bool mkfs, bool force, m0_bcount_t size)</dt>
<dd>replace size constant (size) with a value from confc.  </dd>
<dt><a class="anchor" id="_todo000089"></a>Global <a class="el" href="../../dc/d70/structm0__reqh__fdmi__service.html#a373340c02a357879be8a97f4f341deba">m0_reqh_fdmi_service::rfdms_src_dock_inited</a>  </dt>
<dd>Temporary field to indicate whether source dock was successfully started. (phase 2)  </dd>
<dt><a class="anchor" id="_todo000229"></a>Global <a class="el" href="../../d5/d8c/group__reqh.html#ga3ed2a8afd1e8128d04e1b37b99695112">m0_reqh_init</a>  (struct <a class="el" href="../../d9/da2/structm0__reqh.html">m0_reqh</a> *reqh, const struct <a class="el" href="../../d2/dfd/structm0__reqh__init__args.html">m0_reqh_init_args</a> *reqh_args)</dt>
<dd>use iostores instead of <a class="el" href="../../d5/d0f/structm0__cob__domain.html">m0_cob_domain</a> </dd>
<dt><a class="anchor" id="_todo000241"></a>Global <a class="el" href="../../de/df4/group__rm-ha.html#gaf6ebb70a61ffbd5cb260bcb0515dc6cf">m0_rm_ha_subscribe_sync</a>  (struct <a class="el" href="../../dd/d03/structm0__confc.html">m0_confc</a> *confc, const char *rem_ep, struct <a class="el" href="../../d2/dd9/structm0__rm__ha__tracker.html">m0_rm_ha_tracker</a> *tracker)</dt>
<dd><p class="startdd">Ideally this function should be implemented through asynchronous <a class="el" href="../../de/df4/group__rm-ha.html#ga4fb4a55c227eec9881bbb3312735acaf">m0_rm_ha_subscribe()</a>. The problem is that <a class="el" href="../../db/d9e/structm0__rm__ha__subscriber.html">m0_rm_ha_subscriber</a> internally locks confc sm group. For global confc it is locality0 sm group. So this group can't be provided to <a class="el" href="../../de/df4/group__rm-ha.html#ga94630ddaeda4345ec94ff228311d62a3">m0_rm_ha_subscriber_init()</a>. Usually users requesting synchronous operation don't have another option, except locality0 sm group. </p>
<p class="enddd">What if remote is already in M0_NC_FAILED state? We should check it somewhere.  </p>
</dd>
<dt><a class="anchor" id="_todo000236"></a>Class <a class="el" href="../../d3/db4/structm0__rm__incoming.html">m0_rm_incoming</a>  </dt>
<dd>a new type of incoming request M0_RIT_GRANT (M0_RIT_FOIEGRAS?) can be added to forcibly grant new credits to the owner, for example, as part of a coordinated global distributed resource usage balancing between owners. Processing of requests of this type would be very simple, because adding new credits never blocks. Similarly, a new outgoing request type M0_ROT_TAKE could be added.  </dd>
<dt><a class="anchor" id="_todo000237"></a>Global <a class="el" href="../../d5/dde/group__rmnet.html#ga562f54608468b90722bf60f4f3f0524b">m0_rm_remote_owner_set</a>  (struct <a class="el" href="../../d6/d34/structm0__rm__remote.html">m0_rm_remote</a> *rem, uint64_t id)</dt>
<dd>Assigns a service to a given remote. </dd>
<dt><a class="anchor" id="_todo000239"></a>Global <a class="el" href="../../d8/d71/structm0__rm__resource__type.html#a7ed7ba50e4d3138148b6e3c953ee874c">m0_rm_resource_type::rt_ha_events</a>  </dt>
<dd>:<ol type="1">
<li>Ideally queue shall be operated in lockfree manner to avoid taking locks in HA callback and in AST thread. Currently since only one producer and one consumer contend for the queue lock and critical section is not large this has been differed. Lockfree queue would also require a bit of memory management.</li>
<li>HA should not send the same state twice, and ideally Motr should assert on such incidence. This implementation would circumvent such behaviour by HA. Once Halon is completely replaced by Hare RM can assert on such spurious notifications.  </li>
</ol>
</dd>
<dt><a class="anchor" id="_todo000238"></a>Global <a class="el" href="../../d8/d71/structm0__rm__resource__type.html#a9e3c851242a851951e9311ad4b5c9c32">m0_rm_resource_type::rt_id</a>  </dt>
<dd>Currently this is assigned manually and centrally. In the future, resource types identifiers (as well as rpc item opcodes) will be assigned dynamically by a special service (and then announced to the clients). Such identifier name-spaces are resources themselves, so, welcome to a minefield of bootstrapping.  </dd>
<dt><a class="anchor" id="_todo000243"></a>Global <a class="el" href="../../de/def/group__rm__service.html#gaaf8aa16a70d7b27314cf6801252e348d">m0_rms_register</a>  (void)</dt>
<dd>Contact confd and take list of resource types for this resource manager.  </dd>
<dt><a class="anchor" id="_todo000245"></a>Global <a class="el" href="../../d7/df1/group__rpc-at.html#ga52c51d0e4d53a3cd3fd7f3739a97cf34">m0_rpc_at_init</a>  (struct <a class="el" href="../../da/dc3/structm0__rpc__at__buf.html">m0_rpc_at_buf</a> *ab)</dt>
<dd><a class="el" href="../../dc/da7/assert_8h.html#a1c063bd08f7e1ab3a6e6008ef825d471">M0_PRE(M0_IS0(ab))</a>;  </dd>
<dt><a class="anchor" id="_todo000251"></a>Global <a class="el" href="../../db/d3c/conn__pool_8c.html#a156c79b3485d31c0f0c83c5e207f953e">m0_rpc_conn_pool_get_async</a>  (struct <a class="el" href="../../d4/d53/structm0__rpc__conn__pool.html">m0_rpc_conn_pool</a> *pool, const char *remote_ep, struct <a class="el" href="../../dd/d65/structm0__rpc__session.html">m0_rpc_session</a> **session)</dt>
<dd><p class="startdd">Looks like rpc link connect could not be called twice, even in case first attempt fails (phase 2). </p>
<p class="enddd">Potential race if connection is established before clink is added to session channel.  </p>
</dd>
<dt><a class="anchor" id="_todo000253"></a>Global <a class="el" href="../../d2/d6b/conn__pool_8h.html#ad0fb84623a7a53985b6ba71e9e40827e">m0_rpc_conn_pool_session_established</a>  (struct <a class="el" href="../../dd/d65/structm0__rpc__session.html">m0_rpc_session</a> *session)</dt>
<dd>Unprotected access to -&gt;sm_state in this function.  </dd>
<dt><a class="anchor" id="_todo000254"></a>Global <a class="el" href="../../db/de9/group__rpc.html#gac991d04a87aa904a1df286d5ccd630ac">m0_rpc_frm_constraints_get_defaults</a>  (struct <a class="el" href="../../dc/dc5/structm0__rpc__frm__constraints.html">m0_rpc_frm_constraints</a> *c)</dt>
<dd>XXX decide default values for constraints  </dd>
<dt><a class="anchor" id="_todo000264"></a>Global <a class="el" href="../../df/db4/group__rpc__session.html#ga39a5c6bae2e4944783bde5b99dfe8b2e">m0_rpc_item_dispatch</a>  (struct <a class="el" href="../../de/d21/structm0__rpc__item.html">m0_rpc_item</a> *item)</dt>
<dd>this assumes that the item is a fop.  </dd>
<dt><a class="anchor" id="_todo000258"></a>Global <a class="el" href="../../db/de9/group__rpc.html#ggad070f66853976d2fae7af0b20b66799ea307dfbb5201495c7a288f4dbabf294b4">M0_RPC_ITEM_RESEND_INTERVAL</a>  </dt>
<dd>Provide proper value for re-send interval  </dd>
<dt><a class="anchor" id="_todo000259"></a>Global <a class="el" href="../../d6/d49/structm0__rpc__item__type__ops.html#a771836e1aa26739e10b6cc92a06e83bc">m0_rpc_item_type_ops::rito_eq</a>  )(const struct <a class="el" href="../../de/d21/structm0__rpc__item.html">m0_rpc_item</a> *i1, const struct <a class="el" href="../../de/d21/structm0__rpc__item.html">m0_rpc_item</a> *i2)</dt>
<dd>XXX Implement rito_eq for fops  </dd>
<dt><a class="anchor" id="_todo000261"></a>Global <a class="el" href="../../d9/d36/structm0__rpc__machine.html#a219c182d3e9b7f963a53ba021528b57b">m0_rpc_machine::rm_reqh</a>  </dt>
<dd>There needs to be generic mechanism to register a request handler (or any other handler for future use) with the rpc machine and a ops vector specifying a method to be invoked for futher processing, e.g. <a class="el" href="../../d5/d8c/group__reqh.html#ga68422463b149e333355cad87f123d92f">m0_reqh_fop_handle()</a>, in case of reqh.  </dd>
<dt><a class="anchor" id="_todo000267"></a>Class <a class="el" href="../../d5/dc3/structm0__sns__cm__file__ctx.html">m0_sns_cm_file_ctx</a>  </dt>
<dd>Use the same object to hold layout context.  </dd>
<dt><a class="anchor" id="_todo000265"></a>Global <a class="el" href="../../d7/daf/group___s_n_s_c_m.html#ga959c5eb224ada5e57a7b257b24540f2b">m0_sns_cm_op</a>  </dt>
<dd>: Remove once Halon supports successor enum m0_cm_op.  </dd>
<dt><a class="anchor" id="_todo000266"></a>Global <a class="el" href="../../d7/daf/group___s_n_s_c_m.html#gaecd39a2ec1f81b6dfd39ca001f1ade0a">m0_sns_cm_status</a>  </dt>
<dd>: Remove once Halon supports successor enum m0_cm_status.  </dd>
<dt><a class="anchor" id="_todo000277"></a>Global <a class="el" href="../../df/d3a/group__spiel-api-fspec-intr.html#gaaead29497ab3c7f05f3a577203d87e36">m0_spiel_pool_rebalance_abort</a>  (struct <a class="el" href="../../dd/d2a/structm0__spiel.html">m0_spiel</a> *spl, const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *pool_fid)</dt>
<dd><p class="startdd">Remove once Halon supports m0_spiel_{sns,dix}_rebalance_abort(). </p>
<p class="enddd">Remove once Halon supports m0_spiel_{sns,dix}_rebalance_abort().  </p>
</dd>
<dt><a class="anchor" id="_todo000275"></a>Global <a class="el" href="../../df/d3a/group__spiel-api-fspec-intr.html#ga333098c2180c79594dd99e0bb409b608">m0_spiel_pool_rebalance_continue</a>  (struct <a class="el" href="../../dd/d2a/structm0__spiel.html">m0_spiel</a> *spl, const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *pool_fid)</dt>
<dd><p class="startdd">Remove once Halon supports m0_spiel_{sns,dix}_rebalance_continue(). </p>
<p class="enddd">Remove once Halon supports m0_spiel_{sns,dix}_rebalance_continue().  </p>
</dd>
<dt><a class="anchor" id="_todo000276"></a>Global <a class="el" href="../../df/d3a/group__spiel-api-fspec-intr.html#gafdb7fb266fb82f32e7b5a386297ae3a4">m0_spiel_pool_rebalance_quiesce</a>  (struct <a class="el" href="../../dd/d2a/structm0__spiel.html">m0_spiel</a> *spl, const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *pool_fid)</dt>
<dd><p class="startdd">Remove once Halon supports m0_spiel_{sns,dix}_rebalance_quiesce(). </p>
<p class="enddd">Remove once Halon supports m0_spiel_{sns,dix}_rebalance_quiesce().  </p>
</dd>
<dt><a class="anchor" id="_todo000274"></a>Global <a class="el" href="../../df/d3a/group__spiel-api-fspec-intr.html#ga7a853389dec4a25890eb162c9bfdef7c">m0_spiel_pool_rebalance_start</a>  (struct <a class="el" href="../../dd/d2a/structm0__spiel.html">m0_spiel</a> *spl, const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *pool_fid)</dt>
<dd><p class="startdd">Remove once Halon supports m0_spiel_{sns,dix}_rebalance_start(). </p>
<p class="enddd">Remove once Halon supports m0_spiel_{sns,dix}_rebalance_start().  </p>
</dd>
<dt><a class="anchor" id="_todo000288"></a>Global <a class="el" href="../../d9/d50/group__spiel-api-fspec.html#gaa38392f8c0acaacac14c0dd3c55702af">m0_spiel_pool_rebalance_status</a>  (struct <a class="el" href="../../dd/d2a/structm0__spiel.html">m0_spiel</a> *spl, const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *pool_fid, struct <a class="el" href="../../dc/d53/structm0__spiel__sns__status.html">m0_spiel_sns_status</a> **statuses)</dt>
<dd>Remove once Halon supports m0_spiel_{sns,dix}_rebalance_status().  </dd>
<dt><a class="anchor" id="_todo000272"></a>Global <a class="el" href="../../df/d3a/group__spiel-api-fspec-intr.html#ga0a0cec263747893d9dd71384c2239392">m0_spiel_pool_repair_abort</a>  (struct <a class="el" href="../../dd/d2a/structm0__spiel.html">m0_spiel</a> *spl, const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *pool_fid)</dt>
<dd><p class="startdd">Remove once Halon supports m0_spiel_{sns,dix}_repair_abort(). </p>
<p class="enddd">Remove once Halon supports m0_spiel_{sns,dix}_repair_abort().  </p>
</dd>
<dt><a class="anchor" id="_todo000270"></a>Global <a class="el" href="../../df/d3a/group__spiel-api-fspec-intr.html#ga409ba8e547b61f12d64c1106bf9a309d">m0_spiel_pool_repair_continue</a>  (struct <a class="el" href="../../dd/d2a/structm0__spiel.html">m0_spiel</a> *spl, const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *pool_fid)</dt>
<dd><p class="startdd">Remove once Halon supports m0_spiel_{sns,dix}_repair_continue(). </p>
<p class="enddd">Remove once Halon supports m0_spiel_{sns,dix}_repair_continue().  </p>
</dd>
<dt><a class="anchor" id="_todo000271"></a>Global <a class="el" href="../../df/d3a/group__spiel-api-fspec-intr.html#gae338da06c96755e6aa29716ab95f031d">m0_spiel_pool_repair_quiesce</a>  (struct <a class="el" href="../../dd/d2a/structm0__spiel.html">m0_spiel</a> *spl, const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *pool_fid)</dt>
<dd><p class="startdd">Remove once Halon supports m0_spiel_{sns,dix}_repair_quiesce(). </p>
<p class="enddd">Remove once Halon supports m0_spiel_{sns,dix}_repair_quiesce().  </p>
</dd>
<dt><a class="anchor" id="_todo000269"></a>Global <a class="el" href="../../df/d3a/group__spiel-api-fspec-intr.html#ga22f13201f4ab168127b0ca98c55cc830">m0_spiel_pool_repair_start</a>  (struct <a class="el" href="../../dd/d2a/structm0__spiel.html">m0_spiel</a> *spl, const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *pool_fid)</dt>
<dd><p class="startdd">Remove once Halon supports m0_spiel_{sns,dix}_repair_start(). </p>
<p class="enddd">Remove once Halon supports m0_spiel_{sns,dix}_repair_start().  </p>
</dd>
<dt><a class="anchor" id="_todo000273"></a>Global <a class="el" href="../../df/d3a/group__spiel-api-fspec-intr.html#ga5200c5ea3c95c364867c9d9fa4e0426f">m0_spiel_pool_repair_status</a>  (struct <a class="el" href="../../dd/d2a/structm0__spiel.html">m0_spiel</a> *spl, const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *pool_fid, struct <a class="el" href="../../dc/d53/structm0__spiel__sns__status.html">m0_spiel_sns_status</a> **statuses)</dt>
<dd><p class="startdd">Remove once Halon supports m0_spiel_{sns,dix}_repair_status(). </p>
<p class="enddd">Remove once Halon supports m0_spiel_{sns,dix}_repair_status().  </p>
</dd>
<dt><a class="anchor" id="_todo000279"></a>Class <a class="el" href="../../dc/d53/structm0__spiel__sns__status.html">m0_spiel_sns_status</a>  </dt>
<dd>Remove once Halon supports successor <a class="el" href="../../d0/df6/structm0__spiel__repreb__status.html">m0_spiel_repreb_status</a>.  </dd>
<dt><a class="anchor" id="_todo000295"></a>Class <a class="el" href="../../d2/db8/structm0__stob__cache.html">m0_stob_cache</a>  </dt>
<dd>document  </dd>
<dt><a class="anchor" id="_todo000296"></a>Global <a class="el" href="../../d9/d6a/group__stob.html#gga20e19b7361a5e689c6dacac20180ab73aedb1a67f49efdeff25975633174776a7">M0_STOB_CACHE_MAX_SIZE</a>  </dt>
<dd>make a parameter for stob domain.  </dd>
<dt><a class="anchor" id="_todo000301"></a>Global <a class="el" href="../../d9/d6a/group__stob.html#ga86554798b734b43b7fde32398ff992fb">m0_stob_find_by_key</a>  (struct <a class="el" href="../../dc/d61/structm0__stob__domain.html">m0_stob_domain</a> *dom, const struct <a class="el" href="../../d9/d8a/structm0__fid.html">m0_fid</a> *stob_fid, struct <a class="el" href="../../d1/d0a/structm0__stob.html">m0_stob</a> **out)</dt>
<dd>move allocation out of cache lock if needed  </dd>
<dt><a class="anchor" id="_todo000298"></a>Global <a class="el" href="../../d9/d6a/group__stob.html#ga451f565d74b54f3ac0fbb87a0713b1a0">m0_stob_io_opcode</a>  </dt>
<dd>implement barriers.  </dd>
<dt><a class="anchor" id="_todo000302"></a>Global <a class="el" href="../../d9/d6a/group__stob.html#gaa7f44fcbd3117c4e779bcd5ce05f5eb0">m0_stob_state</a>  </dt>
<dd>add M0_ prefix.  </dd>
<dt><a class="anchor" id="_todo000122"></a>Global <a class="el" href="../../d8/dc1/bulkio__common_8c.html#a050d1b2839668daa750b4b3719bbfbe6">M0_TL_DESCR_DECLARE</a>  (rpcbulk, M0_EXTERN)</dt>
<dd>This value can be reduced after multiple message delivery in a single buffer is supported.  </dd>
<dt><a class="anchor" id="_todo000130"></a>Global <a class="el" href="../../d8/d98/group__trace.html#gad566bc8e4723e7ca51684832307873fa">m0_trace_allot</a>  (const struct <a class="el" href="../../d5/d09/structm0__trace__descr.html">m0_trace_descr</a> *td, const void *body)</dt>
<dd>put memory barrier here before writing the magic  </dd>
<dt><a class="anchor" id="_todo000086"></a>Global <a class="el" href="../../d0/d9e/group__addb2.html#ga1d009c17f114d7cc67fee7148b876e4d">M0_XCA_DOMAIN</a>  </dt>
<dd>Q: Is it possible release FOP to be ONEWAY?  </dd>
<dt><a class="anchor" id="_todo000044"></a>Global <a class="el" href="../../d3/d8e/group__cob.html#gae7a2c5a57b82ab9e2981f1dcc4dad73f">M0_XCA_DOMAIN</a>  </dt>
<dd><p class="startdd">at some point, we may replace the co_ref by taking a reference on the underlying co_stob. At that point, we will need a callback at last put. We wait to see how cob users will use these references, whether they need callbacks in turn, etc.</p>
<p>Q: Make it generic reply? </p>
<p class="enddd">Q: Is it possible release FOP to be ONEWAY?  </p>
</dd>
<dt><a class="anchor" id="_todo000044"></a>Global <a class="el" href="../../d3/d8e/group__cob.html#gae7a2c5a57b82ab9e2981f1dcc4dad73f">M0_XCA_DOMAIN</a>  </dt>
<dd><p class="startdd">at some point, we may replace the co_ref by taking a reference on the underlying co_stob. At that point, we will need a callback at last put. We wait to see how cob users will use these references, whether they need callbacks in turn, etc.</p>
<p>Q: Make it generic reply? </p>
<p class="enddd">Q: Is it possible release FOP to be ONEWAY?  </p>
</dd>
<dt><a class="anchor" id="_todo000085"></a>Global <a class="el" href="../../d0/d9e/group__addb2.html#ga1d009c17f114d7cc67fee7148b876e4d">M0_XCA_DOMAIN</a>  </dt>
<dd>Q: Make it generic reply?  </dd>
<dt><a class="anchor" id="_todo000080"></a>Global <a class="el" href="../../d8/de2/group___f_d_m_i___d_l_d__fspec__filter.html#ga74f57f1feb570123b01a320292450662">M0_XCA_ENUM</a>  </dt>
<dd>Phase 2: Recursive data definition is not allowed in xcode operations.  </dd>
<dt><a class="anchor" id="_todo000080"></a>Global <a class="el" href="../../d8/de2/group___f_d_m_i___d_l_d__fspec__filter.html#ga74f57f1feb570123b01a320292450662">M0_XCA_ENUM</a>  </dt>
<dd>Phase 2: Recursive data definition is not allowed in xcode operations.  </dd>
<dt><a class="anchor" id="_todo000110"></a>Module <a class="el" href="../../de/d4a/group__m0ham.html">m0ham</a>  </dt>
<dd><p class="startdd">Fix memory leaks:</p><ul>
<li><a class="el" href="../../d2/d0b/structm0__ha__entrypoint__req__fop.html#ac55d8b45b4d93ffebb4f6fa09610758c">m0_ha_entrypoint_req_fop::erf_git_rev_id</a></li>
<li><a class="el" href="../../db/db9/structm0__ha__entrypoint__rep__fop.html#af3dc2f91d6454349cf4a133f5c087291">m0_ha_entrypoint_rep_fop::hbp_active_rm_ep</a></li>
<li>m0_ha_entrypoint_rep_fop::hbp_confd_fids.af_elems</li>
<li>m0_ha_entrypoint_rep_fop::hbp_confd_eps.ab_elems&lt;p&gt;Implement "Connect/disconnect without m0_ha_msg traffic" scenario. See the comment in <a class="el" href="../../de/d4a/group__m0ham.html#gad2168c0c769a493993cc3f157b7be3fe">ham_link_disconnected()</a>.</li>
</ul>
<p>"Server sends, client receives" scenario ==&gt; client crashes.</p>
<p class="enddd"><a class="el" href="../../de/d4a/group__m0ham.html#gab3c6d5d9bcedcf6955b18c126e16baa1">ham_say()</a> entrypoint attributes in <a class="el" href="../../de/d4a/group__m0ham.html#gadec30c47df1dea93bf8d83223b715557">ham_entrypoint_replied()</a>. </p>
</dd>
<dt><a class="anchor" id="_todo000142"></a>Global <a class="el" href="../../d8/d2b/inode_8c.html#a2723aefda5b9e2a7bfc7e60e87afd2f3">m0t1fs_file_lock_init</a>  (struct m0t1fs_inode *ci, struct m0t1fs_sb *csb)</dt>
<dd>Get di type from configuration.  </dd>
<dt><a class="anchor" id="_todo000141"></a>Global <a class="el" href="../../df/d10/fsync_8h.html#a389eff049efbd0e1d797f17d94739ff6">m0t1fs_fsync</a>  (struct file *file, loff_t start, loff_t end, int datasync)</dt>
<dd>: Generate some addb here.  </dd>
<dt><a class="anchor" id="_todo000133"></a>Global <a class="el" href="../../db/dcd/m0t1fs_2linux__kernel_2dir_8c.html#a439ab2e1f721fb44a64b33d2b8de7feb">m0t1fs_mds_cob_op</a>  (struct m0t1fs_sb *csb, const struct m0t1fs_mdop *mo, struct <a class="el" href="../../d5/d9d/structm0__fop__type.html">m0_fop_type</a> *ftype, struct <a class="el" href="../../d5/d01/structm0__fop.html">m0_fop</a> **rep_fop)</dt>
<dd>remid can be found generically, outside of this switch through the use of '<a class="el" href="../../dd/d6d/group__xcode.html#gadcf7da30ac4bf065f02fe57b00fc0f3c">m0_xcode_find()</a>' - this function should be cleaned up later.  </dd>
<dt><a class="anchor" id="_todo000143"></a>Global <a class="el" href="../../d2/d1d/super_8c.html#a524cdd9f57f01f3ddec49a877fa308dc">m0t1fs_statfs</a>  (struct dentry *dentry, struct kstatfs *buf)</dt>
<dd>According to <a class="el" href="../../d6/d2c/group__stobad.html#ga0553b23084178bfa3e0d91525d6d2129">stob_ad_domain_cfg_create_parse()</a>, current block size forcibly defaulted by BALLOC_DEF_BLOCK_SHIFT value. Need to understand if it's ever going to be any different in future, and if so, whether it's worth to be exposed to fs client. Besides, what if the balloc setup is going to vary among segments/pools/etc.?  </dd>
<dt><a class="anchor" id="_todo000211"></a>Global <a class="el" href="../../dc/d55/group___net_test_u_console_internals.html#ga0ddf1224851353fc92bfbff6f499fa97">main</a>  (int argc, char *argv[])</dt>
<dd><p class="startdd">add to command line parameters </p>
<p>where is the error </p>
<p>add to command line parameters </p>
<p>add Ctrl+C handler <a class="el" href="../../da/d19/group___net_test_init_fini_internals.html#ga6619efcca91ebaef9d8bb112d9b7301e">m0_net_test_fini()</a>+m0_net_test_config_fini() </p>
<p>atexit() </p>
<p class="enddd">where is the error  </p>
</dd>
<dt><a class="anchor" id="_todo000145"></a>Global <a class="el" href="../../d5/d42/md__fops_8c.html#a0eab5ab1a5edf7c73ba32618d1f77da4">md_fol_frag_redo</a>  (struct <a class="el" href="../../d1/dc1/structm0__fop__fol__frag.html">m0_fop_fol_frag</a> *ffrag, struct <a class="el" href="../../db/dac/structm0__fol.html">m0_fol</a> *fol)</dt>
<dd>Perform the redo operation for meta-data updates using the generic fop fol fragment.  </dd>
<dt><a class="anchor" id="_todo000144"></a>Global <a class="el" href="../../d5/d42/md__fops_8c.html#af366d85bb9a48580cfb146e73cecc910">md_fol_frag_undo</a>  (struct <a class="el" href="../../d1/dc1/structm0__fop__fol__frag.html">m0_fop_fol_frag</a> *ffrag, struct <a class="el" href="../../db/dac/structm0__fol.html">m0_fol</a> *fol)</dt>
<dd>Perform the undo operation for meta-data updates using the generic fop fol fragment.  </dd>
<dt><a class="anchor" id="_todo000146"></a>Global <a class="el" href="../../da/dda/group__mdservice.html#ga39205059ac29df4ca8236b49d261e1c1">mds_start</a>  (struct <a class="el" href="../../da/d3c/structm0__reqh__service.html">m0_reqh_service</a> *service)</dt>
<dd>XXX change this when reqh will be started before services, see MOTR-317  </dd>
<dt><a class="anchor" id="_todo000191"></a>Page <a class="el" href="../../dd/df4/net-test.html">Motr Network Benchmark</a>  </dt>
<dd><p class="startdd">Outdated and not used now.</p>
<p class="enddd">Outdated and not used now. </p>
</dd>
<dt><a class="anchor" id="_todo000219"></a>Global <a class="el" href="../../d3/d88/ut_2network_8c.html#a61fc89502014500456c4d16e3c84be5f">net_buf_data_eq</a>  (enum m0_net_test_network_buf_type buf_type, struct <a class="el" href="../../de/d31/structm0__net__test__network__ctx.html">m0_net_test_network_ctx</a> *ctx1, uint32_t buf_index1, struct <a class="el" href="../../de/d31/structm0__net__test__network__ctx.html">m0_net_test_network_ctx</a> *ctx2, uint32_t buf_index2)</dt>
<dd>too expensive, use <a class="el" href="../../d0/d7f/group__vec.html#gad481d7c4ffe49912e0cca7c0262baa0b">m0_bufvec_cursor_step()</a> + memcmp()  </dd>
<dt><a class="anchor" id="_todo000218"></a>Global <a class="el" href="../../dc/daf/ut_2commands_8c.html#a196572b8bde6bd321b2b64079f73721c">net_test_command_ut</a>  (size_t nr)</dt>
<dd>set callback  </dd>
<dt><a class="anchor" id="_todo000184"></a>Global <a class="el" href="../../df/d38/group___net_test_network_internals.html#ga6219bbfeeb4b20689feefc7a5b4efd18">net_test_network_ctx_initfini</a>  (struct <a class="el" href="../../de/d31/structm0__net__test__network__ctx.html">m0_net_test_network_ctx</a> *ctx, struct <a class="el" href="../../d0/dc7/structm0__net__test__network__cfg.html">m0_net_test_network_cfg</a> *cfg, const char *tm_addr)</dt>
<dd><p class="startdd">make ctx-&gt;ntc_dom embedded into ctx </p>
<p class="enddd">replace gmc and ctx  </p>
</dd>
<dt><a class="anchor" id="_todo000181"></a>Module <a class="el" href="../../d5/d16/group__netsock.html">netsock</a>  </dt>
<dd>It is not clear how to manage write-monitoring in case of multiple "parallel" sockets to the same end-point. If writeability of all such sockets is monitored, epoll_wait() can busy-loop. If not all of them are monitored, they are useless for concurrent writes. </dd>
<dt><a class="anchor" id="_todo000188"></a>Module <a class="el" href="../../de/d26/group___net_test_network_d_f_s.html">NetTestNetworkDFS</a>  </dt>
<dd><p class="startdd">m0_net_test_network_ prefix is too long. rename and align. </p>
<p class="enddd">s/uint32_t/size_t/ </p>
</dd>
<dt><a class="anchor" id="_todo000183"></a>Module <a class="el" href="../../df/d38/group___net_test_network_internals.html">NetTestNetworkInternals</a>  </dt>
<dd><p class="startdd">add timeouts to channels and network buffers </p>
<p>align code (function parameters etc.) </p>
<p class="enddd">cache <a class="el" href="../../d0/d7f/group__vec.html#ga9c79d9e7b339acaf8b46ac0a813f064d">m0_vec_count()</a> </p>
</dd>
<dt><a class="anchor" id="_todo000203"></a>Module <a class="el" href="../../da/d84/group___net_test_ping_node_internals.html">NetTestPingNodeInternals</a>  </dt>
<dd>nb_max_receive_msgs &gt; 1 is not supported. </dd>
<dt><a class="anchor" id="_todo000205"></a>Module <a class="el" href="../../d2/de9/group___net_test_stats_d_f_s.html">NetTestStatsDFS</a>  </dt>
<dd>Move to lib/stats.h </dd>
<dt><a class="anchor" id="_todo000125"></a>Global <a class="el" href="../../d6/de4/layout_2ut_2layout_8c.html#acabce7ab7d4c6eee02784d2fb0d39ad8">NKP_assign_and_pool_init</a>  (uint32_t enum_id, uint32_t inline_test, uint32_t list_nr_less, uint32_t list_nr_more, uint32_t linear_nr, uint32_t *N, uint32_t *K, uint32_t *S, uint32_t *P)</dt>
<dd>This is a workaround to be taken out along with the forthcoming patch for the layout module to use xcode and newer BE, with which the whole layout test suite will anyway be restructured.  </dd>
<dt><a class="anchor" id="_todo000179"></a>Global <a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#gaf05550e19ded0a4dc758312635444092">nlx_dev_tm_cleanup</a>  (struct <a class="el" href="../../d1/dab/structnlx__kcore__domain.html">nlx_kcore_domain</a> *kd, struct <a class="el" href="../../d5/d0b/structnlx__kcore__transfer__mc.html">nlx_kcore_transfer_mc</a> *ktm)</dt>
<dd>XXX list removal is protected by the lock, but iteration over the list isn't? &ndash;nikita.  </dd>
<dt><a class="anchor" id="_todo000198"></a>Global <a class="el" href="../../dd/da5/group___net_test_bulk_node_internals.html#ga058deb8a039669531f9b9c93cc9e3887">node_bulk_cmd_start</a>  (void *ctx_, const struct <a class="el" href="../../d2/d3e/structm0__net__test__cmd.html">m0_net_test_cmd</a> *cmd, struct <a class="el" href="../../d2/d3e/structm0__net__test__cmd.html">m0_net_test_cmd</a> *reply)</dt>
<dd><p class="startdd">copy-paste from node_ping.c. refactor it. </p>
<p class="enddd">copy-paste from node_ping.c  </p>
</dd>
<dt><a class="anchor" id="_todo000200"></a>Global <a class="el" href="../../dd/da5/group___net_test_bulk_node_internals.html#gaa9b527057189a24da890c66c3d4193bf">node_bulk_cmd_stop</a>  (void *ctx_, const struct <a class="el" href="../../d2/d3e/structm0__net__test__cmd.html">m0_net_test_cmd</a> *cmd, struct <a class="el" href="../../d2/d3e/structm0__net__test__cmd.html">m0_net_test_cmd</a> *reply)</dt>
<dd>copy-paste from node_ping.c. refactor it.  </dd>
<dt><a class="anchor" id="_todo000197"></a>Class <a class="el" href="../../db/d43/structnode__bulk__ctx.html">node_bulk_ctx</a>  </dt>
<dd>move equal parts from <a class="el" href="../../db/d43/structnode__bulk__ctx.html">node_bulk_ctx</a> &amp; <a class="el" href="../../de/d6f/structnode__ping__ctx.html">node_ping_ctx</a> to single struct  </dd>
<dt><a class="anchor" id="_todo000193"></a>Global <a class="el" href="../../d2/d9a/group___net_test_node_internals.html#gaa4ae51af7329f0a8584412be8d9531d3">node_cmd_wait</a>  (struct <a class="el" href="../../d5/d60/structm0__net__test__node__ctx.html">m0_net_test_node_ctx</a> *ctx, struct <a class="el" href="../../d2/d3e/structm0__net__test__cmd.html">m0_net_test_cmd</a> *cmd, enum m0_net_test_cmd_type type)</dt>
<dd>add retry count  </dd>
<dt><a class="anchor" id="_todo000160"></a>Global <a class="el" href="../../d7/d99/conf_8c.html#a4bfdfce78c9ee79141f8ee72fa387b77">node_options_add</a>  (struct <a class="el" href="../../d8/d7f/structcs__args.html">cs_args</a> *args, const struct <a class="el" href="../../dc/de6/structm0__conf__node.html">m0_conf_node</a> *node)</dt>
<dd>Node parameters cn_memsize and cn_flags options are not used currently. Options '-m' and '-q' options are used for maximum RPC message size and minimum length of TM receive queue. If required, change the option names accordingly.  </dd>
<dt><a class="anchor" id="_todo000025"></a>Global <a class="el" href="../../d2/d64/group__cas-client.html#ga2fe722035b135853449cb48f39f3a718">nreq_asmbl_accept</a>  (struct <a class="el" href="../../d3/db5/structm0__cas__req.html">m0_cas_req</a> *req)</dt>
<dd>validate it  </dd>
<dt><a class="anchor" id="_todo000081"></a>Global <a class="el" href="../../d4/dfa/filterc_8c.html#a4d76375f338f97222389edb92a9d2ddf">open_filter_group</a>  (struct <a class="el" href="../../d0/d19/structm0__filterc__ctx.html">m0_filterc_ctx</a> *ctx, enum m0_fdmi_rec_type_id rec_type_id, struct <a class="el" href="../../df/da6/structm0__conf__obj.html">m0_conf_obj</a> **out)</dt>
<dd>Close opened groups?  </dd>
<dt><a class="anchor" id="_todo000234"></a>Global <a class="el" href="../../d2/deb/group__rm.html#ga62a2c4f8fedd86bdc490e7e01870fbf7">outgoing_check</a>  (struct <a class="el" href="../../d3/db4/structm0__rm__incoming.html">m0_rm_incoming</a> *in, enum m0_rm_outgoing_type, struct <a class="el" href="../../d6/d46/structm0__rm__credit.html">m0_rm_credit</a> *credit, struct <a class="el" href="../../d6/d34/structm0__rm__remote.html">m0_rm_remote</a> *other)</dt>
<dd>adjust outgoing requests priority (priority inheritance)  </dd>
<dt><a class="anchor" id="_todo000168"></a>Global <a class="el" href="../../db/d27/io__pargrp_8c.html#a0a37b5e031c56bacd802090b0cdd7f41">pargrp_iomap_fullpages_count</a>  (struct <a class="el" href="../../d0/d55/structpargrp__iomap.html">pargrp_iomap</a> *map)</dt>
<dd>: all client buffers should be PA_FULLPAGE_MODIFY - rip all this out  </dd>
<dt><a class="anchor" id="_todo000124"></a>Global <a class="el" href="../../df/d01/group__pdclust.html#gaf6b83528b6743540ad1b75a990a4c107">permute_column</a>  (struct <a class="el" href="../../d9/d8c/structm0__pdclust__instance.html">m0_pdclust_instance</a> *pi, uint64_t omega, uint64_t t)</dt>
<dd>Not sure if this should be replaced by an ADDB DP or a M0_LOG.  </dd>
<dt><a class="anchor" id="_todo000180"></a>Global <a class="el" href="../../de/dec/lnet_2st_2ping_8c.html#ab32f0c3cf666b61702ace01263c98ddd">ping_init</a>  (struct <a class="el" href="../../d9/d6a/structnlx__ping__ctx.html">nlx_ping_ctx</a> *ctx)</dt>
<dd>replace gmc and ctx  </dd>
<dt><a class="anchor" id="_todo000100"></a>Global <a class="el" href="../../d5/d34/sd__common_8h.html#aa1645b1c9674c96b7968f0ce494969d6">prepare_rpc_env</a>  (struct <a class="el" href="../../db/dcd/structtest__rpc__env.html">test_rpc_env</a> *env, struct <a class="el" href="../../d9/da2/structm0__reqh.html">m0_reqh</a> *reqh, const struct <a class="el" href="../../d3/d58/structm0__rpc__frm__ops.html">m0_rpc_frm_ops</a> *frm_ops, bool sender, struct <a class="el" href="../../d2/de3/structm0__rpc__conn.html">m0_rpc_conn</a> *rpc_conn, struct <a class="el" href="../../dd/d65/structm0__rpc__session.html">m0_rpc_session</a> *rpc_session)</dt>
<dd>Add prefix  </dd>
<dt><a class="anchor" id="_todo000131"></a>Global <a class="el" href="../../da/dd8/group__thread.html#ga0a97ce0078be0455675943c681b444d8">pthread_attr_default</a>  </dt>
<dd>move this in <a class="el" href="../../d5/d1b/structm0.html">m0</a> instance.  </dd>
<dt><a class="anchor" id="_todo000174"></a>Global <a class="el" href="../../df/dca/group__m0d.html#ga90ac7e85da79f65ed4c242e951f592e1">pver_is_actual</a>  (const struct <a class="el" href="../../df/da6/structm0__conf__obj.html">m0_conf_obj</a> *obj)</dt>
<dd>XXX filter only actual pool versions till formulaic pool version creation in place.  </dd>
<dt><a class="anchor" id="_todo000065"></a>Global <a class="el" href="../../db/d90/group__rconfc__dlspec.html#gaaac22c7cd891b27a57d2c1628ba5334b">rconfc_link_fini_ast</a>  (struct <a class="el" href="../../d5/d32/structm0__sm__group.html">m0_sm_group</a> *grp, struct <a class="el" href="../../de/d78/structm0__sm__ast.html">m0_sm_ast</a> *ast)</dt>
<dd>The dead confd fid is going to be removed from phony cache, and the link object to be finalised in <a class="el" href="../../d3/da7/rconfc__link__fom_8c.html#ae9b2fa2971ffcf5e93388646e4562761">rconfc_link_fom_fini()</a>. Therefore, no way remains to listen for the confd state changes in future. You may be tempted by an idea of reviving the link in case the confd is announced M0_NC_ONLINE later, but consider the following analysis: </dd>
<dt><a class="anchor" id="_todo000173"></a>Global <a class="el" href="../../df/dca/group__m0d.html#gad589ce0d5a21dede8ad436780cf1b5c6">reqh_services_start</a>  (struct <a class="el" href="../../db/df9/structm0__reqh__context.html">m0_reqh_context</a> *rctx, struct <a class="el" href="../../d1/ddd/structm0__motr.html">m0_motr</a> *cctx)</dt>
<dd>XXX Handle errors properly.  </dd>
<dt><a class="anchor" id="_todo000230"></a>Global <a class="el" href="../../d2/deb/group__rm.html#gaadd41e3e327172608c63f963776db593">rev_session_clink_cb</a>  (struct <a class="el" href="../../d0/d06/structm0__clink.html">m0_clink</a> *link)</dt>
<dd>This would be fixed, when RM will be using normal locality sm groups, rather than per-resource-type groups  </dd>
<dt><a class="anchor" id="_todo000240"></a>Global <a class="el" href="../../de/df4/group__rm-ha.html#gad902d974530d0fb776b1349352740b9e">rm_ha_sbscr_diter_next</a>  (struct <a class="el" href="../../db/d9e/structm0__rm__ha__subscriber.html">m0_rm_ha_subscriber</a> *sbscr)</dt>
<dd>What if obj is already in M0_NC_FAILED state? We should check it somewhere.  </dd>
<dt><a class="anchor" id="_todo000235"></a>Global <a class="el" href="../../d2/deb/group__rm.html#ga85d3cb36f0421ef267794c835b5399ca">rm_remote_death_handler</a>  (struct <a class="el" href="../../d6/d34/structm0__rm__remote.html">m0_rm_remote</a> *remote)</dt>
<dd>if rc != 0, then credits remain in sub-let list and can't be revoked anymore. Also we can't return error code to user. Maybe we should notify HA about error?  </dd>
<dt><a class="anchor" id="_todo000244"></a>Module <a class="el" href="../../de/def/group__rm__service.html">rm_service</a>  </dt>
<dd>All the creditors for the resources reside inside RM service; i.e. RM service will be the creditor for all currently available resource types. When specific resource types are implemented, this can be changed.  </dd>
<dt><a class="anchor" id="_todo000063"></a>Global <a class="el" href="../../dc/dd7/root_8c.html#ae9ecce76149763d396cf80fa5a29d5fc">root_encode</a>  (struct <a class="el" href="../../de/dba/structm0__confx__obj.html">m0_confx_obj</a> *dest, const struct <a class="el" href="../../df/da6/structm0__conf__obj.html">m0_conf_obj</a> *src)</dt>
<dd>Make spiel happy for now as it does not know about fdmi yet.  </dd>
<dt><a class="anchor" id="_todo000246"></a>Module <a class="el" href="../../d7/df1/group__rpc-at.html">rpc-at</a>  </dt>
<dd><p class="startdd">Another method of buffer transmission may be needed: "best". When client specifies this method it has to provide network buffer as with in-bulk case. The server sends the reply inline if possible, uses the netbuffer otherwise. This would allow return of large records (via in-bulk), while avoiding in-bulk overhead for small records.</p>
<p class="enddd">: Perform negotiation on inbulk threshold during connection establishment? </p>
</dd>
<dt><a class="anchor" id="_todo000250"></a>Global <a class="el" href="../../df/db4/group__rpc__session.html#ga59af65a8c2ecf666a527afc4d3b494f9">rpc_conn__on_cache_ready_cb</a>  (struct <a class="el" href="../../d0/d06/structm0__clink.html">m0_clink</a> *clink)</dt>
<dd>See if we can act any smarter than just log the subscription error. Please note, -ENOENT code is normal in the situation when the connection previously was established to a service that appears abandoned when conf updates.  </dd>
<dt><a class="anchor" id="_todo000248"></a>Global <a class="el" href="../../df/db4/group__rpc__session.html#ga3601d170977b90a066e6c59f119b10ed">rpc_conn__on_service_event_cb</a>  (struct <a class="el" href="../../d0/d06/structm0__clink.html">m0_clink</a> *clink)</dt>
<dd><p class="startdd">See if to <a class="el" href="../../df/db4/group__rpc__session.html#gabaf00b78d1a327a1ea762a8c0f0d995a">__conn_ha_unsubscribe()</a> right now, but not wait until rpc connection getting finalised.</p>
<p class="enddd">See if anything, or what and when otherwise, we need to do on getting M0_NC_ONLINE notification.  </p>
</dd>
<dt><a class="anchor" id="_todo000262"></a>Module <a class="el" href="../../df/db4/group__rpc__session.html">rpc_session</a>  </dt>
<dd><p class="startdd">currently, receiver assigns identifiers to connections and sessions and these identifiers are used by both parties. What we can do, is to allow sender to assign identifiers to sessions (this identifier is sent in SESSION_ESTABLISH). Then, whenever receiver uses the session to send a reply, it uses this identifier (instead of receiver assigned session-id). The advantage of this, is that sender can use an identifier that allows quick lookup (e.g., an index in some session array or simply a pointer). Similarly for connections (i.e., another sender generated identifier in addition to uuid, that is not guaranteed to be globally unique)</p>
<ul>
<li>Generate ADDB data points for important session events</li>
<li>store replies in FOL</li>
<li>Optimization: Cache misordered items at receiver, rather than discarding them.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000260"></a>Global <a class="el" href="../../db/de9/group__rpc.html#gad54f5cb688f3849ec20ef5372d003702">rpc_tm_setup</a>  (struct <a class="el" href="../../d4/d78/structm0__net__transfer__mc.html">m0_net_transfer_mc</a> *tm, struct <a class="el" href="../../db/d78/structm0__net__domain.html">m0_net_domain</a> *net_dom, const char *ep_addr, struct <a class="el" href="../../d4/d52/structm0__net__buffer__pool.html">m0_net_buffer_pool</a> *pool, uint32_t colour, m0_bcount_t msg_size, uint32_t qlen)</dt>
<dd>Find more appropriate err code. tm does not report cause of failure.  </dd>
<dt><a class="anchor" id="_todo000072"></a>Global <a class="el" href="../../dd/d33/group__dix.html#gaa94ddd6e445fee07a2e7801a72cafe27">sc_key_pos_set</a>  (struct <a class="el" href="../../d9/d1c/structm0__dix__next__sort__ctx.html">m0_dix_next_sort_ctx</a> *ctx, uint32_t key_idx, const uint32_t *recs_nr)</dt>
<dd>: Why it is so?  </dd>
<dt><a class="anchor" id="_todo000097"></a>Global <a class="el" href="../../d0/d55/source__dock__fom_8c.html#abedc41df26c3fe0beae685ba8e0d6811">sd_fom_process_matched_filters</a>  (struct <a class="el" href="../../d3/dbb/structm0__fdmi__src__dock.html">m0_fdmi_src_dock</a> *sd_ctx, struct <a class="el" href="../../d4/d48/structm0__fdmi__src__rec.html">m0_fdmi_src_rec</a> *src_rec)</dt>
<dd>store map &lt;fdmi record id, endpoint&gt;, Phase 2  </dd>
<dt><a class="anchor" id="_todo000222"></a>Global <a class="el" href="../../dd/d7f/group__pool.html#ga4bc31752cd178f4034041c39d3bcf54c">service_ctxs_create</a>  (struct <a class="el" href="../../d5/d33/structm0__pools__common.html">m0_pools_common</a> *pc, bool service_connect)</dt>
<dd>: This needs to be converted to process (m0d) context since it connects to specific process endpoint.  </dd>
<dt><a class="anchor" id="_todo000290"></a>Global <a class="el" href="../../de/d81/spiel__conf__ut_8c.html#abfa03f8bc2f354468c190cd2f872fc55">spiel_conf_ut_init</a>  (void)</dt>
<dd>Use fid convert function to set kind.  </dd>
<dt><a class="anchor" id="_todo000278"></a>Global <a class="el" href="../../df/d3a/group__spiel-api-fspec-intr.html#gab227aff581081cddf57995e6c2baccf9">spiel_process_health_replied_ast</a>  (struct <a class="el" href="../../d5/d32/structm0__sm__group.html">m0_sm_group</a> *grp, struct <a class="el" href="../../de/d78/structm0__sm__ast.html">m0_sm_ast</a> *ast)</dt>
<dd>Need to understand if it would make sense from consumer's standpoint to interrupt stats collection here on a network error.  </dd>
<dt><a class="anchor" id="_todo000291"></a>Global <a class="el" href="../../d3/dff/stats__srv_8c.html#ad271823b8bd25cd4180cac6f7b8a5a9c">stats_add</a>  (struct <a class="el" href="../../d4/d8a/structm0__tl.html">m0_tl</a> *stats_list, struct <a class="el" href="../../d0/d2e/structm0__stats__sum.html">m0_stats_sum</a> *sum)</dt>
<dd>Is it required to check valid <a class="el" href="../../d0/d2e/structm0__stats__sum.html#a226fa247d455a2933a93d9d73521753a">m0_stats_sum::ss_id</a> from some some list? How ? need some global stats id list.  </dd>
<dt><a class="anchor" id="_todo000294"></a>Module <a class="el" href="../../d9/d6a/group__stob.html">stob</a>  </dt>
<dd>more scalable object index instead of a list. </dd>
<dt><a class="anchor" id="_todo000293"></a>Global <a class="el" href="../../d6/d2c/group__stobad.html#ga6e4ea9dd43e3a7b323da708c56f5c641">stob_ad_io_launch</a>  (struct <a class="el" href="../../dc/dca/structm0__stob__io.html">m0_stob_io</a> *io)</dt>
<dd>: Needs to check performance impact of sorting each stobio on ad stob.  </dd>
<dt><a class="anchor" id="_todo000300"></a>Global <a class="el" href="../../d3/d78/group__stoblinux.html#ga19cb24ab57001e5fbf53409c8604f0bd">stob_linux_domain_create_destroy</a>  (struct <a class="el" href="../../d3/df7/structm0__stob__type.html">m0_stob_type</a> *type, const char *path, uint64_t dom_key, void *cfg, bool create)</dt>
<dd>get mode from create cfg  </dd>
<dt><a class="anchor" id="_todo000299"></a>Module <a class="el" href="../../d3/d78/group__stoblinux.html">stoblinux</a>  </dt>
<dd>use explicit state machine instead of ioq threads </dd>
<dt><a class="anchor" id="_todo000163"></a>Global <a class="el" href="../../d2/d61/group__index-dix.html#ga88bd2bee111d9b376d26184d55672cd9">svc_find</a>  (const struct <a class="el" href="../../d3/dd6/structm0__op__idx.html">m0_op_idx</a> *oi)</dt>
<dd>Currently, the implementation of non-distributed indices is very similar to the distributed indices implementation. This makes bug fixing more difficult: every error has to be fixed twice. To solve this issue the implementation should be generalised for both cases in this file. A non-distributed index should be treated as a special type of distributed index (with 1 component catalogue).  </dd>
<dt><a class="anchor" id="_todo000206"></a>Page <a class="el" href="../../d6/d7b/net-test-fspec-cli-console.html">Test console command line parameters</a>  </dt>
<dd>Update obsoleted options. Use  </dd>
<dt><a class="anchor" id="_todo000020"></a>Global <a class="el" href="../../da/d8d/ut_2extmap_8c.html#acba08c3a3319512a31cf338a9871f1a5">test_init</a>  (void)</dt>
<dd>break UT into small transactions  </dd>
<dt><a class="anchor" id="_todo000066"></a>Global <a class="el" href="../../d5/d9a/ut_2rconfc_8c.html#ab0d6964cd632e7b797ac4f70ec8e544b">test_start_stop</a>  (void)</dt>
<dd>Check addresses used by rconfc  </dd>
<dt><a class="anchor" id="_todo000167"></a>Global <a class="el" href="../../d3/d91/utils_8c.html#a70878fa10d238d5e8f6045dcb702d2af">tolerance_of_level</a>  (struct <a class="el" href="../../d0/d6f/structm0__op__io.html">m0_op_io</a> *ioo, uint64_t lv)</dt>
<dd>This code is not required once MOTR-899 lands into dev. Tolerance for the given level.  </dd>
<dt><a class="anchor" id="_todo000134"></a>Global <a class="el" href="../../d0/dec/m0t1fs_2linux__kernel_2file_8c.html#a9ef75ed4bedeacb3a4eca6a6261302d2">tolerance_of_level</a>  (struct <a class="el" href="../../d6/d09/structio__request.html">io_request</a> *req, uint64_t lv)</dt>
<dd>This code is not required once MOTR-899 lands into dev. Tolerance for the given level.  </dd>
<dt><a class="anchor" id="_todo000114"></a>Global <a class="el" href="../../de/d4a/group__m0ham.html#ga40067f460c2ddfff05a10070e617d187">xcode_read_as</a>  (const struct <a class="el" href="../../d6/d9e/structm0__xcode__type.html">m0_xcode_type</a> *type, const char *str, int *rc)</dt>
<dd>XXX Move to xcode/xcode.[hc]. Use this function instead of <a class="el" href="../../d0/dc4/group__conf__dfspec__preload.html#ga34d41b04f28f54ce9ef01deb6c2e06ea">m0_confstr_parse()</a>. </dd>
</dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 14 2022 14:03:27 for Motr by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
