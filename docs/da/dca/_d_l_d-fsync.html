<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Motr: Fsync DLD</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Motr
   &#160;<span id="projectnumber">M0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('da/dca/_d_l_d-fsync.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Fsync DLD </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="../../da/dca/_d_l_d-fsync.html#DLD-fsync-overview">Overview</a></li>
<li><a class="el" href="../../da/dca/_d_l_d-fsync.html#DLD-fsync-funcspec">Functional Specification</a></li>
<li><a class="el" href="../../da/dca/_d_l_d-fsync.html#DLD-fsync-ds">Data Structures</a></li>
<li><a class="el" href="../../da/dca/_d_l_d-fsync.html#DLD-fsync-logspec">Logical Specification</a></li>
<li><a class="el" href="../../da/dca/_d_l_d-fsync.html#DLD-fsync-futurework">Future Work</a></li>
<li><a class="el" href="../../da/dca/_d_l_d-fsync.html#DLD-fsync-errors">Error handling</a></li>
<li><a class="el" href="../../da/dca/_d_l_d-fsync.html#DLD-fsync-tests">Tests</a></li>
<li><a class="el" href="../..//cortx-motr/m0t1fs/linux_kernel/fsync.h.html#fsync-metadata">Metadata</a></li>
<li><a class="el" href="../..//cortx-motr/m0t1fs/linux_kernel/fsync.h.html#fsync-metadata-rq">Requirements</a></li>
<li><a class="el" href="../..//cortx-motr/m0t1fs/linux_kernel/fsync.h.html#fsync-metadata-refs">References</a></li>
</ul>
<hr/>
<h1><a class="anchor" id="DLD-fsync-overview"></a>
Overview</h1>
<p>Fsync is a syscall provided by POSIX to 'write out' all changes to a file that are currently held in memory to persistant storage. This syscall is used by applications to ensure that data can be retrieved even if the system crashes or is rebooted. Fsync writes out both file data and metadata, and blocks the application until this information is written to persistent storage.</p>
<p>Motr backend (be) is used for metadata and FOL records, and has a transaction based interface.</p>
<p>Fsync is implemented by m0t1fs as a function to send an 'fsync' fop to each server that has pending transactions, the reply is sent by each server once the transaction ID specified in the request has become committed. Fsync has both an active and a passive mode. In passive mode the fsync fom merely waits for the transactions to become committed, in active mode it uses <a class="el" href="../../d9/dcf/group__be.html#ga174f219c25061b07e098c97ad43610bf">m0_be_tx_force()</a>, to cause the transactions to make progress more quickly than they otherwise would.</p>
<h1><a class="anchor" id="DLD-fsync-funcspec"></a>
Functional Specification</h1>
<p><a class="el" href="../../df/d10/fsync_8h.html#a389eff049efbd0e1d797f17d94739ff6">m0t1fs_fsync()</a> sends a fop to a set of servers to monitor the progress of a range of transactions. The fop specifies an active/passive mode, a transaction ID and a locality ID.</p>
<p>The server will send a reply when transactions up to and including the specified transaction ID have been committed. In passive mode the fsync state machine will wait until the specified transaction has been committed, at which point it will reply. In active mode the fsync machine will invoke <a class="el" href="../../d9/dcf/group__be.html#ga174f219c25061b07e098c97ad43610bf">m0_be_tx_force()</a> to cause transaction-commit to complete in the shortest possible time and then it will wait. In both cases the reply fop specifies a committed transaction ID, which may be greater than the ID in the request.</p>
<h1><a class="anchor" id="DLD-fsync-ds"></a>
Data Structures</h1>
<div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// fsync request fop</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">struct </span><a class="code" href="../../df/d8b/structm0__fop__fsync.html">m0_fop_fsync</a> {</div><div class="line">        <span class="comment">// the transaction to monitor, reply when this is committed</span></div><div class="line">        uint64_t ff_be_txid;</div><div class="line"></div><div class="line">        <span class="comment">// locality of the target tx</span></div><div class="line">        <span class="keywordtype">size_t</span>   ff_be_locality;</div><div class="line"></div><div class="line">        <span class="comment">// store one of enum m0_fsync_mode</span></div><div class="line">        uint32_t <a class="code" href="../../df/d8b/structm0__fop__fsync.html#a7e242750d052c7bdad1c3a4a3a8a2086">ff_fsync_mode</a>;</div><div class="line">} M0_XCA_RECORD;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> <a class="code" href="../../d8/dd5/fsync__fops_8h.html#aa107388ab23b4f8c45866be89d396cae">m0_fsync_mode</a> {</div><div class="line">        <a class="code" href="../../d8/dd5/fsync__fops_8h.html#aa107388ab23b4f8c45866be89d396caeaa9314bc29e413be2cf04fb709db59b26">M0_FSYNC_MODE_PASSIVE</a>,</div><div class="line">        <a class="code" href="../../d8/dd5/fsync__fops_8h.html#aa107388ab23b4f8c45866be89d396caea0cec2249ef8a9a3a867d815b2fc33b7c">M0_FSYNC_MODE_ACTIVE</a>,</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// fsync reply fop</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">struct </span><a class="code" href="../../df/da4/structm0__fop__fsync__rep.html">m0_fop_fsync_rep</a> {</div><div class="line">        <span class="comment">// return code for the fsync operation. 0 for success</span></div><div class="line">        uint32_t <a class="code" href="../../df/da4/structm0__fop__fsync__rep.html#ad3f8f230e2ad66757ad931dd292d50b3">ffr_rc</a>;</div><div class="line"></div><div class="line">        <span class="comment">// the committed transaction, may be later than requested</span></div><div class="line">        uint64_t ffr_be_committed_txid;</div><div class="line">} M0_XCA_RECORD;</div></div><!-- fragment --><h1><a class="anchor" id="DLD-fsync-logspec"></a>
Logical Specification</h1>
<p>fsync adds a 'uint64_t &lt;prefix&gt;_be_txid' to each fop-reply type that causes FOL records to be generated. At the time of writing these are...</p>
<p>From <a class="el" href="../../dd/d3e/io__fops_8h.html">ioservice/io_fops.h</a>:</p><ul>
<li>write <a class="el" href="../../d5/d4b/structm0__fop__cob__rw__reply.html">m0_fop_cob_rw_reply</a></li>
<li>writev <a class="el" href="../../da/d1c/structm0__fop__cob__writev__rep.html">m0_fop_cob_writev_rep</a></li>
<li>cob-create <a class="el" href="../../da/da1/structm0__fop__cob__op__reply.html">m0_fop_cob_op_reply</a></li>
<li>cob-delete <a class="el" href="../../da/da1/structm0__fop__cob__op__reply.html">m0_fop_cob_op_reply</a></li>
</ul>
<p>From <a class="el" href="../../d0/dda/md__fops_8h.html">mdservice/md_fops.h</a>:</p><ul>
<li>create <a class="el" href="../../df/db1/structm0__fop__create__rep.html">m0_fop_create_rep</a></li>
<li>link <a class="el" href="../../dd/db9/structm0__fop__link__rep.html">m0_fop_link_rep</a></li>
<li>unlink <a class="el" href="../../d4/d77/structm0__fop__unlink__rep.html">m0_fop_unlink_rep</a></li>
<li>open <a class="el" href="../../d3/dff/structm0__fop__open__rep.html">m0_fop_open_rep</a></li>
<li>setattr <a class="el" href="../../d9/d8c/structm0__fop__setattr__rep.html">m0_fop_setattr_rep</a></li>
<li>setxattr <a class="el" href="../../dc/d3a/structm0__fop__setxattr__rep.html">m0_fop_setxattr_rep</a></li>
<li>delxattr <a class="el" href="../../d0/d80/structm0__fop__delxattr__rep.html">m0_fop_delxattr_rep</a></li>
<li>rename <a class="el" href="../../de/d46/structm0__fop__rename__rep.html">m0_fop_rename_rep</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>&lt;prefix&gt;_be_txid is added to the fop-replies inside a new M0_XCA_RECORD <a class="el" href="../../dc/d0a/structm0__fop__mod__rep.html">m0_fop_mod_rep</a>, which includes all those data that are common to several replies.</dd>
<dd>
write uses the same reply-type as read, the &lt;prefix&gt;_be_txid field will be present in both read and write replies, it must be initialised to 0 for read replies.</dd>
<dd>
cob-create and cob-delete share a reply type.</dd>
<dd>
open can currently cause setattr to be called (when nlink changes), in the future it may also cause 'atime' to be updated.</dd></dl>
<p>Code in ioservice and mdservice adds the be transaction ID <a class="el" href="../../d2/d7e/structm0__be__tx.html#a37b9836c35b435817d7d4e909c973354">m0_be_tx::t_id</a> to the reply fop.</p>
<p>Code in m0t1fs/file and m0t1fs/dir adds a mapping between senders and the largest-seen transaction ID for this open file (or directory). This is stored as a new member of struct m0t1fs_inode::ci_pending_tx for both files and directories.</p>
<dl class="section note"><dt>Note</dt><dd>a sender should be identified by <a class="el" href="../../d7/dd6/structm0__reqh__service__ctx.html">m0_reqh_service_ctx</a> which represents a 1:1 relationship between mounted m0t1fs (super block) and a service instance (e.g., mdservice, ioservice).</dd></dl>
<p>The mapping should be stored as an m0_tlist, while any file could be striped accross every server in the cluster, the records are almost always processed as a set. A new struct would be required that holds the mapping of senders to the largest-seen transaction <a class="el" href="../../d8/d0d/structm0__reqh__service__txid.html">m0_reqh_service_txid</a>. These should be allocated when needed (when a reply with a transaction ID is received), and free'd when the file (or directory) is closed.</p>
<p>When fsync() is called for an open file or directory, m0t1fs should first call simple_fsync() to ensure all dirty pages have been pushed through writeback and are pending on the server. simple_fsync() will block until all of its writes have completed, at which point we will have an up-to-date maximum transaction ID for each sender. The m0t1fs fsync code should then process each sender in the mapping and send an fsync fop specifying the maximum transaction ID seen for this sender, the ID for the locality where that transaction lives in and the active/passive flag. fsync() then waits for a reply for each fop before proceeding.</p>
<p>On the ioserver/mdserver, the fsync-fop's fom uses <a class="el" href="../../d9/dcf/group__be.html#ga8185b0d5a18cccd585edfc571f8bcf75">m0_be_engine__tx_find()</a> to find the transaction pointed-to from the fop request and performs different actions depending on the passive/active flag: </p><pre class="fragment">- Active mode:   m0_be_tx_force() gets called to close the transaction's
                 group and trigger its immediate placing. The code then
                 waits until the transaction's state changes to
                 M0_BTS_PLACED.

- Passive mode:  Instead of explictly calling m0_be_tx_force() to trigger
                 transaction logging as Active mode does, Passive mode
                 simply waits until the transaction's state changes to
                 M0_BTS_PLACED (tx_group fom will handle the
                 transaction logging in the background).
</pre><p>In both cases, fsync-fom calls <a class="el" href="../../d1/d59/group__fom.html#ga3da36b83a0def226d7aba23fd436e7fc">m0_fom_wait_on()</a> to wait on tx-&gt;t_sm.sm_chan so it gets woken up when the transaction's state changes.</p>
<p>When fsync-fop completes, a reply is generated, which includes the ID of the target transaction.</p>
<p><a class="el" href="../../d9/dcf/group__be.html#ga174f219c25061b07e098c97ad43610bf">m0_be_tx_force()</a> checks the state of the transaction is M0_BTS_CLOSED and invokes <a class="el" href="../../d9/dcf/group__be.html#gaf67047261f5631923017dc32f47bdbd4">m0_be_tx_group_close()</a> on the transaction's group, using M0_TIME_IMMEDIATELY as the timeout. The group gets then closed and all its transactions get immediately logged and written in-place.</p>
<p>Once a reply for a fsync-fop has been received, the corresponding entry in the mapping could be removed if its recorded maximum transaction ID is less than or equal to the transaction ID that was committed (for example the recorded maximum transaction ID may be 4, an fsync-fop is sent with value 4, and a reply is received with value 12 - due to transactions for other objects or clients that were committed in the intervening time). It is also possible that new transactions are started after fsync was called, and that the maximum transaction ID has increased since we started waiting.</p>
<h1><a class="anchor" id="DLD-fsync-futurework"></a>
Future Work</h1>
<ol type="1">
<li>VFS also provides a mechanism for synchronising the contents of a whole mount-point using the syncfs syscall which (eventually) calls sync_fs() as a super block operation. To allow this call to be implemented later, the fsync code should maintain a mount-point-wide map of sender to maximum transaction IDs in the super block. This should be updated whenever a new reply is received, and have its records pruned whenever a fsync-fop-reply is received.</li>
<li>There is no scope for cancelling an fsync operation, and an application may become blocked until it completes. To allow higher-priority conflicting operations to occur (such as killing the application, or umount-ing m0t1fs), an fsync-cancel ioctl could be provided. It should specify a process id and file descriptor ID (both easily discovered through /proc), which causes the fsync operation to complete early (with a failure).</li>
<li>A m0_be_engine::eng_last_tx_placed field could be used to keep track of the ID of the last transaction placed by the engine. This value can then be returned as part of every fsync fop reply, so clients know the current maximum transaction ID of a sender and can save some fsync fop requests.</li>
</ol>
<h1><a class="anchor" id="DLD-fsync-errors"></a>
Error handling</h1>
<ul>
<li>no reply to fsync-fop POSIX requires that the application calling fsync() will be blocked until the action has been completed (fsync-reply has been received) [1]. The RPC layer will take care of lost requests and replies, but other events may cause the reply to be delayed indefinitely. This error is not handled, there is no timeout for fsync-fops.</li>
<li><p class="startli">transaction-to-sync hasn't arrived yet Clients should only receive transaction IDs from reply fops, so there is no case where an fsync-fop can specify a future transaction that has not yet been received (let alone replied to). This is considered a fatal error, and an fsync reply fop is sent immediately with 'EINVAL' as the return code in 'ffr_rc'.</p>
<p class="startli">This error could also occur if rpc_items are replayed in a different order, the <a class="el" href="../../dd/d65/structm0__rpc__session.html#ad180cb69f2332d72844eb9baa902425d">m0_rpc_session::s_xid</a> field suggests that any replay will occur in the original order. This scenario is not considered.</p>
</li>
<li>transaction ID overflow It is assumed that no server/target/device will survive the 18 quintillion transactions needed to overflow a 64 bit counter, and thus transaction ID overflow does not need to be considered.</li>
<li>invalid mode received If the server fom receives a mode it does not recognise, it must send a reply with the value 'EINVAL' as the return code in 'ffr_rc'.</li>
<li><p class="startli">no rpc_conn is available for that sender Between receiving a reply, and fsync() being called, the server may fail or become unavailable. In this case an entry in the mapping will exist, but it is not possible for fsync() to send a fop to the failed server.</p>
<p class="startli">In this case fsync() should interact with DTM to determine whether the transaction was replayed to a different node, and committed there. For now fsync() should just assume the server could have failed after receiving the message.</p>
</li>
<li>simple_fsync() failed partially or completely If any of the IO operations triggered by simple_fsync() fails, the fsync() syscall must abort and return 'EIO'.</li>
<li>error when updating the mapping between senders and max. transaction IDs Not having a valid and updated maximum transaction ID for a file means the file cannot be fsync'ed properly. It needs to be assessed how likely it is an error is detected at that stage.<ul>
<li>to mitigate this risk, the '<a class="el" href="../../d8/d0d/structm0__reqh__service__txid.html">m0_reqh_service_txid</a>' is cached between sending an fsync-fop and receiving its reply. These records are only free'd when an inode is destroyed, so there is no scope for the record being not-found. The remaining case where this could happen is if the reply code is unable to obtain the required locks, indicating a deadlock, which the kernel will detect and 'handle'.</li>
</ul>
</li>
<li>'force functions' might fail Forcing a transaction seeks to shorten the time a transaction is kept waiting as part of an IO optimization mechanism. Even if this functions fail, the transaction is expected to be eventually logged and written and thus no special measures are required in this case.</li>
</ul>
<h1><a class="anchor" id="DLD-fsync-tests"></a>
Tests</h1>
<ul>
<li>send fsync-fop expect fsync-reply-fop</li>
<li>check the service-&gt;txid mapping is cleaned up as appropriate</li>
<li>send fsync-fop receive fsync-reply-fop with a higher ID than expected</li>
<li>check service-&gt;txid mapping is cleaned up as appropriate</li>
<li>send fsync-fop for a transaction in the future, expect fsync-reply-fop with EINVAL ffr_rc</li>
<li>send fsync-fop, cause max_txid to increase before the reply is received</li>
<li>check service-&gt;txid mapping isn't cleaned up</li>
<li>Can't easily test a 'never completes' scenario - fault injection and test-timeout? </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 14 2022 14:03:25 for Motr by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
