<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Motr: Copy Packet DLD</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Motr
   &#160;<span id="projectnumber">M0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('da/d67/_c_p_d_l_d.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Copy Packet DLD </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-ovw">Overview</a></li>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-def">Definitions</a></li>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-req">Requirements</a></li>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-depends">Dependencies</a></li>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-highlights">Design Highlights</a></li>
<li><a class="el" href="../../d5/de7/_c_p_d_l_d-fspec.html">Functional Specification</a></li>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-lspec">Logical Specification</a><ul>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-lspec-comps">Component Overview</a></li>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-lspec-state">State Specification</a></li>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-lspec-mn-xform">Transformation in multinode environment</a><ul>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-lspec-mn-xform-out">Outgoing path</a></li>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-lspec-mn-xform-in">Incoming path</a></li>
</ul>
</li>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-lspec-thread">Threading and Concurrency Model</a></li>
</ul>
</li>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-conformance">Conformance</a></li>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-ut">Unit Tests</a></li>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-st">System Tests</a></li>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-ref">References</a></li>
</ul>
<hr/>
 <h1><a class="anchor" id="CPDLD-ovw"></a>
Overview</h1>
<p>Copy packet is the data structure used to describe the movement of a piece of re-structured data between various copy machine replica nodes and within the same replica. It is an entity which has data as well as operations. Copy packets are FOMs of special type, created when a data re-structuring request is posted to replica.</p>
<p>Copy packet processing logic is implemented in a non-blocking way. Packet has buffers to carry data and FOM for execution in context of request handler. It can perform different work which depends on its phase (i.e. FOM phase) in execution.</p>
<hr/>
 <h1><a class="anchor" id="CPDLD-def"></a>
Definitions</h1>
<ul>
<li><b>Copy Packet:</b> A chunk of data traversing through the copy machine.</li>
<li><b>Copy packet acknowledgement:</b> Reply received, representing successful processing of the copy packet. With this acknowledgement, copy packet releases various resources and updates its internal state.</li>
<li><b>Next phase function:</b> Given a copy packet, this identifies the phase that has to be assigned to this copy packet. The next phase function (<a class="el" href="../../d2/dd0/structm0__cm__cp__ops.html#a15c17d5bc07372087bf1b95c705ac267">m0_cm_cp_ops::co_phase_next()</a>) determines the routing and execution of copy packets through the copy machine.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="CPDLD-req"></a>
Requirements</h1>
<ul>
<li><b>r.cm.cp</b> Copy packet abstraction implemented such that it represents the data to be transferred within replica.</li>
<li><b>r.cm.cp.async</b> Every read-write (receive-send) by replica should follow the non-blocking processing model of Motr design.</li>
<li><b>r.cm.buffer_pool</b> Copy machine should provide a buffer pool, which is efficiently used for copy packet data.</li>
<li><b>r.cm.cp.bulk_transfer</b> All data packets (except control packets) that are sent over RPC should use bulk-interface for communication.</li>
<li><b>r.cm.cp.fom.locality</b> Copy packet FOMs should be efficiently assigned request handler locality without causing any deadlock or data corruption.</li>
<li><b>r.cm.addb</b> Copy packet should have its own addb context, (similar to fom), although it uses different addb locations, this will trace the entire path of the copy packet.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="CPDLD-depends"></a>
Dependencies</h1>
<ul>
<li><b>r.cm.service</b> Copy packet FOMs are executed in context of copy machine replica.</li>
<li><b>r.cm.ops</b> Replica provides operations to create, configure and execute copy packet FOMs.</li>
<li><b>r.layout</b> Data restructuring needs layout info.</li>
<li><b>r.layout.input-iterator</b> Iterate over layout info to create packets and forward it in replica.</li>
<li><b>r.resource</b> Resources like buffers, CPU cycles, network bandwidth, storage bandwidth are needed by copy packet FOM during execution.</li>
<li><b>r.confc</b> Data from configuration will be used to initialise copy packets.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="CPDLD-highlights"></a>
Design Highlights</h1>
<ul>
<li>Copy packet is implemented as FOM, which inherently has non-blocking model of motr.</li>
<li>Distributed sliding window algorithm is used to process copy packets within copy machine replica.</li>
<li>Layout is updated periodically as the restructuring progresses.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="CPDLD-lspec"></a>
Logical Specification</h1>
<ul>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-lspec-comps">Component Overview</a><ul>
<li><a class="el" href="../../da/d18/group___d_l_d_c_p_internal.html">Copy packet internal</a> <br />
 - <a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-lspec-state">State Specification</a></li>
</ul>
</li>
<li><a class="el" href="../../da/d67/_c_p_d_l_d.html#CPDLD-lspec-thread">Threading and Concurrency Model</a></li>
</ul>
<h2><a class="anchor" id="CPDLD-lspec-comps"></a>
Component Overview</h2>
<p><b>Copy packet functionality is split into two parts:</b></p>
<ul>
<li>generic functionality, implemented by cm/cp.[hc] and</li>
<li>copy packet type functionality which is based on copy machine type. (e.g. SNS, Replication, &amp;c).</li>
</ul>
<p><b>Copy packet creation:</b> Given the size of the buffer pool, the replica calculates its initial sliding window (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dec/structm0__cm__sw.html">m0_cm_sw</a>). Once the replica learns windows of every other replica, <a class="el" href="../../da/d8d/ut_2extmap_8c.html#a93ac04629f844f68ac58615004a135e7">it</a> can produce <a class="el" href="../../d8/d6f/ut_2sync_8c.html#a6e096170b1a10d82c6e08fbafaf92355">copy</a> packets that replicas (including this <a class="el" href="../../d8/dea/lib_2ut_2misc_8c.html#a6a8fda42257413778e8892aaef5aea54">one</a>) are <a class="el" href="../../d2/d66/group__dtm.html#ga1df324a6d0cdf8a7df921060a93d0de4">ready</a> to process.</dd></dl>
<p>Copy packet is created when,</p><ul>
<li>replica starts. It should be made sure that sliding window has enough packets for processing by creating them at start.</li>
<li>has space. After completion of each copy packet, space in sliding window is checked. If space exists, then copy packets will be created.</li>
</ul>
<p><b>Copy Packet destruction:</b> Copy packet is destroyed by setting its phase to M0_CCP_FINI. Following are some cases where copy packet is finalised.</p>
<ul>
<li>On notification of copy packet data written to device/container.</li>
<li>During transformation, packets that are no longer needed, are finalised.</li>
<li>On completion of copy packet transfer over the network.</li>
</ul>
<p><b>Copy packet cooperation within replica:</b> Copy packet needs resources (memory, processor, &amp;c.) to do processing:</p>
<ul>
<li>Needs buffers to keep data during IO.</li>
<li>Needs buffers to keep data until the transfer is finished.</li>
<li>Needs buffers to keep intermediate checksum until all units of an aggregation group have been received.</li>
</ul>
<p>The copy packet (and its associated buffers) will go through various phases. In a particular scenario where data read from device creates a copy packet, then copy packet transitions to data transformation phase, which, after reconstructing the data, transitions to data write or send, which submits IO. On IO completion, the copy packet is destroyed.</p>
<p>Copy machine provides and manages resources required by the copy packet. e.g. In case of SNS Repair, copy machine creates 2 buffer pools, for incoming and outgoing copy packets. Based on the availability of buffers in these buffer pools, new copy packets are created. On finalisation of a copy packet, the corresponding buffers are released back to the respective buffer pool.</p>
<h2><a class="anchor" id="CPDLD-lspec-state"></a>
State Specification</h2>
<p><b>Copy packet is a state machine that goes through following phases:</b></p>
<ul>
<li><b>INIT</b> Copy packet gets initialised with input data. e.g In SNS, extent, COB, &amp;c gets initialised. Usually this is done with some iterator over layout info. (m0_cm_cp_phase::M0_CCP_INIT)</li>
<li><b>READ</b> Reads data from its associated container or device according to the input information, and places the data in a copy packet data buffer. Before doing this, it needs to grab necessary resources: memory, locks, permissions, CPU/disk bandwidth, etc. Data/parity is encapsulated in copy packet, and the copy packets are transfered to next phase. (m0_cm_cp_phase::M0_CCP_READ)</li>
<li><b>WRITE</b> Writes data from copy packet data buffer to the container or device. Spare container and offset to write is identified from layout information. (m0_cm_cp_phase::M0_CCP_WRITE)</li>
<li><b>XFORM</b> Data restructuring is done in this phase. This phase would typically process a lot of local copy packets. E.g., for SNS repair machine, a file typically has a component object (cob) on each device in the pool, which means that a node could (and should) calculate "partial parity" of all local units, instead of sending each of them separately across the network to a remote copy machine replica. (m0_cm_cp_phase::M0_CCP_XFORM)</li>
<li><b>IOWAIT</b> Waits for IO to complete. (m0_cm_cp_phase::M0_CCP_IO_WAIT)</li>
<li><b>SW_CHECK</b> Checks if the copy packet is in sliding window. If it is not, then waits in this phase till it fits in the sliding window.</li>
<li><b>SEND</b> Send copy packet over network. Control FOP and bulk transfer are used for sending copy packet. (m0_cm_cp_phase::M0_CCP_SEND)</li>
<li><b>SEND_WAIT</b> Waits till the acknowledgement is received that copy packet has been reached to the destination.</li>
<li><b>BUF_ACQ</b> Acquire the buffers based on the control fop information.</li>
<li><b>RECV_INIT</b> After acquiring required number of buffers, copy packet FOM transitions to m0_cm_cp_phase::M0_CCP_RECV_INIT phase and initiates zero copy using rpc_bulk.</li>
<li><b>RECV_WAIT</b> Zero copy is completed. Any cleanup, if is done in this phase.</li>
<li><b>FINI</b> Finalises copy packet.</li>
</ul>
<p>Specific copy packet can have phases in addition to these phases. Additional phases may be used to do processing for copy packet specific functionality. Handling of additional phases also can be done using next phase function, as implementation of next phase function is also specific to copy packet type.</p>
<p>Transition between standard phases is done by next phase function. It will produce the next phase according to the configuration of the copy machine and the copy packet itself.</p>
<p><b>State diagram for copy packet:</b> </p><div class="dotgraph">
<img src="../../dot_inline_dotgraph_6.png" alt="dot_inline_dotgraph_6.png" border="0" usemap="#dot_inline_dotgraph_6.map"/>
<map name="dot_inline_dotgraph_6.map" id="dot_inline_dotgraph_6.map"></map>
</div>
<h2><a class="anchor" id="CPDLD-lspec-mn-xform"></a>
Transformation in multinode environment</h2>
<p>When copy packet fom enters transformation phase, it calculates partial parity on that particular node. This calculation is based on the incoming copy packets for an aggregation group. In case of multinode data restructuring, transformation is executed locally i.e. along outgoing path as well as along the incoming path.</p>
<h3><a class="anchor" id="CPDLD-lspec-mn-xform-out"></a>
Outgoing path</h3>
<p>The transformed copy packet contains partial parity of the local copy packets belonging to a particular aggregation group. The transformed copy packet can either be written locally or can be sent to remote destination node.</p>
<h3><a class="anchor" id="CPDLD-lspec-mn-xform-in"></a>
Incoming path</h3>
<p>The transformed copy packet contains the partial parity of the copy packets which are received from other nodes as well as local copy packets. This is executed typically on the destination node (i.e. node on which spare units are allocated, in case of repair operation). Transformation phase function inherently waits for all the copy packets in an aggregation group to be transformed. For this to happen, transformation function has to do bookkeeping of following information:</p><ul>
<li>number of copy packets that have been transformed for a particular aggregation group (<a class="el" href="../../d6/d14/structm0__cm__aggr__group.html#aa148c5153af3c4ac1bd687488b70ad21">m0_cm_aggr_group::cag_transformed_cp_nr</a>).</li>
<li>indices of the copy packets in an aggregation group that have been transformed (this knowledge is required by parity recovery algorithm like Reed-Solomon) This is stored using a bitmap (<a class="el" href="../../d8/d32/structm0__cm__cp.html#afee1cacc1e4964d09302f84a44681099">m0_cm_cp::c_xform_cp_indices</a>).</li>
</ul>
<p>The index of the copy packet in an aggregation group is stored by the iterator in <a class="el" href="../../d8/d32/structm0__cm__cp.html#a882a847129adaf4116abbfd06c6027e2">m0_cm_cp::c_ag_cp_idx</a>. This index is used by the transformation function to populate the bitmap (<a class="el" href="../../d8/d32/structm0__cm__cp.html#afee1cacc1e4964d09302f84a44681099">m0_cm_cp::c_xform_cp_indices</a>). Note: This index should be global index of a copy packet in an aggregation group.</p>
<p>For any aggregation group, transformation is marked as complete, iff all indices in the bitmap are set to true.</p>
<h2><a class="anchor" id="CPDLD-lspec-thread"></a>
Threading and Concurrency Model</h2>
<p>Copy packet is implemented as a FOM and thus do not have its own thread. It runs in the context of reqh threads. So FOM locality group lock (i.e m0_cm_cp:c_fom:fo_loc:fl_group:s_lock) is used to serialise access to <a class="el" href="../../d8/d32/structm0__cm__cp.html">m0_cm_cp</a> and its operation.</p>
<hr/>
 <h1><a class="anchor" id="CPDLD-conformance"></a>
Conformance</h1>
<ul>
<li><b>i.cm.cp</b> Replicas communicate using copy packet structure.</li>
<li><b>i.cm.cp.async</b> Copy packet are implemented as FOM. FOM in request handler infrastructure makes it non-blocking.</li>
<li><b>i.cm.buffer_pool</b> Buffer pools are managed by copy machine which cater to the requirements of copy packet data.</li>
<li><b>i.cm.cp.bulk_transfer</b> All data packets (except control packets) that are sent over RPC, use bulk-interface for communication.</li>
<li><b>i.cm.cp.fom.locality</b> Copy machine implements its type specific <a class="el" href="../../d2/dd0/structm0__cm__cp__ops.html#a40f5d3f5b65c18947caa4a68c71c65c5">m0_cm_cp_ops::co_home_loc_helper()</a>.</li>
<li><b>i.cm.cp.addb</b> copy packet uses ADDB context of copy machine.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="CPDLD-ut"></a>
Unit Tests</h1>
<ul>
<li>Basic Test: Alloc, Init, fini and free.</li>
<li>Test storage phases (write, read and then verify).</li>
<li>Test transformation phase. Wait in the transformation phase till the bitmap in the transformed copy packet has all its bits set to true.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="CPDLD-st"></a>
System Tests</h1>
<hr/>
 <h1><a class="anchor" id="CPDLD-ref"></a>
References</h1>
<p>For documentation links, please refer to this file : doc/motr-design-doc-list.rst</p><ul>
<li>HLD of SNS Repair</li>
<li>HLD of Copy machine and agents </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d3/dd6/_d_l_d_i_x.html">Detailed Designs</a></li>
    <li class="footer">Generated on Thu Apr 14 2022 14:03:22 for Motr by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
