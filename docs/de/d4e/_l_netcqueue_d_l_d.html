<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Motr: LNet Buffer Event Circular Queue DLD</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Motr
   &#160;<span id="projectnumber">M0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('de/d4e/_l_netcqueue_d_l_d.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">LNet Buffer Event Circular Queue DLD </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-ovw">Overview</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-def">Definitions</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-req">Requirements</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-depends">Dependencies</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-highlights">Design Highlights</a></li>
<li><a class="el" href="../../d1/db3/cqueue_d_l_d-fspec.html">Functional Specification</a><ul>
<li><a class="el" href="../../dd/d08/group__bevcqueue.html">External Interfaces</a> <br />
 - <a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-lspec">Logical Specification</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-lspec-comps">Component Overview</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-lspec-q">Logic of the Circular Queue</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-lspec-state">State Specification</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-lspec-thread">Threading and Concurrency Model</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-lspec-numa">NUMA optimizations</a></li>
</ul>
</li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-conformance">Conformance</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-ut">Unit Tests</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-st">System Tests</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-O">Analysis</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-ref">References</a></li>
</ul>
<hr/>
 <h1><a class="anchor" id="cqueueDLD-ovw"></a>
Overview</h1>
<p>The circular queue provides a data structure and interfaces to manage a lock-free queue for a single producer and consumer. The producer and consumer can be in different address spaces with the queue in shared memory. The circular queue is designed to specifically meet the needs of the <a class="el" href="../../db/dd7/_k_l_net_core_d_l_d.html">Core API</a>. In particular see the <a class="el" href="../../db/dd7/_k_l_net_core_d_l_d.html#KLNetCoreDLD-lspec-bevq">The Buffer Event Queue</a> section.</p>
<p>The queue implementation does not address how the consumer gets notified that queue elements have been produced. That functionality is provided separately by the Core API <a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga327d60c2c88dba4beb81eaada363e4fa">nlx_core_buf_event_wait()</a> subroutine.</p>
<hr/>
 <h1><a class="anchor" id="cqueueDLD-def"></a>
Definitions</h1>
<ul>
<li>HLD of Motr LNet Transport : For documentation links, please refer to this file : doc/motr-design-doc-list.rst</li>
</ul>
<hr/>
 <h1><a class="anchor" id="cqueueDLD-req"></a>
Requirements</h1>
<ul>
<li><b>r.m0.lib.atomic.interoperable-kernel-user-support</b> The implementation shall provide a queue that supports atomic, interoperable sharing between kernel to user-space.</li>
<li><b>r.net.xprt.lnet.growable-event-queue</b> The implementation shall support an event queue to which new elements can be added over time.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="cqueueDLD-depends"></a>
Dependencies</h1>
<ul>
<li>The <a class="el" href="../../d3/de8/group__atomic.html">Atomic</a> API.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="cqueueDLD-highlights"></a>
Design Highlights</h1>
<ul>
<li>A data structure representing a circular queue.</li>
<li>The circular queue efficiently delivers event notifications from the LNet Transport Kernel Core layer to the LNet transport layer.</li>
<li>Handles atomic access to elements in the queue for a single producer and consumer.</li>
<li>Handles dynamically adding new elements to the circular queue.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="cqueueDLD-lspec"></a>
Logical Specification</h1>
<ul>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-lspec-comps">Component Overview</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-lspec-q">Logic of the Circular Queue</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-lspec-xlink">Cross Address Space Linkage Support</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-lspec-qalloc">Circular Queue Allocation</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-lspec-state">State Specification</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-lspec-thread">Threading and Concurrency Model</a></li>
<li><a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-lspec-numa">NUMA optimizations</a></li>
</ul>
<h2><a class="anchor" id="cqueueDLD-lspec-comps"></a>
Component Overview</h2>
<p>The circular queue is a single component.</p>
<h2><a class="anchor" id="cqueueDLD-lspec-q"></a>
Logic of the Circular Queue</h2>
<p>The circular queue is a FIFO queue. The implementation maintains pointers for the consumer and producer, a count of the number of elements that can currently be consumed, The total number of elements in the queue (both those that are consumable and those that are not currently consumable) and operations for accessing the pointers and for moving them around the circular queue elements. The application manages the memory containing the queue itself, and adds new elements to the queue when the size of the queue needs to grow. In this discussion of the logic, the pointers are named <code>consumer</code>, <code>producer</code> and <code>next</code> for brevity.</p>
<div class="dotgraph">
</div>
<p>The elements starting after <code>consumer</code> up to but not including <code>producer</code> contain data to be consumed (those elements marked with "x" in the diagram). So, <code>consumer</code> follows <code>producer</code> around the circular queue. When <code>consumer-&gt;next</code> is the same as <code>producer</code>, the queue is empty (requiring that the queue be initialized with at least 2 elements). The element pointed to by <code>consumer</code> (element "y" in the diagram) is the element most recently consumed by the consumer. The producer cannot use this element, because if it did, producing that element would result in moving <code>producer</code> so that it would pass <code>consumer</code>.</p>
<p>In the context of the LNet Buffer Event Queue, the transport should add enough elements to the queue strictly before it enqueues buffer operations requiring subsequent completion notifications. The number required is the total number of possible events generated by queued buffers, plus one extra element for the most recently consumed event notification. The circular queue does not enforce this requirement, but does provide APIs that the transport can use to determine the current number of elements in the queue and to add new elements.</p>
<p>The element denoted by <code>producer</code> is returned by <a class="el" href="../../dd/d08/group__bevcqueue.html#ga6027e82fa54371c2e9335f5366455adf">bev_cqueue_pnext()</a> as long as the queue is not full. This allows the producer to determine the next available element and populate it with the data to be produced. Once the element contains the data, the producer then calls <a class="el" href="../../dd/d08/group__bevcqueue.html#gaef877c0746747aab043617177b5973df">bev_cqueue_put()</a> to make that element available to the consumer. This call also moves the <code>producer</code> pointer to the next element and increments the <code>count</code> of consumable elements.</p>
<p>The consumer uses <a class="el" href="../../dd/d08/group__bevcqueue.html#ga77e31d64b61358e7d0d559a774ceb639">bev_cqueue_get()</a> to get the next available element containing data in FIFO order. Consuming an element causes <code>consumer</code> to be pointed at the next element in the queue and decrementing the <code>count</code> of consumable elements. After this call returns, the consumer "owns" the element returned, element "y" in the diagram. The consumer owns this element until it calls <a class="el" href="../../dd/d08/group__bevcqueue.html#ga77e31d64b61358e7d0d559a774ceb639">bev_cqueue_get()</a> again, at which time ownership reverts to the queue and can be reused by the producer.</p>
<h2><a class="anchor" id="cqueueDLD-lspec-xlink"></a>
Cross Address Space Linkage Support</h2>
<p>The pointers themselves are more complex than the description above suggests. The <code>consumer</code> pointer refers to the element just consumed in the consumer's (the transport) address space. The <code>producer</code> pointer refers to the element in the producer's (the kernel) address space.</p>
<p>A queue link element (the <code>next</code> pointer in the preceding discussion) is represented by the <a class="el" href="../../d1/d60/structnlx__core__bev__link.html">nlx_core_bev_link</a> data structure: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="../../d1/d60/structnlx__core__bev__link.html">nlx_core_bev_link</a> {</div><div class="line">         <span class="comment">// Self pointer in the transport address space.</span></div><div class="line">         <a class="code" href="../../d8/de0/group___l_net_core.html#ga069c6e5507e1ebf2931a1358f46e3461">nlx_core_opaque_ptr_t</a> <a class="code" href="../../d1/d60/structnlx__core__bev__link.html#acc3cf3987686e39b42b4a3e71e47131b">cbl_c_self</a>;</div><div class="line">         <span class="comment">// Pointer to the next element in the consumer address space.</span></div><div class="line">         <a class="code" href="../../d8/de0/group___l_net_core.html#ga069c6e5507e1ebf2931a1358f46e3461">nlx_core_opaque_ptr_t</a> <a class="code" href="../../d1/d60/structnlx__core__bev__link.html#a69db7719f04d4f86ab31c502cce79f06">cbl_c_next</a>;</div><div class="line">         <span class="comment">// Self reference in the producer.</span></div><div class="line">         <span class="keyword">struct </span><a class="code" href="../../d4/d08/structnlx__core__kmem__loc.html">nlx_core_kmem_loc</a> <a class="code" href="../../d1/d60/structnlx__core__bev__link.html#a4018193b850dc4b840fb253584875efe">cbl_p_self_loc</a>;</div><div class="line">         <span class="comment">// Reference to the next element in the producer.</span></div><div class="line">         <span class="keyword">struct </span><a class="code" href="../../d4/d08/structnlx__core__kmem__loc.html">nlx_core_kmem_loc</a> <a class="code" href="../../d1/d60/structnlx__core__bev__link.html#a40e37302f5783236edcb422cf9280765">cbl_p_next_loc</a>;</div><div class="line">};</div></div><!-- fragment --><p> The data structure maintains separate "opaque" pointer fields for the producer and consumer address spaces. Elements in the queue are linked through both flavors of their <code>next</code> field. The initialization of this data structure is described in <a class="el" href="../../de/d4e/_l_netcqueue_d_l_d.html#cqueueDLD-lspec-qalloc">Circular Queue Allocation</a>. The opaque pointer type is derived from ::uint64_t. In the case of the producer, the <code><a class="el" href="../../d4/d08/structnlx__core__kmem__loc.html">nlx_core_kmem_loc</a></code> structure is used instead of a pointer. This allows the buffer event object itself to be mapped and unmapped temporarily, rather than requiring all buffer events to be mapped in the kernel at all times (since this could exhaust the kernel page map table in the case of a user space consumer).</p>
<p>When the producer performs a <a class="el" href="../../dd/d08/group__bevcqueue.html#gaef877c0746747aab043617177b5973df">bev_cqueue_put()</a> call, internally, this call uses <a class="el" href="../../d1/d60/structnlx__core__bev__link.html#a40e37302f5783236edcb422cf9280765">nlx_core_bev_link::cbl_p_next_loc</a> to refer to the next element (and increment the <code>count</code> of consumable elements). Similarly, when the consumer performs a <a class="el" href="../../dd/d08/group__bevcqueue.html#ga77e31d64b61358e7d0d559a774ceb639">bev_cqueue_get()</a> call, internally this subroutine uses <a class="el" href="../../d1/d60/structnlx__core__bev__link.html#a69db7719f04d4f86ab31c502cce79f06">nlx_core_bev_link::cbl_c_next</a> (and decrements the <code>count</code> of consumable elements). Note that only allocation, discussed below, modifies any of these pointers. Steady-state operations on the queue only modify the <code>consumer</code> and <code>producer</code> pointers.</p>
<p>Because the <code>producer</code> "pointer" is implemented as a <a class="el" href="../../d4/d08/structnlx__core__kmem__loc.html">nlx_core_kmem_loc</a>, it cannot be accessed atomically. So, a comparison like</p>
<div class="fragment"><div class="line"><a class="code" href="../../d1/d41/ut_2rwlock_8c.html#a1d2a9f68c117ca7f7fdcb220f4c08fa4">q</a>-&gt;producer != <a class="code" href="../../d1/d41/ut_2rwlock_8c.html#a1d2a9f68c117ca7f7fdcb220f4c08fa4">q</a>-&gt;consumer</div></div><!-- fragment --><p>cannot be implemented in general, without synchronization. However, by keeping an atomic <code>count</code> of consumable elements, subroutines such as <code><a class="el" href="../../dd/d08/group__bevcqueue.html#ga5d24e1b0bc217d8d53b11f0afcdcce03">bev_cqueue_is_empty()</a></code> can be implemented by testing the <code>count</code> rather than comparing pointers.</p>
<h2><a class="anchor" id="cqueueDLD-lspec-qalloc"></a>
Circular Queue Allocation</h2>
<p>The circular queue must contain at least 2 elements, as discussed above. Additional elements can be added to maintain the requirement that the number of elements in the queue equals or exceeds the number of pending buffer operations, plus one element for the most recently consumed operation.</p>
<p>The initial condition is shown below. In this diagram, the queue is empty (see the state discussion, below). There is room in the queue for one pending buffer event and one completed/consumed event.</p>
<div class="dotgraph">
<img src="../../dot_inline_dotgraph_23.png" alt="dot_inline_dotgraph_23.png" border="0" usemap="#dot_inline_dotgraph_23.map"/>
<map name="dot_inline_dotgraph_23.map" id="dot_inline_dotgraph_23.map"></map>
</div>
<p>Before adding additional elements, the following are true:</p><ul>
<li>The number of elements in the queue, N, equals the number of pending operations plus one for the most recently consumed operation completion event.</li>
<li>The producer produces one event per pending operation.</li>
<li>The producer will never catch up with the consumer. Given the required number of elements, the producer will run out of work to do when it has generated one event for each buffer operation, resulting in a state where <code> producer == consumer </code>.</li>
</ul>
<p>This means the queue can <b>safely</b> be expanded at the location of the <code>consumer</code> pointer (i.e. in the consumer address space), without affecting the producer. Elements are added as follows:</p>
<ol type="1">
<li>Allocate and initialize a new queue element (referred to as <code>newnode</code>) which sets <code>newnode-&gt;c_self</code> and <code>newnode-&gt;p_self</code>.</li>
<li>Set <code> newnode-&gt;next = consumer-&gt;next </code></li>
<li>Set <code> consumer-&gt;next = newnode </code></li>
<li>set <code> consumer = newnode </code></li>
</ol>
<p>Steps 2-4 are performed in <a class="el" href="../../dd/d08/group__bevcqueue.html#ga590b6faabdb5da756b429cf13c4c0ec4">bev_cqueue_add()</a>. Because several fields need to be updated, simple atomic operations are insufficient. Thus, the transport layer must synchronize calls to <a class="el" href="../../dd/d08/group__bevcqueue.html#ga590b6faabdb5da756b429cf13c4c0ec4">bev_cqueue_add()</a> and <a class="el" href="../../dd/d08/group__bevcqueue.html#ga77e31d64b61358e7d0d559a774ceb639">bev_cqueue_get()</a>, because both calls affect the consumer. Given that <a class="el" href="../../dd/d08/group__bevcqueue.html#ga590b6faabdb5da756b429cf13c4c0ec4">bev_cqueue_add()</a> completes its three operations before returning, and <a class="el" href="../../dd/d08/group__bevcqueue.html#ga590b6faabdb5da756b429cf13c4c0ec4">bev_cqueue_add()</a> is called before the new buffer is added to the queue, there is no way the producer will try to generate an event and move its pointer forward until <a class="el" href="../../dd/d08/group__bevcqueue.html#ga590b6faabdb5da756b429cf13c4c0ec4">bev_cqueue_add()</a> completes. This allows the transport layer and core layer to continue interact only using atomic operations.</p>
<p>A diagrammatic view of these steps is shown below. The dotted arrows signify the pointers before the new node is added. The Step numbers correspond to steps 2-4 above. </p><div class="dotgraph">
<img src="../../dot_inline_dotgraph_24.png" alt="dot_inline_dotgraph_24.png" border="0" usemap="#dot_inline_dotgraph_24.map"/>
<map name="dot_inline_dotgraph_24.map" id="dot_inline_dotgraph_24.map"></map>
</div>
<p>Once again, updating the <code>next</code> pointer is less straight forward than the diagram suggests. In step 1, the node is allocated by the transport layer. Once allocated, initialization includes the transport layer setting the <a class="el" href="../../d1/d60/structnlx__core__bev__link.html#acc3cf3987686e39b42b4a3e71e47131b">nlx_core_bev_link::cbl_c_self</a> pointer to point at the node and having the kernel core layer "bless" the node by setting the <a class="el" href="../../d1/d60/structnlx__core__bev__link.html#a4018193b850dc4b840fb253584875efe">nlx_core_bev_link::cbl_p_self_loc</a> field. After the self pointers are set, the next fields can be set by using these self fields. Since allocation occurs in the transport address space, the allocation logic uses the <a class="el" href="../../d1/d60/structnlx__core__bev__link.html#a69db7719f04d4f86ab31c502cce79f06">nlx_core_bev_link::cbl_c_next</a> pointers of the existing nodes for navigation, and sets both the <code><a class="el" href="../../d1/d60/structnlx__core__bev__link.html#a69db7719f04d4f86ab31c502cce79f06">nlx_core_bev_link::cbl_c_next</a></code> and <a class="el" href="../../d1/d60/structnlx__core__bev__link.html#a40e37302f5783236edcb422cf9280765">nlx_core_bev_link::cbl_p_next_loc</a> fields. The <code>cbl_p_next_loc</code> field is set by using the <code>cbl_c_next-&gt;cbl_p_self_loc</code> value, which is treated opaquely by the transport layer. So, steps 2 and 3 update both pairs of pointers. Allocation has no affect on the <code>producer</code> reference itself, only the <code>consumer</code> pointer.</p>
<p>The resultant 3 element queue looks like this: </p><div class="dotgraph">
<img src="../../dot_inline_dotgraph_25.png" alt="dot_inline_dotgraph_25.png" border="0" usemap="#dot_inline_dotgraph_25.map"/>
<map name="dot_inline_dotgraph_25.map" id="dot_inline_dotgraph_25.map"></map>
</div>
<h2><a class="anchor" id="cqueueDLD-lspec-state"></a>
State Specification</h2>
<p>The circular queue can be in one of 3 states:</p><ul>
<li>empty: This is the initial state and the queue returns to this state whenever the count of consumable elements return to zero.</li>
<li>full: The queue contains elements and has no room for more. In this state, the producer should not attempt to put any more elements into the queue. Recall that the consumer "owns" the element that it just consumed, so the queue is full when the count of consumable elements is one less than the size of the queue. This state can be expressed as <div class="fragment"><div class="line"><a class="code" href="../../d6/d0c/ut_2xcode_8c.html#a5f7d24ded17bf1ab44fdadf38c54a8b5">count</a> == (total_number - 1) </div></div><!-- fragment --></li>
<li>partial: In this state, the queue contains elements to be consumed and still has room for additional element production. This can be expressed as <div class="fragment"><div class="line"><a class="code" href="../../d6/d0c/ut_2xcode_8c.html#a5f7d24ded17bf1ab44fdadf38c54a8b5">count</a> &gt; 0 &amp;&amp; <a class="code" href="../../d6/d0c/ut_2xcode_8c.html#a5f7d24ded17bf1ab44fdadf38c54a8b5">count</a> &lt; (total_number - 1) </div></div><!-- fragment --></li>
</ul>
<p>Recall that the <code>count</code> is stored as a <code><a class="el" href="../../d7/d9d/structm0__atomic64.html">m0_atomic64</a></code>, so it must be access using <code><a class="el" href="../../d3/de8/group__atomic.html#ga611f47b9f61896df7924843f8d7e95de">m0_atomic64_get()</a></code>, requiring the use of a temporary variable in the case of testing if the queue is in the partial state.</p>
<h2><a class="anchor" id="cqueueDLD-lspec-thread"></a>
Threading and Concurrency Model</h2>
<p>A single producer and consumer are supported. The variables <code>consumer</code> and <code>producer</code> represent the range of elements in the queue containing data. While the <code>producer</code> is a compound object, with a single producer, no locking is required to access it. The <code>producer</code> cannot safely be accessed by the consumer, since they can be in different address spaces, so an atomic <code>count</code> of consumable elements is used as a surrogate for comparing the <code>consumer</code> and <code>producer</code>. Multiple producers and/or consumers must synchronize externally.</p>
<p>The transport layer acts both as the consumer and the allocator, and both operations use and modify the <code>consumer</code> variable and related pointers. As such, calls to <a class="el" href="../../dd/d08/group__bevcqueue.html#ga590b6faabdb5da756b429cf13c4c0ec4">bev_cqueue_add()</a> and <a class="el" href="../../dd/d08/group__bevcqueue.html#ga77e31d64b61358e7d0d559a774ceb639">bev_cqueue_get()</a> must be synchronized. The transport layer holds the transfer machine m0_net_transfer_mc::ntm_mutex when it calls <a class="el" href="../../dd/d08/group__bevcqueue.html#ga590b6faabdb5da756b429cf13c4c0ec4">bev_cqueue_add()</a>. The transport layer will also hold this mutex when it calls <a class="el" href="../../dd/d08/group__bevcqueue.html#ga77e31d64b61358e7d0d559a774ceb639">bev_cqueue_get()</a>.</p>
<h2><a class="anchor" id="cqueueDLD-lspec-numa"></a>
NUMA optimizations</h2>
<p>None.</p>
<hr/>
 <h1><a class="anchor" id="cqueueDLD-conformance"></a>
Conformance</h1>
<ul>
<li><b>i.m0.lib.atomic.interoperable-kernel-user-support</b> The <a class="el" href="../../d1/d60/structnlx__core__bev__link.html">nlx_core_bev_link</a> data structure allows for tracking the pointers to the link in both address spaces. The atomic operations allow the FIFO to be produced and consumed simultaneously in both spaces without synchronization or context switches.</li>
<li><b>i.net.xprt.lnet.growable-event-queue</b> The implementation supports an event queue to which new elements can be added over time.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="cqueueDLD-ut"></a>
Unit Tests</h1>
<p>The following cases will be tested by unit tests:</p>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000086">Test:</a></b></dt><dd>Initializing a queue of minimum size 2</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000087">Test:</a></b></dt><dd>Successfully producing an element</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000088">Test:</a></b></dt><dd>Successfully consuming an element</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000089">Test:</a></b></dt><dd>Failing to consume an element because the queue is empty</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000090">Test:</a></b></dt><dd>Initializing a queue of larger size</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000091">Test:</a></b></dt><dd>Repeating the producing and consuming tests</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000092">Test:</a></b></dt><dd>Concurrently producing and consuming elements</dd></dl>
<hr/>
 <h1><a class="anchor" id="cqueueDLD-st"></a>
System Tests</h1>
<p>System testing will include tests where the producer and consumer are in separate address spaces.</p>
<hr/>
 <h1><a class="anchor" id="cqueueDLD-O"></a>
Analysis</h1>
<p>The circular queue (the struct <a class="el" href="../../db/d96/structnlx__core__bev__cqueue.html">nlx_core_bev_cqueue</a>) consumes fixed size memory, independent of the size of the elements contains the queue's data. The number of elements can grow over time, where the number of elements is proportional to the number of current and outstanding buffer operations. This number of elements will reach some maximum based on the peak activity in the application layer. Operations on the queue are O(1) complexity.</p>
<hr/>
 <h1><a class="anchor" id="cqueueDLD-ref"></a>
References</h1>
<ul>
<li>HLD of Motr LNet Transport : For documentation links, please refer to this file : doc/motr-design-doc-list.rst</li>
<li><a href="http://drdobbs.com/high-performance-computing/210604448">Writing Lock-Free Code: A Corrected Queue, Herb Sutter, in Dr Dobbs Journal, 2008</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d3/dd6/_d_l_d_i_x.html">Detailed Designs</a></li><li class="navelem"><a class="el" href="../../d6/de0/_l_net_d_l_d.html">LNet Transport DLD</a></li>
    <li class="footer">Generated on Thu Apr 14 2022 14:03:26 for Motr by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
