<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Motr: Auto-Provisioning of Receive Message Queue Buffers DLD</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Motr
   &#160;<span id="projectnumber">M0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d1/d77/_net_r_q_prov_d_l_d.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Auto-Provisioning of Receive Message Queue Buffers DLD </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="../../d1/d77/_net_r_q_prov_d_l_d.html#NetRQProvDLD-ovw">Overview</a></li>
<li><a class="el" href="../../d1/d77/_net_r_q_prov_d_l_d.html#NetRQProvDLD-def">Definitions</a></li>
<li>NetRQProvDLD-req</li>
<li><a class="el" href="../../d1/d77/_net_r_q_prov_d_l_d.html#NetRQProvDLD-depends">Dependencies</a></li>
<li><a class="el" href="../../d1/d77/_net_r_q_prov_d_l_d.html#NetRQProvDLD-highlights">Design Highlights</a></li>
<li><a class="el" href="../../d1/d77/_net_r_q_prov_d_l_d.html#NetRQProvDLD-fspec">Functional Specification</a></li>
<li><a class="el" href="../../d1/d77/_net_r_q_prov_d_l_d.html#NetRQProvDLD-lspec">Logical Specification</a><ul>
<li><a class="el" href="../../d1/d77/_net_r_q_prov_d_l_d.html#NetRQProvDLD-lspec-state">State Specification</a></li>
<li><a class="el" href="../../d1/d77/_net_r_q_prov_d_l_d.html#NetRQProvDLD-lspec-thread">Threading and Concurrency Model</a></li>
<li><a class="el" href="../../d1/d77/_net_r_q_prov_d_l_d.html#NetRQProvDLD-lspec-numa">NUMA optimizations</a></li>
</ul>
</li>
<li><a class="el" href="../../d1/d77/_net_r_q_prov_d_l_d.html#NetRQProvDLD-conformance">Conformance</a></li>
<li><a class="el" href="../../d1/d77/_net_r_q_prov_d_l_d.html#NetRQProvDLD-ut">Unit Tests</a></li>
<li><a class="el" href="../../d1/d77/_net_r_q_prov_d_l_d.html#NetRQProvDLD-st">System Tests</a></li>
<li><a class="el" href="../../d1/d77/_net_r_q_prov_d_l_d.html#NetRQProvDLD-O">Analysis</a></li>
<li><a class="el" href="../../d1/d77/_net_r_q_prov_d_l_d.html#NetRQProvDLD-ref">References</a></li>
</ul>
<hr/>
 <h1><a class="anchor" id="NetRQProvDLD-ovw"></a>
Overview</h1>
<p>This document describes the design of the auto-provisioning of network buffers to the receive message queue of a transfer machine feature.</p><ul>
<li>HLD of Motr LNet Transport : For documentation links, please refer to this file : doc/motr-design-doc-list.rst </li>
</ul>
<h1><a class="anchor" id="NetRQProvDLD-def"></a>
Definitions</h1>
<ul>
<li>HLD of Motr LNet Transport : For documentation links, please refer to this file : doc/motr-design-doc-list.rst</li>
</ul>
<p>, and <a class="el" href="../../d8/d01/group__net__buffer__pool.html">Network Buffer Pool</a>.</p>
<p>from HLD of Motr LNet Transport : For documentation links, please refer to this file : doc/motr-design-doc-list.rsti</p>
<hr/>
 <h1><a class="anchor" id="NetRQProvDLD-depends"></a>
Dependencies</h1>
<ul>
<li>Provisioning support primarily depends on the <a class="el" href="../../d8/d01/group__net__buffer__pool.html">Network Buffer Pool</a>. The <a class="el" href="../../d8/d01/group__net__buffer__pool.html#gac6bdd9900fc54c802b1e16d44cb6b64f">m0_net_buffer_pool_get()</a> subroutine must be modified to set the value of the <a class="el" href="../../d9/d7e/structm0__net__buffer.html#accd7a8e24513930e5c6f574f1ae478a3">m0_net_buffer::nb_pool</a> field.</li>
<li>Locality support during provisioning depends on the application assigning a color to each transfer machine. In user space Motr servers this is done by the <a class="el" href="../../df/dca/group__m0d.html">Motr Setup</a> module.</li>
<li>The act of provisioning is similar to invoking <a class="el" href="../../d9/dd2/group__net.html#gacce89dfe5af29f0c271b458408c6e57e">m0_net_buffer_add()</a> on the <a class="el" href="../../d9/dd2/group__net.html#gga4a25e727e622f7aaaedfe8ffa01fa005aa95a74f1b59dffb048013e381c4f6733">M0_NET_QT_MSG_RECV</a> queue of the transfer machine. Since the transfer machine mutex is usually held in most provisioning calls, an internal version of this subroutine which requires the mutex to be held should be made available if necessary.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="NetRQProvDLD-highlights"></a>
Design Highlights</h1>
<ul>
<li>Automatic provisioning takes place from a network buffer pool specified by the <a class="el" href="../../d9/dd2/group__net.html#ga711c501232bfbf09dcf4c9607e62b4c7">m0_net_tm_pool_attach()</a> subroutine.</li>
<li>Automatic provisioning takes place at the following times:<ul>
<li>When the transfer machine is started.</li>
<li>When a buffer is dequeued from the receive queue.</li>
<li>When an exhausted pool is replenished (requires application support)</li>
</ul>
</li>
<li>Locality support available if the transfer machine is assigned a color with the <a class="el" href="../../d9/dd2/group__net.html#ga914a2a40268980dd7cd53064123cbc8b">m0_net_tm_colour_set()</a> subroutine.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="NetRQProvDLD-fspec"></a>
Functional Specification</h1>
<p>The following new APIs are introduced: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span>      <a class="code" href="../../d9/dd2/group__net.html#ga711c501232bfbf09dcf4c9607e62b4c7">m0_net_tm_pool_attach</a>(<span class="keyword">struct</span> <a class="code" href="../../d4/d78/structm0__net__transfer__mc.html">m0_net_transfer_mc</a> *tm,</div><div class="line">                               <span class="keyword">struct</span> <a class="code" href="../../d4/d52/structm0__net__buffer__pool.html">m0_net_buffer_pool</a> *bufpool,</div><div class="line">                               <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="../../d8/d8d/structm0__net__buffer__callbacks.html">m0_net_buffer_callbacks</a> *callbacks,</div><div class="line">                               <a class="code" href="../../d9/d49/types_8h.html#a754ca36f0e1fff3edef4f267024b1a1f">m0_bcount_t</a> min_recv_size,</div><div class="line">                               uint32_t <a class="code" href="../../d3/d8c/tm__provision__ut_8c.html#ac63de6d964805afb602209467a716bbb">max_recv_msgs</a>);</div><div class="line"><span class="keywordtype">int</span>      <a class="code" href="../../d9/dd2/group__net.html#gac077a492d8ac995912594898504f03fa">m0_net_tm_pool_length_set</a>(<span class="keyword">struct</span> <a class="code" href="../../d4/d78/structm0__net__transfer__mc.html">m0_net_transfer_mc</a> *tm, uint32_t len);</div><div class="line"><span class="keywordtype">void</span>     <a class="code" href="../../d9/dd2/group__net.html#ga56521d311aec804ccae66e4594719282">m0_net_domain_buffer_pool_not_empty</a>(<span class="keyword">struct</span> <a class="code" href="../../d4/d52/structm0__net__buffer__pool.html">m0_net_buffer_pool</a> *<a class="code" href="../../d0/df1/iter__ut_8c.html#a8b1bf9675fb77ab02a105e260477a59b">pool</a>);</div><div class="line"><span class="keywordtype">void</span>     <a class="code" href="../../d9/dd2/group__net.html#ga914a2a40268980dd7cd53064123cbc8b">m0_net_tm_colour_set</a>(<span class="keyword">struct</span> <a class="code" href="../../d4/d78/structm0__net__transfer__mc.html">m0_net_transfer_mc</a> *tm, uint32_t colour);</div><div class="line">uint32_t <a class="code" href="../../d9/dd2/group__net.html#ga43df1796517e1a3bb4dd2765d8dae2dc">m0_net_tm_colour_get</a>(<span class="keyword">struct</span> <a class="code" href="../../d4/d78/structm0__net__transfer__mc.html">m0_net_transfer_mc</a> *tm);</div></div><!-- fragment --><p>The transfer machine data structure is extended as follows: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="../../d4/d78/structm0__net__transfer__mc.html">m0_net_transfer_mc</a> {</div><div class="line">      ...</div><div class="line">      <span class="keyword">struct </span><a class="code" href="../../d4/d52/structm0__net__buffer__pool.html">m0_net_buffer_pool</a>            *<a class="code" href="../../d4/d78/structm0__net__transfer__mc.html#ac16e5b955b5bfa853933e1784b57cac3">ntm_recv_pool</a>;</div><div class="line">      <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="../../d8/d8d/structm0__net__buffer__callbacks.html">m0_net_buffer_callbacks</a> *<a class="code" href="../../d4/d78/structm0__net__transfer__mc.html#a07289bb65658f1f03ccaf51dd75f76ba">ntm_recv_pool_callbacks</a>;</div><div class="line">      uint32_t                              <a class="code" href="../../d4/d78/structm0__net__transfer__mc.html#af312bf36794a76e78faa89d119384a29">ntm_recv_queue_min_length</a>;</div><div class="line">      <span class="keyword">struct </span><a class="code" href="../../d7/d9d/structm0__atomic64.html">m0_atomic64</a>                    <a class="code" href="../../d4/d78/structm0__net__transfer__mc.html#aa0b26826c28f6d909c882e90c52e6bf5">ntm_recv_queue_deficit</a>;</div><div class="line">      uint32_t                              <a class="code" href="../../d4/d78/structm0__net__transfer__mc.html#abe37488ce6fba5fdd3aaa0af927c6cbd">ntm_pool_colour</a>;</div><div class="line">};</div></div><!-- fragment --><p>The network buffer data structure is extended as follows: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="../../d9/d7e/structm0__net__buffer.html">m0_net_buffer</a> {</div><div class="line">      ...</div><div class="line">      <span class="keyword">struct </span><a class="code" href="../../d4/d52/structm0__net__buffer__pool.html">m0_net_buffer_pool</a>            *<a class="code" href="../../d9/d7e/structm0__net__buffer.html#accd7a8e24513930e5c6f574f1ae478a3">nb_pool</a>;</div><div class="line">};</div></div><!-- fragment --><p>The following enumeration is defined: </p><div class="fragment"><div class="line"><span class="keyword">enum</span> {</div><div class="line">     <a class="code" href="../../d9/dd2/group__net.html#gga4ba3e3f719af1e66760185a8a0115342a09d7b269b4625dae8854e2e0a7522dd4">M0_NET_TM_RECV_QUEUE_DEF_LEN</a> = 2</div><div class="line">};</div></div><!-- fragment --><hr/>
 <h1><a class="anchor" id="NetRQProvDLD-lspec"></a>
Logical Specification</h1>
<h2><a class="anchor" id="NetRQProvDLD-lspec-enable"></a>
Enabling Automatic Provisioning</h2>
<p>Automatic provisioning of network buffers to the receive queue takes place only when a buffer pool is "attached" to a transfer machine using the <a class="el" href="../../d9/dd2/group__net.html#ga711c501232bfbf09dcf4c9607e62b4c7">m0_net_tm_pool_attach()</a> subroutine. The subroutine can only be called prior to starting the transfer machine.</p>
<p>The subroutine validates that the specified pool is in the same network domain. It then saves the pool pointer in the <a class="el" href="../../d4/d78/structm0__net__transfer__mc.html#ac16e5b955b5bfa853933e1784b57cac3">m0_net_transfer_mc::ntm_recv_pool</a> field, and the callback pointer in the <a class="el" href="../../d4/d78/structm0__net__transfer__mc.html#a07289bb65658f1f03ccaf51dd75f76ba">m0_net_transfer_mc::ntm_recv_pool_callbacks</a> field.</p>
<h2><a class="anchor" id="NetRQProvDLD-lspec-initial"></a>
Initial Provisioning</h2>
<p>The first attempt to provision the transfer machine is on start up, just after the transfer machine state change event is delivered. This ensures that there is no race condition between the state change event and the buffer completion callback notifying receipt first incoming unsolicited message.</p>
<p>The receive message queue is provisioned with <a class="el" href="../../d9/dd2/group__net.html#gga4ba3e3f719af1e66760185a8a0115342a09d7b269b4625dae8854e2e0a7522dd4">M0_NET_TM_RECV_QUEUE_DEF_LEN</a> (nominally 2) network buffers if possible.</p>
<h2><a class="anchor" id="NetRQProvDLD-lspec-normal"></a>
Normal Provisioning</h2>
<p>Whenever a network buffer is dequeued from the receive message queue, an attempt to re-provision the queue is made prior to delivering the buffer completion event. This ensures that the queue is replenished as soon as possible. Note that not every receive message queue buffer completion event will trigger re-provisioning if multiple message delivery is enabled in the buffer.</p>
<p>When re-provisioning, as many buffers are fetched from the pool as needed to bring its length to the minimum desired value. Changing the minimum receive queue length with the <a class="el" href="../../d9/dd2/group__net.html#gac077a492d8ac995912594898504f03fa">m0_net_tm_pool_length_set()</a> subroutine always triggers an attempt to re-provision. No attempt is ever made, however, to return buffers to the pool if the length of the queue is greater than the minimum.</p>
<p>New network buffers are obtained by invoking the <a class="el" href="../../d8/d01/group__net__buffer__pool.html#gac6bdd9900fc54c802b1e16d44cb6b64f">m0_net_buffer_pool_get()</a> subroutine. The buffer obtained from this subroutine is expected to have its <a class="el" href="../../d9/d7e/structm0__net__buffer.html#accd7a8e24513930e5c6f574f1ae478a3">m0_net_buffer::nb_pool</a> variable set to the pool pointer, to enable the application to easily return it to the pool it came from, without having to explicitly track the pool. This requires a modification to the <a class="el" href="../../d8/d01/group__net__buffer__pool.html#gac6bdd9900fc54c802b1e16d44cb6b64f">m0_net_buffer_pool_get()</a> subroutine.</p>
<p>Actual provisioning is done by invoking <a class="el" href="../../d9/dd2/group__net.html#gacce89dfe5af29f0c271b458408c6e57e">m0_net_buffer_add()</a> or its internal equivalent, depending on the locking model used.</p>
<p>It is possible that the buffer pool gets exhausted and re-provisioning fails, partially or entirely. In such cases, the transfer machine maintains a count of the number of additional buffers it requires in the <a class="el" href="../../d4/d78/structm0__net__transfer__mc.html#aa0b26826c28f6d909c882e90c52e6bf5">m0_net_transfer_mc::ntm_recv_queue_deficit</a> <b>atomic</b> variable. This is to facilitate later re-provisioning without unnecessary locking and loss of locality.</p>
<h2><a class="anchor" id="NetRQProvDLD-lspec-abnormal"></a>
Provisioning After Pool Exhaustion</h2>
<p>Re-provisioning a transfer machine after pool exhaustion requires a triggering event:</p><ul>
<li>Another receive queue buffer gets de-queued.</li>
<li>The application changes the minimum receive queue length with the <a class="el" href="../../d9/dd2/group__net.html#gac077a492d8ac995912594898504f03fa">m0_net_tm_pool_length_set()</a> subroutine.</li>
<li>The application invokes the <a class="el" href="../../d9/dd2/group__net.html#ga56521d311aec804ccae66e4594719282">m0_net_domain_buffer_pool_not_empty()</a> subroutine from the pool's  not-empty callback.</li>
</ul>
<p>The first two cases result in the same behavior as normal provisioning.</p>
<p>The <a class="el" href="../../d9/dd2/group__net.html#ga56521d311aec804ccae66e4594719282">m0_net_domain_buffer_pool_not_empty()</a> subroutine initiates the replenishment of  all depleted transfer machines in the network domain that are provisioned from the specified buffer pool. The order in which each transfer machine gets processed is arbitrary, but this poses no particular problem because such a situation is assumed to be very rare and the system is already in deep trouble were it to happen.</p>
<p>The following pseudo-code illustrates the subroutine algorithm: </p><div class="fragment"><div class="line"><a class="code" href="../../d9/dd2/group__net.html#ga56521d311aec804ccae66e4594719282">m0_net_domain_buffer_pool_not_empty</a>(<a class="code" href="../../d0/df1/iter__ut_8c.html#a8b1bf9675fb77ab02a105e260477a59b">pool</a>) {</div><div class="line">   <a class="code" href="../../dc/da7/assert_8h.html#ac8bebb1ebb72c1dae891a1a1c24e7aec">M0_ASSERT</a>(<a class="code" href="../../d8/d01/group__net__buffer__pool.html#ga5891449a008a0d2a5fcad686b2f2e63e">m0_net_buffer_pool_is_locked</a>(<a class="code" href="../../d0/df1/iter__ut_8c.html#a8b1bf9675fb77ab02a105e260477a59b">pool</a>));</div><div class="line">   <a class="code" href="../../dc/d74/addb2_2ut_2storage_8c.html#a6b9f7e6115c241d0a8ea3087490f1043">dom</a> = <a class="code" href="../../d0/df1/iter__ut_8c.html#a8b1bf9675fb77ab02a105e260477a59b">pool</a>-&gt;nbp_ndom;</div><div class="line">   <a class="code" href="../../d0/d04/group__mutex.html#gae26efdb3a765f750c5992041d6ee2336">m0_mutex_lock</a>(&amp;<a class="code" href="../../dc/d74/addb2_2ut_2storage_8c.html#a6b9f7e6115c241d0a8ea3087490f1043">dom</a>-&gt;nd_mutex);</div><div class="line">   <span class="keywordflow">foreach</span> tm in <a class="code" href="../../dc/d74/addb2_2ut_2storage_8c.html#a6b9f7e6115c241d0a8ea3087490f1043">dom</a>-&gt;nd_tms <a class="code" href="../../dd/d94/lib_2ut_2list_8c.html#a510d1f3465504f3f259cf505d0e14d98">list</a> {</div><div class="line">       <span class="keywordflow">if</span> (<a class="code" href="../../d3/de8/group__atomic.html#ga611f47b9f61896df7924843f8d7e95de">m0_atomic64_get</a>(&amp;tm-&gt;ntm_recv_queue_deficit) == 0)</div><div class="line">          <span class="keywordflow">continue</span>; <span class="comment">// skip if no deficit</span></div><div class="line">       <a class="code" href="../../d0/d04/group__mutex.html#gae26efdb3a765f750c5992041d6ee2336">m0_mutex_lock</a>(&amp;tm-&gt;ntm_mutex);</div><div class="line">       <span class="keywordflow">if</span> (tm-&gt;ntm_state == <a class="code" href="../../d9/dd2/group__net.html#ggaaa9dbf6c20e7f07dfe6fc3746f6183e2abbe89cdedac94d27fe1eeb53c4a82ffe">M0_NET_TM_STARTED</a> &amp;&amp; tm-&gt;ntm_recv_pool == <a class="code" href="../../d0/df1/iter__ut_8c.html#a8b1bf9675fb77ab02a105e260477a59b">pool</a> &amp;&amp;</div><div class="line">           <a class="code" href="../../d3/de8/group__atomic.html#ga611f47b9f61896df7924843f8d7e95de">m0_atomic64_get</a>(&amp;tm-&gt;ntm_recv_queue_deficit) &gt; 0) {</div><div class="line">           <span class="comment">// attempt to provision the TM</span></div><div class="line">       }</div><div class="line">       <a class="code" href="../../d0/d04/group__mutex.html#ga18963570792098f5ab3cf3e8ede8046a">m0_mutex_unlock</a>(&amp;tm-&gt;ntm_mutex);</div><div class="line">   }</div><div class="line">   <a class="code" href="../../d0/d04/group__mutex.html#ga18963570792098f5ab3cf3e8ede8046a">m0_mutex_unlock</a>(&amp;<a class="code" href="../../dc/d74/addb2_2ut_2storage_8c.html#a6b9f7e6115c241d0a8ea3087490f1043">dom</a>-&gt;nd_mutex);</div><div class="line">}</div></div><!-- fragment --><p> Note the following:</p><ul>
<li>The pool is assumed to be locked when the subroutine is invoked.</li>
<li>The domain lock is held while the list of transfer machines is traversed.</li>
<li>Provisioning is attempted only if the transfer machine is in a depleted condition. This check is made with an atomic variable without the need to obtain the transfer machine mutex. This reduces the amount of locking required, and preserves the spatial locality of transfer machine locks as long as possible. In particular, it does not interfere with transfer machines that do not need provisioning.</li>
<li>The transfer machine lock is required to determine the transfer machine state, associated pool and re-affirm the need for additional network buffers.</li>
</ul>
<p>Note that the network layer has no control over the pool operations, so it is up to the application to supply a  not-empty pool callback subroutine and make the call to the <a class="el" href="../../d9/dd2/group__net.html#ga56521d311aec804ccae66e4594719282">m0_net_domain_buffer_pool_not_empty()</a> subroutine from there.</p>
<h2><a class="anchor" id="NetRQProvDLD-lspec-state"></a>
State Specification</h2>
<p>Automatic provisioning only takes place in an active transfer machine (state is <a class="el" href="../../d9/dd2/group__net.html#ggaaa9dbf6c20e7f07dfe6fc3746f6183e2abbe89cdedac94d27fe1eeb53c4a82ffe">M0_NET_TM_STARTED</a>).</p>
<p>Automatic provisioning of a transfer machine exists in two (informal) states:</p><ul>
<li><b>Provisioned</b> </li>
<li><b>Depleted</b> </li>
</ul>
<p>In the <b>Provisioned</b> state there are sufficient network buffers enqueued on the receive message queue. The algorithms do not care whether these buffers were obtained from the buffer pool or not, just that the count is right.</p>
<p>When there are insufficient network buffers in the receive message queue, the provisioning state is said to be <b>Depleted</b>. The provisioning algorithms work to change the state back to <b>Provisioned</b> by obtaining additional buffers from the buffer pool. It is expected that this usually gets done before the application can sense the transition out of the <b>Provisioned</b> state (prior to the buffer completion event callback), but there is a possibility that the pool gets exhausted before this is accomplished.</p>
<p>A non-zero value in <a class="el" href="../../d4/d78/structm0__net__transfer__mc.html#aa0b26826c28f6d909c882e90c52e6bf5">m0_net_transfer_mc::ntm_recv_queue_deficit</a> indicates that automatic provisioning is in the <b>Depleted</b> state. Otherwise, it is in the <b>Provisioned</b> state.</p>
<p>Every time the minimum required network buffer count is modified it is possible that the transfer machine's automatic provisioning state transitions to <b>Depleted</b>, so an attempt is made to re-provision to restore the state.</p>
<h2><a class="anchor" id="NetRQProvDLD-lspec-thread"></a>
Threading and Concurrency Model</h2>
<p>There are more reentrancy issues involved with automatic provisioning than concurrency issues, which in some sense is more complicated.</p>
<p>Applications return receive message buffers to the buffer pool on their own accord, possibly, but not always, in the buffer completion callback itself. The transfer machine lock is <b>not</b> held by the application at this time; instead, the application has to obtain the pool lock to return the buffer. It is possible that this operation triggers a domain wide re-provisioning if the pool was exhausted. The re-provisioning operation, as explained above, will obtain the domain lock and internal transfer machine locks, but assumes that the buffer pool lock is held.</p>
<p>Normal provisioning usually takes place in the context of normal transfer machine operations, protected by the transfer machine mutex. The provisioning steps necessarily require that the pool lock be obtained which clearly is exactly in the opposite order of the application triggered re-provisioning, hence <b>can result in a deadlock</b>. Since application behavior cannot be dictated, normal provisioning must be made to use the same locking order as the re-provisioning case. This requires that the transfer machine lock be released, the pool lock obtained, and then the transfer machine lock re-obtained.</p>
<p>This is not a new situation; the transfer machine is already handling cases where it has to temporarily give up and re-obtain its own mutex. To avoid getting destroyed while operating out of its mutex, the transfer machine uses the <a class="el" href="../../d4/d78/structm0__net__transfer__mc.html#ac25a898a8ec2a7d4876cdd9ee7e5a19d">m0_net_transfer_mc::ntm_callback_counter</a> to indicate that it is operating in such a mode. When it re-obtains the mutex and decrements the counter, it signals on the <a class="el" href="../../d4/d78/structm0__net__transfer__mc.html#a2754c804d4265d5dd78c6ea474b2becb">m0_net_transfer_mc::ntm_chan</a> channel. This is illustrated in the following pseudo-code: </p><div class="fragment"><div class="line">...</div><div class="line">M0_PRE(m0_in_mutex(&amp;tm-&gt;ntm_mutex);</div><div class="line"><a class="code" href="../../dc/da7/assert_8h.html#a1c063bd08f7e1ab3a6e6008ef825d471">M0_PRE</a>(tm-&gt;ntm_recv_pool != <a class="code" href="../../db/df8/lib_2user__space_2misc_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);</div><div class="line">++tm-&gt;ntm_callback_counter;</div><div class="line"><a class="code" href="../../d0/d04/group__mutex.html#ga18963570792098f5ab3cf3e8ede8046a">m0_mutex_unlock</a>(&amp;tm-&gt;ntm_mutex);</div><div class="line"></div><div class="line"><a class="code" href="../../d8/d01/group__net__buffer__pool.html#ga3108150c6181b9767449f3b2eb0c0f7c">m0_net_buffer_pool_lock</a>(tm-&gt;ntm_recv_pool);</div><div class="line"><a class="code" href="../../d0/d04/group__mutex.html#gae26efdb3a765f750c5992041d6ee2336">m0_mutex_lock</a>(&amp;tm-&gt;ntm_mutex);</div><div class="line"><a class="code" href="../../db/dcd/m0t1fs_2linux__kernel_2dir_8c.html#a1c039c828314ce748de2792692443d41">if</a> (tm-&gt;ntm_state == <a class="code" href="../../d9/dd2/group__net.html#ggaaa9dbf6c20e7f07dfe6fc3746f6183e2abbe89cdedac94d27fe1eeb53c4a82ffe">M0_NET_TM_STARTED</a> &amp;&amp; ...) {</div><div class="line">           <span class="comment">// provision if needed</span></div><div class="line">}</div><div class="line"><a class="code" href="../../d0/d04/group__mutex.html#ga18963570792098f5ab3cf3e8ede8046a">m0_mutex_unlock</a>(&amp;tm-&gt;ntm_mutex);</div><div class="line"><a class="code" href="../../d8/d01/group__net__buffer__pool.html#ga98cfb317097d1024cca11a4c5af51b9c">m0_net_buffer_pool_unlock</a>(tm-&gt;ntm_recv_pool)</div><div class="line"></div><div class="line"><a class="code" href="../../d0/d04/group__mutex.html#gae26efdb3a765f750c5992041d6ee2336">m0_mutex_lock</a>(&amp;tm-&gt;ntm_mutex);</div><div class="line">--tm-&gt;ntm_callback_counter;</div><div class="line">...</div></div><!-- fragment --><p>The callback counter logic is already used currently to synchronize buffer completion events with the concurrent finalization of the transfer machine. The new addition is to obtain the pool and transfer machine locks if provisioning is needed; this can be done on a demand basis only for the most frequent re-provisioning case, so the overhead can be held to a minimum.</p>
<p>Transfer machine finalization must be slightly tweaked to continue waiting on the counter and channel as long as the transfer machine state is active.</p>
<h2><a class="anchor" id="NetRQProvDLD-lspec-numa"></a>
NUMA optimizations</h2>
<p>The <a class="el" href="../../d8/d01/group__net__buffer__pool.html">Network Buffer Pool</a> module provides support for "colored" operations to maximize the locality of reference between a network buffer and a transfer machine. All <a class="el" href="../../d8/d01/group__net__buffer__pool.html#gac6bdd9900fc54c802b1e16d44cb6b64f">m0_net_buffer_pool_get()</a> calls will use the <a class="el" href="../../d4/d78/structm0__net__transfer__mc.html#abe37488ce6fba5fdd3aaa0af927c6cbd">m0_net_transfer_mc::ntm_pool_colour</a> field value as the color. This value is initialized to <code>::M0_BUFFER_ANY_COLOR</code>, and it is up to the higher level application to assign a color to the transfer machine with the <a class="el" href="../../d9/dd2/group__net.html#ga914a2a40268980dd7cd53064123cbc8b">m0_net_tm_colour_set()</a> subroutine. The higher level application is also responsible for creating the buffer pool with sufficient colors in the first place.</p>
<p>Special care is taken during domain wide re-provisioning after the buffer pool recovers from an exhausted state, to not lose the locality of reference of the various transfer machine locks with respect to their CPUs. An atomic variable is used to track if a transfer machine needs re-provisioning, and only if this is the case is the lock obtained.</p>
<hr/>
 <h1><a class="anchor" id="NetRQProvDLD-conformance"></a>
Conformance</h1>
<ul>
<li><b>i.m0.net.xprt.support-for-auto-provisioned-receive-queue</b> The design provides a means to automatically provision network buffers to the receive queues of transfer machines, using a domain wide buffer pool that offers the potential of sharing network buffers across multiple transfer machines, yet in a manner that maximizes the spatial locality of each buffer with the transfer machine that last used it.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="NetRQProvDLD-ut"></a>
Unit Tests</h1>
<p>All tests are done with a fake transport and a real buffer pool.</p><ul>
<li>Test that the API calls are properly made.</li>
<li>Test initial provisioning of a transfer machine.</li>
<li>Test normal provisioning after buffer completion.</li>
<li>Test that the atomic counter is properly incremented if the buffer pool is exhausted.</li>
<li>Test that provisioned buffer callbacks match those specified during pool attach.</li>
<li>Test that provisioned buffers identify the buffer pool in the <a class="el" href="../../d9/d7e/structm0__net__buffer.html#accd7a8e24513930e5c6f574f1ae478a3">m0_net_buffer::nb_pool</a> field.</li>
<li>Test provisioning with multiple transfer machines, including domain wide re-provisioning when the pool is replenished.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="NetRQProvDLD-st"></a>
System Tests</h1>
<p>No system testing is planned, though the multiple transfer machine unit tests have some system testing flavor.</p>
<hr/>
 <h1><a class="anchor" id="NetRQProvDLD-O"></a>
Analysis</h1>
<ul>
<li>The buffer pool <a class="el" href="../../d8/d01/group__net__buffer__pool.html#gac6bdd9900fc54c802b1e16d44cb6b64f">m0_net_buffer_pool_get()</a> subroutine call is used to search for appropriate buffers and represents a potentially non-constant time algorithm.</li>
<li>Counting the minimum number of receive buffers using the list length counting subroutine is proportional to the number of elements in the list. Since the algorithm is intended to keep the number of elements in the list to the minimum value, the cost is proportional to the minimum list length in the average case.</li>
<li>The locking model requires that the the transfer machine lock be released and re-acquired in the average case. While this cannot be avoided, the impact can be minimized by re-obtaining the lock only when provisioning is known to be required.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="NetRQProvDLD-ref"></a>
References</h1>
<p>For documentation links, please refer to this file : doc/motr-design-doc-list.rst</p><ul>
<li>HLD of Motr LNet Transport</li>
<li>RPC Bulk Transfer Task Plan</li>
<li><a class="el" href="../../d8/d01/group__net__buffer__pool.html">Network Buffer Pool</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d3/dd6/_d_l_d_i_x.html">Detailed Designs</a></li>
    <li class="footer">Generated on Thu Apr 14 2022 14:03:27 for Motr by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
