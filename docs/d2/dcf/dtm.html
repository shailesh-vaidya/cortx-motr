<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Motr: Distributed transaction manager</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Motr
   &#160;<span id="projectnumber">M0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d2/dcf/dtm.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Distributed transaction manager </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Overview"></a>
Overview</h1>
<p>Distributed transaction manager (DTM) is a major Motr component, responsible for dealing with certain types of transient failures.</p>
<p>Specifically, DTM maintains, as far as possible, consistency of system state in the face of transient network failures (message reordering and duplication) and transient node failures (node failure followed by restart).</p>
<p>Consistency is maintained by grouping state updates, represented by fops (<a class="el" href="../../d5/d01/structm0__fop.html">m0_fop</a>), in collections called "distributed transactions". DTM guarantees that transactions are atomic, in the sense that either all or none of the fops are executed, even should a failure happen in the middle of transaction execution.</p>
<p>Atomicity is achieved by redoing or undoing some fops after a failure. This is done transparently by DTM, relieving its users from the burden of failure handling.</p>
<p>Because different transactions can update the same entities, undo and redo of one transaction might require undo or redo of other dependent transactions. To fulfil this requirement, DTM tracks transaction dependencies.</p>
<p>It might so happen, that too much state was lost in a failure and consistency can not be restored. In this case, DTM determines the subset of system history that is no longer consistent and notifies HA that affected nodes should be anathematised.</p>
<h1><a class="anchor" id="hld"></a>
High level design</h1>
<p>HLD : For documentation links, please refer to this file : doc/motr-design-doc-list.rst</p>
<h1><a class="anchor" id="Abstractions"></a>
Abstractions</h1>
<p>DTM introduces the following major abstractions: </p><pre class="fragment">- dtm instance (m0_dtm, dtm/dtm.c, dtm/dtm.h),
- history (m0_dtm_history, dtm/history.c, dtm/history.h),
- update (m0_dtm_update, dtm/update.c, dtm/update.h),
- operation (m0_dtm_operation, dtm/operation.c, dtm/operation.h),
- distributed transaction (m0_dtm_dtx, dtm/dtx.c, dtm/dtx.h),
- domain (m0_dtm_domain, dtm/domain.c, dtm/domain.h).
</pre><p>See the HLD for more details.</p>
<h1><a class="anchor" id="Nucleus"></a>
Nucleus</h1>
<p>Nucleus is a sub-module within DTM, which contains core versioning and ordering logic for histories, operations and updates. Nucleus introduces its own types: </p><pre class="fragment">- nucleus m0_dtm_nu,
- nucleus operation m0_dtm_op,
- nucleus history m0_dtm_hi and
- nucleus update m0_dtm_up
</pre><p>Nuclear types are embedded in the appropriate DTM types. The rest of DTM hides nucleus types and functions from DTM users.</p>
<p>See dtm/nucleus.c, <a class="el" href="../../d0/d06/nucleus_8h.html">dtm/nucleus.h</a>.</p>
<h1><a class="anchor" id="coding-conventions"></a>
Coding conventions</h1>
<p>Throughout the code, names of nuclear types, functions and variables use 2 letter abbreviations:  nu (nucleus),  hi (history),  op (operation),  up (update).</p>
<p>In the rest of DTM, longer names "history", "oper" and "update" are used. "rem" is used as an abbreviation for "remote dtm instance" (<a class="el" href="../../dc/d0c/structm0__dtm__remote.html">m0_dtm_remote</a>).</p>
<p><a class="el" href="../../db/d48/dtm__internal_8h.html">dtm_internal.h</a> contains definitions and declarations that are used internally by the DTM code.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000075">Todo:</a></b></dt><dd>Internal declarations leak in the global name-space. This should be fixed by making them static and including dtm .c files in a single dtm/dtm.c file.</dd></dl>
<h1><a class="anchor" id="usage"></a>
Outline of DTM usage patterns</h1>
<p>A typical interaction with DTM consists of the following steps: </p><pre class="fragment">- create a transaction (m0_dtm_dtx_init());

- create an operation (m0_dtm_oper_init());

- for each entity, modified by the operation, locate the history
  (m0_dtm_history), representing the entity;

- create an update and add it to the history and the operation
  (m0_dtm_update_init());

- when all updates are added to the operation, add the operation to the
  transaction (m0_dtm_dtx_add());

- create a fop, representing the update and associate it with the update;

- close the operation (m0_dtm_oper_close());

- repeat for other operations in the transaction;

- close the transaction (m0_dtm_dtx_close());
</pre><dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000076">Todo:</a></b></dt><dd>pack, unpack, fop.</dd></dl>
<h1><a class="anchor" id="TOO"></a>
Theory of operation</h1>
<p>First, read the HLD.</p>
<p>A history (<a class="el" href="../../d0/d91/structm0__dtm__history.html">m0_dtm_history</a>) is a piece of system state to which updates are applied sequentially. Some histories correspond to user-visible entities, such as files, keys in meta-data tables, pages with file data; other histories correspond to internal DTM entities, used to express grouping and ordering of state updates. Examples of such internal histories are: fol (<a class="el" href="../../d9/dae/structm0__dtm__fol.html">m0_dtm_fol</a>), distributed transaction (<a class="el" href="../../d8/dd4/structm0__dtm__dtx.html">m0_dtm_dtx</a>), local transaction (<a class="el" href="../../d7/db0/structm0__dtm__ltx.html">m0_dtm_ltx</a>), epoch, domain (<a class="el" href="../../d3/d79/structm0__dtm__domain.html">m0_dtm_domain</a>).</p>
<p>An update to a history is <a class="el" href="../../d4/d50/structm0__dtm__update.html">m0_dtm_update</a>. The list of updates is hanging off of a history (m0_dtm_history::h_hi::hi_ups), the latest update at the head. An update is linked in its history list through m0_dtm_update::upd_up::up_hi_linkage.</p>
<p>Updates are grouped in operations (<a class="el" href="../../d0/d2d/structm0__dtm__oper.html">m0_dtm_oper</a>). Updates of an operation hang off of m0_dtm_oper::oprt_op::op_ups, linked through m0_dtm_update::upd_up::up_op_linkage.</p>
<p>Thus, updates, histories and operations form a certain gridiron pattern: <a class="anchor" id="gridiron"></a></p><pre class="fragment">*
*        H0        H1        H2        H3        H4        H5        H6  NOW
*        |         |         |         |         |         |         |    |
*        |   O0----U---------U         |         |         |         |    |
*        |         |         |         |         |         |         |    |
*        |         |   O1----U---------U---------U---------U---------U    |
*        |         |         |         |         |         |         |    |
*        |         |         |         |   O2----U         |         |    |
*        |         |         |         |         |         |         |    |
*  O3----U---------U---------U---------U---------U---------U---------U    |
*        |         |         |         |         |         |         |    |
*  O4----U---------U         |   O5----U---------U---------U---------U    |
*        |         |         |         |         |         |         |    |
*        |   O6----U---------U---------U         |         |         |    V
*        |         |         |         |         |         |         |   PAST
*
* </pre><p>Note that operation groups updates for logical purposes, it doesn't imply any kind of atomicity (more on operations below).</p>
<p>Each update has 2 version numbers: m0_dtm_update::upd_up::up_ver and m0_dtm_update::upd_up::up_orig_ver.</p>
<p>Version number specifies a position in history. Version numbers are used to order updates and to determine when an update is applicable. m0_dtm_update::upd_up::up_orig_ver specifies the version the history has before the update was applied and m0_dtm_update::upd_up::up_ver specifies the version the history has after the update is applied. These 2 version numbers can coincide, when update doesn't change the entity, represented by the history.</p>
<p>Version 0 is "unknown version", see below. Version 1 is the version of the history before the first (earliest) update in the history has been executed.</p>
<p>The following 3 complementary sub-sections describe organization of DTM structures from the point of view of update, history and operation respectively.</p>
<h1><a class="anchor" id="Update"></a>
Update</h1>
<p>Each update has a state: m0_dtm_update::upd_up::up_state.</p>
<p>When going through updates of a history pastward (that is, starting from the head of the history update list, downward in the diagram above), version numbers are non-increasing and states are non-decreasing.</p>
<p>Update state determines the execution status of the update. Update state increases throughout update life. Hence, update states describe update's life stages. Updates states are the following (m0_dtm_state): </p><pre class="fragment">- LIMBO: a new update is initialised by m0_dtm_update_init(). From the
  very beginning the update is associated with an operation and a
  history. m0_dtm_update_init() places the update on the operation's list
  updates, but not on the history's list of updates. The update starts in
  LIMBO state and remains in this stats until the operation, to which the
  update belongs is closed. In other words, LIMBO is the state of updates
  belonging to still not closed operations. LIMBO is the only state, in
  which the update is not on its history update list. When an operation
  is closed, m0_dtm_op_close() places all its updates on the
  corresponding history lists.

- FUTURE: this is the state of updates from closed operations that are
   not yet executed. Operation can be in FUTURE state for several reasons:
      - it is too early, and some previous operations, as determined by
        version numbers, are not yet added. This is possible when network
        reorders operations arriving to a server;
      - histories of some of operation's updates are busy (see PREPARE
        state below);

- PREPARE: when all updates of an operation are ready (versionwise) to be
  executed, they are moved from FUTURE to PREPARE state and
  m0_dtm_op_ops::doo_ready() call-back is called by the DTM. For a given
  history, at most one update of the history can be in PREPARE
  state. When an update is moved in PREPARE state, its history is marked
  busy (M0_DHF_BUSY) preventing other otherwise ready updates of this
  history to advance past FUTURE state. The purpose of PREPARE state is
  to allow DTM user to serialise operation execution as necessary, e.g.,
  take locks. When all the locks necessary for the operation execution
  are taken, the user calls m0_dtm_op_prepared(), which moves all
  operation updates in INPROGRESS state.

- INPROGRESS: an update in INPROGRESS state is being executed. When an
  update transitions from PREPARED to INPROGRESS state, history's version
  (m0_dtm_hi::hi_ver) is set to update's version, implying that as far as
  DTM is concerned, the state of the entity represented by the history
  contains the update. Because update execution is never truly
  instantaneous, the actual entity state is changed gradually, while the
  update is in INPROGRESS state, but thanks to the locks taken by the
  user in PREPARE state, this doesn't matter.

- VOLATILE: an update moves to VOLATILE state when its execution
  completes and modified entity state is present only in volatile store
  and can be lost in an allowed failure.

- PERSISTENT: an update moves to PERSISTENT state, when modified entity
  state makes it to persistent store, which is guaranteed to survive any
  allowed failure.

- STABLE: finally, an update moves to STABLE state, when DTM guarantees
  that it will survive any further allowed failure. STABLE state is
  different from PERSISTENT, because even if a particular update U is
  persistent, some earlier updates on which U depends can be not yet
  persistent. If such earlier updates are lost in a failure, DTM must
  undo U to preserve consistency.
</pre><h1><a class="anchor" id="History"></a>
History</h1>
<p>History represents evolution of a storage entity. Storage entity changes as result of update executions. Version number unambiguously identifies a point in the history.</p>
<p>History lists both already executed updates and still not executed updates. <a class="el" href="../../df/d76/structm0__dtm__hi.html#a38596b58a5c3a125092d68d7a609d1e0">m0_dtm_hi::hi_ver</a> identifies the point in history corresponding to the current state of the entity. All updates with version numbers less than <a class="el" href="../../df/d76/structm0__dtm__hi.html#a38596b58a5c3a125092d68d7a609d1e0">m0_dtm_hi::hi_ver</a> have been executed and none of the updates with version numbers greater than <a class="el" href="../../df/d76/structm0__dtm__hi.html#a38596b58a5c3a125092d68d7a609d1e0">m0_dtm_hi::hi_ver</a> executed. There can be multiple updates with version numbers equal to <a class="el" href="../../df/d76/structm0__dtm__hi.html#a38596b58a5c3a125092d68d7a609d1e0">m0_dtm_hi::hi_ver</a>, all but one of them must be read-only (because they do not change history version, see above), at least one of such updates has been executed.</p>
<p>History is "owned" (M0_DHF_OWNED) when the local DTM instance has the right to assign version numbers in the history. This is possible when, for example, local Motr instance owns an exclusive lock on the entity represented by the history.</p>
<p>Updates in a history are ordered in 3 ways: </p><pre class="fragment">- "list" ordering by their location in the history update list
  (m0_dtm_history::h_hi::hi_ups);

- "state" ordering by update state (m0_dtm_update::upd_up::up_state);

- "version" ordering by update version
  (m0_dtm_update::upd_up::up_ver). This ordering is partial, because some
  updates have "unknown" version (0).
</pre><p>For updates in states VOLATILE and later, all 3 orderings coincide: for updates X and Y, if X.state &gt;= VOLATILE, then (X.state &lt;= Y.state iff X.ver &lt;= Y.ver iff X is not later than Y in the update list). Moreover, such an update has known (non 0) original version, which coincides with the version of the update next in the list order.</p>
<p>Updates in FUTURE state are not ordered, they form a set from which updates are selected for execution as described below.</p>
<p>Finally, updates in INPROGRESS state are only ordered by the list order, which determines the order in which they left PREPARE state and in which they enter VOLATILE state.</p>
<p>Generally, updates in a history undergo the following process: </p><pre class="fragment">- at certain conditions (described below), advance_hi() scans the set of
  FUTURE updates, looking for an update ready for execution;

- if such an update is found, the update is moved in PREPARE state, the
  history is marked busy and m0_dtm_op_ops::doo_ready() call-back is
  called. This call-back belong to the update operation. All updates of
  an operation move to PREPARE state together. For owned histories,
  update version and original version are assigned at this moment
  (up_ready()), if they were unknown;

- when PREPARE state is complete, user calls m0_dtm_oper_prepared().
  This moves all updates of the operation in INPROGRESS state. This
  signifies that update started execution;

- when update execution is complete, user calls m0_dtm_oper_done(), which
  moves operation updates to VOLATILE state;

- later, when an update reaches a persistent store,
  m0_dtm_history_persistent() is called, which moves the update from
  VOLATILE to PERSISTENT state;

- finally, the update is moved to STABLE state.
</pre><p>hi_advance() is called in the following cases: </p><pre class="fragment">- an operation closes (m0_dtm_op_close()), operation updates are moved to
  FUTURE state and added to their histories and

- m0_dtm_op_prepared() un-busies histories.
</pre><p>Note that while update states are monotonically increasing, while the history update list is traversed, some state-changing events can happen out of order. Specifically, <a class="el" href="../../d2/d66/group__dtm.html#ga6da192797c05f8a3ff01790997090b1b">m0_dtm_oper_done()</a> can be called, when some earlier (in the list order) update is still INPROGRESS. In such cases update state transition is postponed to preserve monotonicity.</p>
<h1><a class="anchor" id="Operation"></a>
Operation</h1>
<p>An operation is a group of updates that change state (mostly) together.</p>
<p>It's important to understand that operations are not (directly) related to transactions, they are orthogonal. In fact, in the <a class="el" href="../../d2/dcf/dtm.html#gridiron">gridiron</a> diagram above, operations (going horizontally) are literally <em>orthogonal</em> to transactions, because the latter are implemented as (vertical) histories.</p>
<p>An operation is initially open. Updates can be added to an open operation. Such updates are in LIMBO state and are not attached to history update lists. When the operation is closed by <a class="el" href="../../d2/d66/group__dtm.html#gab358a69bfd95cd158b9355821e22a6ef">m0_dtm_oper_close()</a>, all its updates are moved to the FUTURE state. No further updates can be added to a closed operation.</p>
<p>By the time <a class="el" href="../../d2/d66/group__dtm.html#gab358a69bfd95cd158b9355821e22a6ef">m0_dtm_oper_close()</a> returns, operation updates might advance past FUTURE state: if they are ready for the execution (see above), they will be transferred to PREPARE state and might reach STABLE state by the time operation is closed.</p>
<p>The main purpose of operations is to group together updates, that should be simultaneously executed. Roughly speaking, an individual update can be executed when its version allows so and an operation can be executed when all its updates can be executed.</p>
<p>Executability of an individual update U is defined as following: </p><pre class="fragment">- U's version is compared (up_cmp()) with the current version of its
  history (m0_dtm_history::h_hi::hi_ver). This comparison can produce one
  of the following outcomes:

- U is EARLY: the update cannot be executed at the moment, because some
  intermediate updates are still missing;

- U is LATE: the update cannot be executed, because it has already been
  executed (update's version is less or equal to the history version);

- U is READY: the update can be executed.
</pre><p>Executability of an operation is checked by <a class="el" href="../../d2/d66/group__dtm.html#gafdc7e51d25bcb576d22dce939ac16cae">op_cmp()</a> as following: </p><pre class="fragment">- if all operation updates are READY, then the operation is READY;

- if all operation updates are LATE, then the operation is LATE;

- if there are EARLY and no LATE updates, then the operation is EARLY;

- otherwise there are both EARLY and LATE updates and the operation is
  *misordered*, that is, cannot be consistently recorded in its
  constituent histories (op_cmp() returns MISER).
</pre><p>Misordering means that DTM user violated serialisability conditions.</p>
<p>When <a class="el" href="../../d2/d66/group__dtm.html#gac28e4fd2c63ece4d210912f5091ae5d6">advance_op()</a> finds late or misordered operation, it signals the user and deletes the operation from DTM (removing all its updates from their histories), see <a class="el" href="../../d2/d66/group__dtm.html#gac28e4fd2c63ece4d210912f5091ae5d6">advance_op()</a>.</p>
<p>An operation typically contains updates from 2 classes: </p><pre class="fragment">- user updates, corresponding to storage objects that DTM end-user
  modifies (files, directories, etc.). User updates are explicitly added
  to the operation by the user (before the operation is closed);

- control updates, used internally by DTM to organize updates in larger
  logical ensembles.
</pre><p>For example, for each local transaction (<a class="el" href="../../d7/db0/structm0__dtm__ltx.html">m0_dtm_ltx</a>) there is a corresponding history (m0_dtm_ltx::lx_ch::ch_history). When an operation is executed in the context of a local transaction, DTM internally adds a special "noop" update (ch_noop_utype) to the operation. This noop update belongs to the local transaction history. This way all operations executed in the context of the local transaction are linked together and can be traced by following local transaction history's list of updates. When a local transaction is closed, a special "close" control update (ch_close_utype) is added to it.</p>
<p>Similarly, distributed transaction (<a class="el" href="../../d8/dd4/structm0__dtm__dtx.html">m0_dtm_dtx</a>), domain (<a class="el" href="../../d3/d79/structm0__dtm__domain.html">m0_dtm_domain</a>) and fol (<a class="el" href="../../d9/dae/structm0__dtm__fol.html">m0_dtm_fol</a>) contain embedded histories.</p>
<p>An update has a label (<a class="el" href="../../d4/d50/structm0__dtm__update.html#a389a2c45079e2b285bd32a0feb2f59b0">m0_dtm_update::upd_label</a>) unique within the update operation. The label is used to identify the update and fetch it from the operation after network transmission. User should assign unique labels to user updates. User updates must have labels not less than M0_DTM_USER_UPDATE_BASE. DTM automatically assigns unique labels to all control updates (in <a class="el" href="../../d2/d66/group__dtm.html#gab358a69bfd95cd158b9355821e22a6ef">m0_dtm_oper_close()</a>).</p>
<h1><a class="anchor" id="client-use"></a>
Client use cases for DTM</h1>
<p>There is a DTM instance on each client. For exmaple, in an m0t1fs client, <a class="el" href="../../db/d9f/structm0__dtm.html">m0_dtm</a> is embedded in the super-block.</p>
<p>When a client executes an application request that changes system state (e.g., file write or directory creation, as opposed to read-only request like file read or pathname lookup), it creates a distributed transaction for the request (<a class="el" href="../../d2/d66/group__dtm.html#ga332c5ce5e23cfab4805e76bf90847cf9">m0_dtm_dtx_init()</a>). The client then creates one or more operations, populates then with updates and adds operations to the transaction. Each operation can include updates to multiple histories corresponding to storage entities, potentially on different remote nodes. Internally, DTM adds control histories and control updates to the operations.</p>
<p>Updates can belong to owned or not-owned histories: </p><pre class="fragment">- when a client has an exclusive lock on some storage entity, the entity
  history is owned by the client DTM instance. In this case, client DTM
  assigns version and original version to every update to the history;

- when a client has no lock on an entity, it still can execute an
  operation on this entity. In this case, entity's history is not owned
  by the client and client DTM uses "unknown" (0) version number for
  updates to the history. When remote DTM executes the update, it assigns
  the version number to the update (which it can do, because it owns the
  history) and returns it to the client;

- a control history on a client can be owned. Examples are:
    - application domain (m0_dtm_domain), exclusively owned by the
      client;
    - "slot" shared between a client and server;
    - distributed transaction initiated by the client.
  In all these cases, the client assigns version numbers to the updates;

- a control history on a client can be non-owned. An example of this is
  the fol of a remote DTM instance. For an operation that has an update
  to be executed by a remote DTM instance, local client DTM adds (in
  m0_dtm_oper_close()) a no-op update to the remote DTM's fol
  (m0_dtm_fol_remote). This update has unknown version. When the
  operation is executed by the remote DTM, actual version number is
  assigned to this update and this version number is returned to the
  client.
</pre><p>After the user added all user updates to the operation, it adds the operation to the distributed transaction and closes the operation.</p>
<h1><a class="anchor" id="Concurrency"></a>
Concurrency</h1>
<h1><a class="anchor" id="Ownership"></a>
Ownership</h1>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d3/dd6/_d_l_d_i_x.html">Detailed Designs</a></li>
    <li class="footer">Generated on Thu Apr 14 2022 14:03:24 for Motr by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
