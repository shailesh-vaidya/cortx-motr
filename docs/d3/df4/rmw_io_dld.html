<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Motr: Detailed Level Design for read-modify-write IO requests.</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Motr
   &#160;<span id="projectnumber">M0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d3/df4/rmw_io_dld.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Detailed Level Design for read-modify-write IO requests. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-ovw">Overview</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-def">Definitions</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-req">Requirements</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-depends">Dependencies</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-highlights">Design Highlights</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec">Logical Specification</a><ul>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-comps">Component Overview</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-sc1">Subcomponent design</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-state">State Specification</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-thread">Threading and Concurrency Model</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-numa">NUMA optimizations</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-abort">IO request aborting</a></li>
</ul>
</li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-degraded-readIO">rmw-degraded-readIO</a><ul>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgreadIO-req">rmw-dgreadIO-req</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgreadIO-highlights">rmw-dgreadIO-highlights</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgreadIO-lspec">rmw-dgreadIO-lspec</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgreadIO-limitations">rmw-dgreadIO-limitations</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgreadIO-conformance">rmw-dgreadIO-conformance</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgreadIO-ut">rmw-dgreadIO-ut</a></li>
</ul>
</li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-degraded-writeIO">rmw-degraded-writeIO</a><ul>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgwriteIO-req">rmw-dgwriteIO-req</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgwriteIO-highlights">rmw-dgwriteIO-highlights</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgwriteIO-depends">rmw-dgwriteIO-depends</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgwriteIO-lspec">rmw-dgwriteIO-lspec</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgwriteIO-limitations">rmw-dgwriteIO-limitations</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgwriteIO-conformance">rmw-dgwriteIO-conformance</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgwriteIO-ut">rmw-dgwriteIO-ut</a></li>
</ul>
</li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-conformance">Conformance</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-ut">Unit Tests</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-st">System Tests</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-O">Analysis</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-ref">References</a></li>
</ul>
<hr/>
 <h1><a class="anchor" id="rmw-ovw"></a>
Overview</h1>
<p>The read-modify-write feature provides support to do partial parity group IO requests on a Motr client. This feature is needed for write IO requests <em>only</em>.</p>
<p>Motr uses notion of layout to represent how file data is spread over multiple objects. Motr client is supposed to work with layout independent code for IO requests. Using layouts, various RAID patterns like RAID5, parity declustered RAID can be supported.</p>
<p>Often, incoming <em>write</em> IO requests do not span whole parity group of file data. In such cases, additional data must be read from the same parity group to have enough information to compute new parity. Then data is changed as per the user request and later sent for write to server. Such actions are taken only for write IO path. Read IO requests do not need any such support.</p>
<hr/>
 <h1><a class="anchor" id="rmw-def"></a>
Definitions</h1>
<p>m0t1fs - Motr client file system. layout - A map which decides how to distribute file data over a number of objects.</p>
<hr/>
 <h1><a class="anchor" id="rmw-req"></a>
Requirements</h1>
<ul>
<li><b>R.m0t1fs.rmw_io.rmw</b> The implementation shall provide support for partial parity group IO requests.</li>
<li><b>R.m0t1fs.fullvectIO</b> The implementation shall support fully vectored scatter-gather IO where multiple IO segments could be directed towards multiple file offsets. This functionality will be used by cluster library writers through an ioctl.</li>
<li><b>R.m0t1fs.rmw_io.efficient</b> IO requests should be implemented efficiently. Since Motr follows async nature of APIs as far as possible, the implementation will stick to async APIs and shall avoid blocking calls.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="rmw-depends"></a>
Dependencies</h1>
<ul>
<li>An async way of waiting for reply rpc item from rpc layer.</li>
<li>Generic layout code.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="rmw-highlights"></a>
Design Highlights</h1>
<ul>
<li>All IO requests (spanning full or partial parity group) follow same code path.</li>
<li>For IO requests which span whole parity group/s, IO is issued immediately.</li>
<li>Read IO requests are issued <em>only</em> for units with at least one single byte of valid file data along with parity units. Ergo, no read IO is done beyond end-of-file.</li>
<li>In case of partial parity group write IO request, a read request is issued to read necessary data blocks and parity blocks.</li>
<li>Read requests will be issued to read the data pages which are partially spanned by the incoming IO requests. For write requests, The data pages which are completely spanned will be populated by copying data from user-space buffers.</li>
<li>Once read is complete, changes are made to partially spanned data buffers (typically these are pages from page cache) and parity is calculated in <em>iterative</em> manner. See the example below.</li>
<li>And then write requests are dispatched for the changed data blocks and the parity block from parity group/s.</li>
</ul>
<p>If <br />
 Do - Data from older version of data block. <br />
 Dn - Data from new version of data block. <br />
 Po - Parity for older version of parity group.</p>
<p>Then, <br />
 delta - <img class="formulaInl" alt="$Parity(Do, Dn)$" src="../../form_2.png"/> (Difference between 2 versions of data block) <br />
 Pn - <img class="formulaInl" alt="$Parity(delta, Po)$" src="../../form_3.png"/> (Parity for new version of parity group)</p>
<hr/>
 <h1><a class="anchor" id="rmw-lspec"></a>
Logical Specification</h1>
<ul>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-comps">Component Overview</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-sc1">Subcomponent design</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-smallIO">Small IO requests</a><ul>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-ds1">Subcomponent Data Structures</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-sub1">Subcomponent Subroutines</a></li>
<li>rmwDFSInternal</li>
</ul>
</li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-state">State Specification</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-thread">Threading and Concurrency Model</a></li>
<li><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-numa">NUMA optimizations</a></li>
</ul>
<h2><a class="anchor" id="rmw-lspec-comps"></a>
Component Overview</h2>
<ul>
<li>First, rwm_io component works with generic layout component to retrieve list of data units and parity units for given parity group.</li>
<li>Then it interacts with rpc bulk API to send IO fops to data server.</li>
<li>All IO fops are dispatched asynchronously at once and the caller thread sleeps over the condition of all fops getting replies.</li>
</ul>
<div class="mscgraph">
<img src="../../msc_inline_mscgraph_8.png" alt="msc_inline_mscgraph_8" border="0" usemap="#msc_inline_mscgraph_8.map"/>
<map name="msc_inline_mscgraph_8.map" id="msc_inline_mscgraph_8.map"></map>
</div>
<h2><a class="anchor" id="rmw-lspec-sc1"></a>
Subcomponent design</h2>
<p>This DLD addresses only rmw_io component.</p>
<ul>
<li>The component will sit in IO path of Motr client code.</li>
<li>It will detect if any incoming IO request spans a parity group only partially.</li>
<li>In case of partial groups, it issues an inline read request to read the necessary blocks from parity group and get the data in memory.</li>
<li>The thread blocks for completion of read IO.</li>
<li>If incoming IO request was read IO, the thread will be returned along with the status and number of bytes read.</li>
<li>If incoming IO request was write, the pages are modified in-place as per the user request.</li>
<li>And then, write IO is issued for the whole parity group.</li>
<li>Completion of write IO will send the status back to the calling thread.</li>
</ul>
<h2><a class="anchor" id="rmw-lspec-smallIO"></a>
Small IO requests</h2>
<p>For small IO requests which do not span even a single parity group due to end-of-file occurring before parity group boundary,</p><ul>
<li>rest of the blocks are assumed to be zero and</li>
<li>parity is calculated from valid data blocks only.</li>
</ul>
<p>The file size will be updated in file inode and will keep a check on actual size.</p>
<p>For instance, with configuration like</p>
<ul>
<li>parity_group_width = 20K</li>
<li>unit_size = 4K</li>
<li>nr_data_units = 3</li>
<li>nr_parity_units = 1</li>
<li>nr_spare_units = 1</li>
</ul>
<p>When a new file is written to with data worth 1K, there will be</p>
<ul>
<li>1 partial data unit and</li>
<li>2 missing data units</li>
</ul>
<p>in the parity group.</p>
<p>Here, parity is calculated with only one partial data unit (only valid block) and data from whole parity group will be written to the server.</p>
<p>While reading the same file back, IO request for only one block is made as mandated by file size.</p>
<p>The seemingly obvious wastage of storage space in such cases can be overcome by</p><ul>
<li>issuing IO requests <em>only</em> for units which have at least a single byte of valid file data and for parity units.</li>
<li>For missing data units, there is no need to use zeroed out buffers since such buffers do not change parity.</li>
<li>Ergo, parity will be calculated from valid data blocks only (falling within end-of-file)</li>
</ul>
<p>Since sending network requests for IO is under control of client, these changes can be accommodated for irrespective of layout type. This way, the wastage of storage space in small IO can be restricted to block granularity.</p>
<p>Processing an IO request may be interrupted due to rconfc read lock revocation. At that point m0t1fs can't read configuration and all operations must be stopped. In that case all IO requests existing at the moment are marked as failed, and as the result client receives -ESTALE error code. The client can try IO operations later when a configuration can be read again. </p><dl class="section see"><dt>See also</dt><dd>rmw-lspec-abort.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000136">Todo:</a></b></dt><dd>In future, optimizations could be done in order to speed up small file IO with the help of client side cache.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Present implementation of m0t1fs IO path uses get_user_pages() API to pin user-space pages in memory. This works just fine with page aligned IO requests. But read-modify-write IO will use APIs like copy_from_user() and copy_to_user() which can copy data to or from user-space for both aligned and non-aligned IO requests. Although for <em>direct-IO</em> and device IO requests, no copy will be done and it uses get_user_pages() API since direct-IO is always page aligned.</dd></dl>
<h3><a class="anchor" id="rmw-lspec-ds1"></a>
Subcomponent Data Structures</h3>
<p><a class="el" href="../../d6/d09/structio__request.html">io_request</a> - Represents an IO request call. It contains the IO extent, struct <a class="el" href="../../d5/d5d/structnw__xfer__request.html">nw_xfer_request</a> and the state of IO request. This structure is primarily used to track progress of an IO request. The state transitions of <a class="el" href="../../d6/d09/structio__request.html">io_request</a> structure are handled by <a class="el" href="../../db/d49/structm0__sm.html">m0_sm</a> structure and its support for chained state transitions.</p>
<p>The <a class="el" href="../../d5/d32/structm0__sm__group.html">m0_sm_group</a> structure is kept as a member of in-memory superblock, struct m0t1fs_sb. All <a class="el" href="../../db/d49/structm0__sm.html">m0_sm</a> structures are associated with this group. </p><dl class="section see"><dt>See also</dt><dd>struct m0t1fs_sb.</dd></dl>
<p>io_req_state - Represents state of IO request call. <a class="el" href="../../da/d29/structm0__sm__state__descr.html">m0_sm_state_descr</a> structure will be defined for description of all states mentioned below.</p>
<p>io_req_type - Represents type of IO request.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000137">Todo:</a></b></dt><dd>IO types like fault IO are not supported yet.</dd></dl>
<p><a class="el" href="../../d8/d5a/structio__request__ops.html">io_request_ops</a> - Operation vector for struct <a class="el" href="../../d6/d09/structio__request.html">io_request</a>.</p>
<p><a class="el" href="../../d5/d5d/structnw__xfer__request.html">nw_xfer_request</a> - Structure representing the network transfer part for an IO request. This structure keeps track of request IO fops as well as individual completion callbacks and status of whole request. Typically, all IO requests are broken down into multiple fixed-size requests.</p>
<p>nw_xfer_state - State of struct <a class="el" href="../../d5/d5d/structnw__xfer__request.html">nw_xfer_request</a>.</p>
<p><a class="el" href="../../d3/d65/structnw__xfer__ops.html">nw_xfer_ops</a> - Operation vector for struct <a class="el" href="../../d5/d5d/structnw__xfer__request.html">nw_xfer_request</a>.</p>
<p><a class="el" href="../../d0/d55/structpargrp__iomap.html">pargrp_iomap</a> - Represents a map of io extents in given parity group. Struct <a class="el" href="../../d6/d09/structio__request.html">io_request</a> contains as many <a class="el" href="../../d0/d55/structpargrp__iomap.html">pargrp_iomap</a> structures as the number of parity groups spanned by original index vector. Typically, the segments from <a class="el" href="../../d0/d55/structpargrp__iomap.html#a7ef80669f099a2021e26df1d9057d5ff">pargrp_iomap::pi_ivec</a> are round_{up/down} to nearest page boundary for segments from io_request::ir_ivec.</p>
<p>pargrp_iomap_rmwtype - Type of read approach used by <a class="el" href="../../d0/d55/structpargrp__iomap.html">pargrp_iomap</a> in case of rmw IO.</p>
<p><a class="el" href="../../dc/d8f/structpargrp__iomap__ops.html">pargrp_iomap_ops</a> - Operation vector for struct <a class="el" href="../../d0/d55/structpargrp__iomap.html">pargrp_iomap</a>.</p>
<p><a class="el" href="../../de/dc5/structdata__buf.html">data_buf</a> - Represents a simple data buffer wrapper object. The embedded db_buf::b_addr points to a kernel page or a user-space buffer in case of direct IO.</p>
<p><a class="el" href="../../d8/dc9/structtarget__ioreq.html">target_ioreq</a> - Collection of IO extents and buffers, directed toward particular component object in a parity group. These structures are created by struct <a class="el" href="../../d6/d09/structio__request.html">io_request</a> dividing the incoming struct iovec into members of parity group.</p>
<p>ast thread - A thread will be maintained per super block instance m0t1fs_sb to wake up on receiving ASTs and execute the bottom halves. This thread will run as long as m0t1fs is mounted. This thread will handle the pending IO requests gracefully when unmount is triggered.</p>
<p>The in-memory super block struct m0t1fs_sb will maintain</p>
<ul>
<li>a boolean indicating if super block is active (mounted). This flag will be reset by the unmount thread. In addition to this, every io request will check this flag while initializing. If this flag is reset, it will return immediately. This helps in blocking new io requests from coming in when unmount is triggered.</li>
<li>atomic count of pending io requests. This will help while handling pending io requests when unmount is triggered.</li>
<li>the "ast" thread to execute ASTs from io requests and to wake up the unmount thread after completion of pending io requests.</li>
<li>a channel for unmount thread to wait on until all pending io requests complete.</li>
</ul>
<p>The thread will run a loop like this...</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (1) {</div><div class="line">        <a class="code" href="../../df/da0/group__chan.html#ga2370fce32196fcfe356cbb47046449de">m0_chan_wait</a>(&amp;sm_group-&gt;s_clink);</div><div class="line">        <a class="code" href="../../d1/dc1/group__sm.html#gae842503973adac6c86a3c1cca683f3a1">m0_sm_group_lock</a>(sm_group);</div><div class="line">        <a class="code" href="../../d1/dc1/group__sm.html#ga86a9c851a2733f04ae882053f934abb5">m0_sm_asts_run</a>(sm_group);</div><div class="line">        <a class="code" href="../../d1/dc1/group__sm.html#gadc8d83305d9fc9578b35299ccd89ff81">m0_sm_group_unlock</a>(sm_group);</div><div class="line">        <span class="keywordflow">if</span> (!<a class="code" href="../../da/d03/m0t1fs_2linux__kernel_2ut_2file_8c.html#a75bc9e5b35af599710e65a2c6d8d6bf5">sb</a>-&gt;csb_active &amp;&amp; <a class="code" href="../../d3/de8/group__atomic.html#ga611f47b9f61896df7924843f8d7e95de">m0_atomic64_get</a>(&amp;<a class="code" href="../../da/d03/m0t1fs_2linux__kernel_2ut_2file_8c.html#a75bc9e5b35af599710e65a2c6d8d6bf5">sb</a>-&gt;csb_pending_io_nr) == 0){</div><div class="line">                <a class="code" href="../../df/da0/group__chan.html#ga57339950d21ecc706c5f2e623647f122">m0_chan_signal</a>(&amp;<a class="code" href="../../da/d03/m0t1fs_2linux__kernel_2ut_2file_8c.html#a75bc9e5b35af599710e65a2c6d8d6bf5">sb</a>-&gt;csb_iowait);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><p>So, while m0t1fs is mounted, the thread will keep running in loop waiting for ASTs.</p>
<p>When unmount is triggered, new io requests will be returned with an error code as m0t1fs_sb::csb_active flag is unset. For pending io requests, the ast thread will wait until callbacks from all outstanding io requests are acknowledged and executed.</p>
<p>Once all pending io requests are dealt with, the ast thread will exit waking up the unmount thread.</p>
<p>Abort is not supported at the moment in m0t1fs io code as it needs same functionality from layer beneath.</p>
<p>When bottom halves for <a class="el" href="../../de/d78/structm0__sm__ast.html">m0_sm_ast</a> structures are run, it updates target_ioreq::tir_rc and target_ioreq::tir_bytes with data from IO reply fop. Then the bottom half decrements nw_xfer_request::nxr_iofops_nr, number of IO fops. When this count reaches zero, <a class="el" href="../../d6/d09/structio__request.html#a64f3c9388f7337ab4aa0b92e6343ed46">io_request::ir_sm</a> changes its state.</p>
<p>A callback function will be used to associate with <a class="el" href="../../de/d21/structm0__rpc__item.html#a6aa5edcd589a8e8b25d32c0c54fe6536">m0_rpc_item::ri_ops</a>:: rio_replied(). This callback will be invoked once rpc layer receives the reply rpc item. This callback will post the <a class="el" href="../../d3/d4a/structio__req__fop.html#a7c918d924d2c65279a5a6f018822c30c">io_req_fop::irf_ast</a> and will thus wake up the thread which executes the ASTs.</p>
<p><a class="el" href="../../d3/d4a/structio__req__fop.html">io_req_fop</a> - Represents a wrapper over generic IO fop and its callback to keep track of such IO fops issued by same <a class="el" href="../../d5/d5d/structnw__xfer__request.html">nw_xfer_request</a>.</p>
<p>io_rpc_item_cb - Callback used to receive fop reply events.</p>
<p>io_bottom_half - Bottom-half function for IO request.</p>
<p>Magic value to verify sanity of struct <a class="el" href="../../d6/d09/structio__request.html">io_request</a>, struct <a class="el" href="../../d5/d5d/structnw__xfer__request.html">nw_xfer_request</a>, struct <a class="el" href="../../d8/dc9/structtarget__ioreq.html">target_ioreq</a> and struct <a class="el" href="../../d3/d4a/structio__req__fop.html">io_req_fop</a>. The magic values are used along with static <a class="el" href="../../de/dcc/structm0__bob__type.html">m0_bob_type</a> structures to assert run-time type identification.</p>
<h3><a class="anchor" id="rmw-lspec-sub1"></a>
Subcomponent Subroutines</h3>
<p>In order to satisfy the requirement of an ioctl API for fully vectored scatter-gather IO (where multiple IO segments are directed at multiple file offsets), a new API will be introduced that will use a <a class="el" href="../../df/da2/structm0__indexvec.html">m0_indexvec</a> structure to specify multiple file offsets.</p>
<div class="fragment"><div class="line">ssize_t <a class="code" href="../../d0/dec/m0t1fs_2linux__kernel_2file_8c.html#a3de95985754f2f14571a59f11f638aa5">m0t1fs_aio</a>(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">const</span> <span class="keyword">struct</span> iovec *iov,</div><div class="line">              <span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="../../df/da2/structm0__indexvec.html">m0_indexvec</a> *ivec, <span class="keyword">enum</span> io_req_type <a class="code" href="../../db/dcd/m0t1fs_2linux__kernel_2dir_8c.html#ac765329451135abec74c45e1897abf26">type</a>);</div></div><!-- fragment --><p>In case of normal file-&gt;f_op-&gt;aio_{read/write} calls, the <a class="el" href="../../df/da2/structm0__indexvec.html">m0_indexvec</a> will be created and populated by m0t1fs code, while in case of ioctl, it has to be provided by user-space.</p>
<p><a class="el" href="../../d0/dec/m0t1fs_2linux__kernel_2file_8c.html#abdb03f8bef7aeb901c5457f71f7c6af4">io_request_invariant</a> - Invariant for structure <a class="el" href="../../d6/d09/structio__request.html">io_request</a>.</p>
<p><a class="el" href="../../de/df0/io__nw__xfer_8c.html#ae5266b3b8a6ac758c86bc265ff418589">nw_xfer_request_invariant</a> - Invariant for structure <a class="el" href="../../d5/d5d/structnw__xfer__request.html">nw_xfer_request</a>.</p>
<p><a class="el" href="../../db/d27/io__pargrp_8c.html#a0f05b7df22b02742ec3d729976221d1e">data_buf_invariant_nr</a> - A helper function to invoke invariant() for all <a class="el" href="../../de/dc5/structdata__buf.html">data_buf</a> structures in array pargrp_iomap::tir_databufs. It is on similar lines of <a class="el" href="../../d7/d08/group__tlist.html#gaff6f93b3ca67a19e8460cc469f5eabda">m0_tl_forall()</a> API.</p>
<p><a class="el" href="../../de/df0/io__nw__xfer_8c.html#ad33a724bb7b5ad13a307654da8cd7972">target_ioreq_invariant</a> - Invariant for structure <a class="el" href="../../d8/dc9/structtarget__ioreq.html">target_ioreq</a>.</p>
<p><a class="el" href="../../db/d27/io__pargrp_8c.html#a9795f9bb68a7c292ffd94bb1d51746c1">pargrp_iomap_invariant</a> - Invariant for structure <a class="el" href="../../d0/d55/structpargrp__iomap.html">pargrp_iomap</a>.</p>
<p><a class="el" href="../../db/d27/io__pargrp_8c.html#aa221fcb792f17a665e7590b265995dc5">pargrp_iomap_invariant_nr</a> - A helper function to invoke <a class="el" href="../../d0/dec/m0t1fs_2linux__kernel_2file_8c.html#a7261507e9052e45c7c69f3c63732a485">pargrp_iomap_invariant()</a> for all such structures in <a class="el" href="../../d6/d09/structio__request.html#a6a813c12d14846501d7f9173acde6aeb">io_request::ir_iomaps</a>.</p>
<p><a class="el" href="../../db/d27/io__pargrp_8c.html#a77e35b33d60b81ada3365935e1b9ec6c">data_buf_invariant</a> - Invariant for structure <a class="el" href="../../de/dc5/structdata__buf.html">data_buf</a>.</p>
<p><a class="el" href="../../d0/dec/m0t1fs_2linux__kernel_2file_8c.html#ae29486695c7a51bc61439e47bc9ccb27">io_req_fop_invariant</a> - Invariant for structure <a class="el" href="../../d3/d4a/structio__req__fop.html">io_req_fop</a>.</p>
<p><a class="el" href="../../d0/dec/m0t1fs_2linux__kernel_2file_8c.html#abfe42dac8c4bfb773f727e2fb629d1e6">io_request_init</a> - Initializes a newly allocated <a class="el" href="../../d6/d09/structio__request.html">io_request</a> structure.</p>
<p><a class="el" href="../../d0/dec/m0t1fs_2linux__kernel_2file_8c.html#a473e1883fcb6719a2314b67f384de53c">io_request_fini</a> - Finalizes the <a class="el" href="../../d6/d09/structio__request.html">io_request</a> structure.</p>
<p>nw_xfer_req_prepare - Creates and populates <a class="el" href="../../d8/dc9/structtarget__ioreq.html">target_ioreq</a> structures for each member in the parity group. Each <a class="el" href="../../d8/dc9/structtarget__ioreq.html">target_ioreq</a> structure will allocate necessary pages to store file data and will create IO fops out of it.</p>
<p><a class="el" href="../../de/df0/io__nw__xfer_8c.html#aa4bf7cbec21e370bb79fc606e8fa5801">nw_xfer_req_dispatch</a> - Dispatches the network transfer request and does asynchronous wait for completion. Typically, IO fops from all target_ioreq::tir_iofops contained in nw_xfer_request::nxr_tioreqs list are dispatched at once. The network transfer request is considered as complete when callbacks for all IO fops from all <a class="el" href="../../d8/dc9/structtarget__ioreq.html">target_ioreq</a> structures are acknowledged and processed.</p>
<p><a class="el" href="../../de/df0/io__nw__xfer_8c.html#a8fc25e92271895c0d81c35f244d5d6a0">nw_xfer_req_complete</a> - Does post processing for network request completion which is usually notifying struct <a class="el" href="../../d6/d09/structio__request.html">io_request</a> about completion.</p>
<h2><a class="anchor" id="rmw-lspec-state"></a>
State Specification</h2>
<div class="dotgraph">
</div>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000138">Todo:</a></b></dt><dd>A client cache is missing at the moment. With addition of cache, the states of an IO request might add up.</dd></dl>
<h2><a class="anchor" id="rmw-lspec-thread"></a>
Threading and Concurrency Model</h2>
<p>All IO fops resulting from IO request will be dispatched at once and the state machine (<a class="el" href="../../db/d49/structm0__sm.html">m0_sm</a>) will wait for completion of read or write IO. Incoming callbacks will be registered with the <a class="el" href="../../db/d49/structm0__sm.html">m0_sm</a> state machine where the bottom half functions will be executed on the "ast" thread. The ast thread and the system call thread coordinate by using <a class="el" href="../../d5/d32/structm0__sm__group.html#a35ea50a5628d18080a8b585d18f405a2">m0_sm_group::s_lock</a> mutex. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/dc1/group__sm.html">State machine</a>. Concurrency section of State <a class="el" href="../../d7/d93/mdservice_2ut_2mdstore_8c.html#a31ac5fe4c426986a4a393057ae289040">machine</a>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000139">Todo:</a></b></dt><dd>In future, with introduction of Resource Manager, distributed extent locks have to be acquired or released as needed.</dd></dl>
<h2><a class="anchor" id="rmw-lspec-numa"></a>
NUMA optimizations</h2>
<p>None.</p>
<h2><a class="anchor" id="rmw-lspec-abort"></a>
IO request aborting</h2>
<p>When m0t1fs rconfc lost read lock it can't read configuration and all existing IO requests must be stopped at the current point of progress. Once rconfc loses read lock, <a class="el" href="../../d2/d9e/structm0__rconfc.html#ab265089da34d9499719245d83aba3565">m0_rconfc::rc_expired_cb</a> is triggered. It sets m0t1fs_sb::csb_rlock_revoked to true and cancel sessions to IO services. ioreq_iosm_handle checks the flag after its subroutines and interrupt handling, if the read lock is revoked.</p>
<h1><a class="anchor" id="rmw-degraded-readIO"></a>
rmw-degraded-readIO</h1>
<p>This section describes the provision for read IO while SNS repair is going on. Motr uses data redundancy patterns like pdclustered RAID to recover in case of a failed device or node. Parity is calculated across a parity group and stored on persistent media so as to recover in case disaster strikes. Since file data is distributed across multiple target objects (cobs in this case), failure of a read IO request for any cobs could result into triggering of degraded mode read IO.</p>
<h2><a class="anchor" id="rmw-dgreadIO-req"></a>
rmw-dgreadIO-req</h2>
<ul>
<li><b>R.dg.mode.readIO.efficient</b> The implementation shall provide an efficient way of handling degraded mode read IO requests keeping the performance hit to a minimum.</li>
<li><b>R.dg.mode.readIO.clientOnly</b> The implementation shall stick to retrieving the lost data unit by reading rest of the data units and/or parity unit from given parity group. There is no interaction with server sns repair process.</li>
</ul>
<h2><a class="anchor" id="rmw-dgreadIO-highlights"></a>
rmw-dgreadIO-highlights</h2>
<p>A new state will be introduced to represent degraded mode read IO. The degraded mode state will find out the affected parity groups from the failed IO fop and will start read for missing data units and/or parity units. Amount of data to be read depends on type of read approach undertaken by the pargrp group (struct <a class="el" href="../../d0/d55/structpargrp__iomap.html">pargrp_iomap</a>), namely</p><ul>
<li>read_old Read rest of the data units as well as parity units.</li>
<li>read_rest Read parity units only since all other data units are already present.</li>
</ul>
<h2><a class="anchor" id="rmw-dgreadIO-lspec"></a>
rmw-dgreadIO-lspec</h2>
<p>A new state DEGRADED_READING will be introduced to handle degraded read IO. The error in IO path will be introduced by a fault injection point which will trigger degraded mode and IO state machine will transition into degraded mode state.</p>
<p>Both simple read IO and read-modify-write IO will be supported in the process. The state transition of IO state machine in both these case will be as given below...</p>
<ul>
<li>simple readIO <br />
 READING &ndash;&gt; DEGRADED_READING <br />
 DEGRADED_READING &ndash;&gt; READ_COMPLETE <br />
 READ_COMPLETE &ndash;&gt; REQ_COMPLETE.</li>
<li>read-modify-write IO <br />
 READING &ndash;&gt; DEGRADED_READING <br />
 DEGRADED_READING &ndash;&gt; READ_COMPLETE <br />
 READ_COMPLETE &ndash;&gt; WRITING <br />
 WRITING &ndash;&gt; WRITE_COMPLETE <br />
 WRITE_COMPLETE &ndash;&gt; REQ_COMPLETE.</li>
</ul>
<p>Caller does not get any intimation of degraded mode read IO. It can only be realised by a little lower throughput numbers since degraded mode readIO state has to do more IO.</p>
<p>A modified state transition diagram can be seen at State specification. </p><dl class="section see"><dt>See also</dt><dd>rmw-lspec-state.</dd></dl>
<p>The existing rmw data structures will be modified to accommodate degraded mode read IO as mentioned below...</p>
<ul>
<li>struct <a class="el" href="../../d6/d09/structio__request.html">io_request</a><ul>
<li>It is the top-level data structure which represents an IO request and state machine will be changed by addition of degraded read IO state.</li>
<li>Routine iosm_handle() will be modified to handle degraded mode state and transition into normal read or write states once degraded mode read IO is complete.</li>
<li>New routines will be added to handle retrieval of lost data unit/s from rest of data units and parity units.</li>
<li><dl class="section see"><dt>See also</dt><dd>rmw-dgreadIO-lspec for valid state transitions with new degraded <a class="el" href="../../db/dcd/m0t1fs_2linux__kernel_2dir_8c.html#a5c10aac132be10054364e8c6dab6e3bc">mode</a> read <a class="el" href="../../d8/d42/group__crate.html#gga9abd0b0dc7c6101f2b95164f81b168aeaedd9974ef2207e0a03e0717dcb9e2269">IO</a> state.</dd></dl>
</li>
</ul>
</li>
<li>struct <a class="el" href="../../d0/d55/structpargrp__iomap.html">pargrp_iomap</a><ul>
<li>a state enumeration will be added indicating the state of parity group is either HEALTHY or DEGRADED.</li>
<li>Pages from the data units and/or parity units that need to be read in order to retrieve lost data unit will be marked with a special page flag to distinguish between normal IO and degraded mode IO.</li>
<li>Since every parity group follows either read-old or read-rest approach while doing read-modify-write, special routines catering to degraded mode handling of these approaches will be developed.<ul>
<li>read_old Since all data units may not be available in this approach, all remaining data units are read. Parity units are read already.</li>
<li>read_rest All data units are available but parity units are not. Hence, parity units are read in order to retrieve lost data.</li>
<li>simple_read A routine will be written in order to do read for rest of data units and/or parity units for a simple read IO request.</li>
</ul>
</li>
</ul>
</li>
<li>struct dgmode_readvec<ul>
<li>a new data structure to hold <a class="el" href="../../df/da2/structm0__indexvec.html">m0_indexvec</a> and <a class="el" href="../../da/d2c/structm0__bufvec.html">m0_bufvec</a> for pages that needed to be read from server.</li>
</ul>
</li>
<li>struct <a class="el" href="../../d5/d5d/structnw__xfer__request.html">nw_xfer_request</a><ul>
<li>nw_xfer_io_prepare() operation will be modified to distribute pages amongst target objects for degraded mode read IO.</li>
</ul>
</li>
<li>struct <a class="el" href="../../d8/dc9/structtarget__ioreq.html">target_ioreq</a><ul>
<li>a new data structure (struct dgmode_readvec) will be introduced to hold pages from degraded mode read IO. This serves 2 purposes.<ul>
<li>Segregate degraded mode read IO from normal IO and</li>
<li>Normal IO requests will not be affected by degraded mode read IO code.</li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="../../d0/dec/m0t1fs_2linux__kernel_2file_8c.html#aa4335ac7529536ab734631137a5de987">target_ioreq_iofops_prepare()</a><ul>
<li>This routine will be changed to handle IO for both healthy mode as well as degraded mode IO.</li>
</ul>
</li>
<li>enum page_attr<ul>
<li>a new flag (PA_DGMODE_READ) will be added to identify pages issued for degraded mode read IO.</li>
</ul>
</li>
<li><p class="startli">io_bottom_half</p><ul>
<li>This routine will be modified to host a fault injection point which will simulate the behavior of system in case of read IO failure.</li>
</ul>
<p class="startli">Along with all these changes, almost all invariants will be changed as necessary.</p>
</li>
</ul>
<h2><a class="anchor" id="rmw-dgreadIO-limitations"></a>
rmw-dgreadIO-limitations</h2>
<ul>
<li>Since present implementation of read-modify-write IO supports only XOR due to lack of differential calculation of parity for Reed-Solomon algorithm only single failures will be supported as XOR supports single failures only.</li>
<li>Since there is no provision in current bulk transfer/rpc bulk API to pin-point failed segment/s in given IO vector during bulk transfer, all parity groups referred to by segments in failed read fop will be tried for regeneration of lost data.</li>
</ul>
<h2><a class="anchor" id="rmw-dgreadIO-conformance"></a>
rmw-dgreadIO-conformance</h2>
<p><b>I.dg.mode.readIO.efficient</b> The implementation will use async way of sending fops and waiting for them. All pages are aggregated so all pending IO is dispatched at once. Besides, new IO vectors will be used in <a class="el" href="../../d8/dc9/structtarget__ioreq.html">target_ioreq</a> structures so as to segregate them from normal IO vector.</p>
<p><b>I.dg.mode.readIO.clientOnly</b> The implementation will use parity regeneration APIs from parity math library so that there is no need to communicate with server.</p>
<h2><a class="anchor" id="rmw-dgreadIO-ut"></a>
rmw-dgreadIO-ut</h2>
<p>The existing rmw UT will be modified to accommodate unit tests made to stress the degraded mode read IO code.</p>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000074">Test:</a></b></dt><dd>Prepare a simple read IO request and enable the fault injection point in order to simulate behavior in case of degraded mode read IO. Keep a known pattern of data in data units so as to verify the contents of lost data unit after degraded mode read IO completes.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000075">Test:</a></b></dt><dd>Prepare a read-modify-write IO request with one parity group and enable fault injection point in io_bottom_half. Keep only one valid data unit in parity group so as to ensure read_old approach is used. Trigger the fault injection point to simulate degraded mode read IO and verify the contents of read buffers after degraded mode read IO completes. The contents of read buffers should match the expected data pattern.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000076">Test:</a></b></dt><dd>Preapre a read-modify-write IO request with one parity group and enable the fault injection point in io_bottom_half. Keep all but one valid data units in parity group so as to ensure read-rest approach is used. Trigger the fault injection point to simulate degraded mode read IO and verify contents of read buffers after degraded mode read IO completes. The contents of read buffers should match the expected data pattern.</dd></dl>
<h1><a class="anchor" id="rmw-degraded-writeIO"></a>
rmw-degraded-writeIO</h1>
<p>This section describes the internals of degraded mode write IO, an update operation, going concurrently with SNS repair process. Since SNS repair and write IO can operate on same file at a file, a distributed lock is used to synchronize access to files. This distributed lock will be used by Motr client IO code as well as the SNS repair process. Once lock is acquired on the given file, write IO request will send IO fops to respective healthy devices and will return the number of bytes written to the end user.</p>
<h2><a class="anchor" id="rmw-dgwriteIO-req"></a>
rmw-dgwriteIO-req</h2>
<p><b>R.dg.mode.writeIO.consistency</b> The implementation shall keep the state of file system to be consistent after degraded mode write IO requests. Ergo, any further read IO requests on same extents should fetch the expected data.</p>
<p><b>R.dg.mode.writeIO.efficient</b> The implementation shall provide an efficient way of provisioning degraded write IO support, keeping the performance hits to a minimum.</p>
<p><b>R.dg.mode.writeIO.dist_locks</b> The implementation shall use cluster wide distributed locks in order to synchronize access between client IO path and SNS repair process. Although due to unavailability of distributed locks, the implementation shall stick to a working business logic which can be demonstrated through appropriate test cases. Distributed locks shall be introduced as and when they are available.</p>
<h2><a class="anchor" id="rmw-dgwriteIO-highlights"></a>
rmw-dgwriteIO-highlights</h2>
<p>A new state will be introduced in IO request state machine to handle all details of degraded mode write IO. The IO request shall try to acquire a distributed lock on the given file and will block until lock is granted. All compute operations like processing parity groups involved and distributing file data amongst different target objects shall be done. Issuing of actual IO fops is not done until distributed lock is not granted. The degraded mode write IO request will find out the current window of SNS repair process in order to find out whether repair process has repaired given file or not. Accordingly write IO fops will be sent to devices (cobs) and total number of bytes written will be returned to end user.</p>
<h2><a class="anchor" id="rmw-dgwriteIO-depends"></a>
rmw-dgwriteIO-depends</h2>
<ul>
<li>Distributed lock API is expected from resource management subsystem which will take care of synchronizing access to files. The Motr client IO path will request a distributed lock for given file and will block until lock is not granted. Similarly, SNS repair should acquire locks on global files which are part of current sliding window while repairing.</li>
<li>An API is expected from SNS subsystem which will find out if repair has completed for input global file fid or not. Since the SNS repair sliding window consists of a set of global fids which are currently under repair, assuming the lexicographical order of repair, the API should return whether input global fid has been repaired or not.</li>
<li>When number of spare units in a storage pool is greater than one, algorithm like Reed &amp; Solomon is used to generate parity. During repair, the SNS repair process recovers the lost data using parity recovery algorithms. If number of parity units is greater than one, the order in which lost units are stored on spare units (which recovered data unit will be stored on which spare unit) should be well known. It should be similar to degraded mode write IO use-case where data for lost devices needs to be redirected to spare units. <br />
 An example can illustrate this properly -<ul>
<li>Consider a storage pool with parameters N = 8, K = 2, P = 12</li>
<li>Assuming device# 2 and #3 failed and SNS repair is triggered.</li>
<li>When SNS repair recovers lost data for 2 lost devices, it needs to be stored on the 2 spare units in all parity groups.</li>
<li>Now the order in which this data is stored on spare units matters and should be same with the order used by Motr client IO code in cases where data for lost devices need to be redirected towards corresponding spare units in same parity group. For instance,<ul>
<li>Recovered unit# 2 stored on Spare unit# 0 AND</li>
<li>Recovered unit# 3 stored on Spare unit# 1. OR</li>
<li>Recovered unit# 2 stored on Spare unit# 1 AND</li>
<li>Recovered unit# 3 stored on Spare unit# 0.</li>
</ul>
</li>
<li>Same routine will be used by Motr degraded write IO code path as well as SNS repair code to decide this order.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="rmw-dgwriteIO-lspec"></a>
rmw-dgwriteIO-lspec</h2>
<p>A new state DEGRADED_WRITING will be introduced which will take care of handling degraded write IO details.</p>
<ul>
<li>As the first step, IO path will try to acquire distributed lock on the given file. This code will be a stub in this case, since distributed locks are not available yet. IO path will block until the distributed lock is not granted.</li>
<li>When SNS repair starts, the normal write IO will fail with an error.</li>
<li>The IO reply fop will be incorporated with a U64 field which will indicate whether SNS repair has finished or is yet to start on given file fid. Alongside, the IO request fop will be incorporated with global fid since since it is not present in current IO request fop and it is needed to find out whether SNS repair has completed for this global fid or not. The SNS repair subsystem will invoke an API <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgwriteIO-depends">rmw-dgwriteIO-depends</a> which will return either a boolean <a class="el" href="../../db/dcd/m0t1fs_2linux__kernel_2dir_8c.html#a49f4a8777715593cb60cf41f88d53f62">value</a> indicating whether repair has completed for given <a class="el" href="../../d4/d00/ut_2di_8c.html#af510170d8a2ea6ab260937a1030c17cb">file</a> or not. Structure <a class="el" href="../../d3/d4a/structio__req__fop.html">io_req_fop</a> will <a class="el" href="../../d0/df1/iter__ut_8c.html#aa1e88453a5be7e5aa3334108a15171e8">be</a> incorporated with a boolean <a class="el" href="../../dd/d6d/group__xcode.html#gae925b6b1e041430a455288ef61ff2e89">field</a> to indicate whether SNS repair has completed for given global <a class="el" href="../../db/dcd/m0t1fs_2linux__kernel_2dir_8c.html#a688aa017bb6d5c4ba591ae41abd6122f">fid</a> or not.</dd></dl>
</li>
<li>Use-case 1: If SNS repair is yet to start on given file, the write IO fops for the failed device can be completely ommitted since there is enough information in parity group which can be used by SNS repair to re-generate lost data.<ul>
<li>If the lost unit is file data, it can be re-generated using parity recover algorithms since parity is updated in this case.</li>
<li>If lost unit is parity, it can be re-calculated using parity generation algorithm.</li>
</ul>
</li>
<li>Use-case 2: If SNS repair has completed for given file, the write IO fops for the failed device can be redirected to spare units since by that time, SNS repair has re-generated data and has dumped it on spare units.<ul>
<li>A mechanism is needed from SNS repair subsystem to find out which unit from parity group maps to which spare unit. <br />
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-dgwriteIO-depends">rmw-dgwriteIO-depends</a></dd></dl>
</li>
</ul>
</li>
<li>The state machine will transition as follows. <br />
 WRITING &ndash;&gt; WRITE_COMPLETE <br />
 WRITE_COMPLETE &ndash;&gt; DEGRADED_WRITING <br />
 DEGRADED_WRITING &ndash;&gt; WRITE_COMPLETE <dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/df4/rmw_io_dld.html#rmw-lspec-state">State Specification</a></dd></dl>
</li>
<li>Existing rmw IO structures will be modified as mentioned below.<ul>
<li>struct <a class="el" href="../../d6/d09/structio__request.html">io_request</a><ul>
<li>State machine will be changed by addition of a new state which will handle degraded mode write IO.</li>
<li><a class="el" href="../../d0/dec/m0t1fs_2linux__kernel_2file_8c.html#a93849df78d31b58bc028810d5f4af3bb">ioreq_iosm_handle()</a> will be modified to handle new state whenever write IO fails with a particular error code.</li>
</ul>
</li>
<li>struct <a class="el" href="../../d5/d5d/structnw__xfer__request.html">nw_xfer_request</a><ul>
<li>Needs change in <a class="el" href="../../d0/dec/m0t1fs_2linux__kernel_2file_8c.html#a868fe96209a5da63122469af0fea932b">nw_xfer_tioreq_map()</a> to factor out common code which will be shared with the use-case where repair has completed for given file and lost data is re-generated on spare units. In this case, write IO fops on failed device need to be redirected to spare units.</li>
</ul>
</li>
<li>struct <a class="el" href="../../d8/dc9/structtarget__ioreq.html">target_ioreq</a><ul>
<li>Struct dgmode_readvec will be reused to work for degraded mode write IO.</li>
<li>The routine <a class="el" href="../../d0/dec/m0t1fs_2linux__kernel_2file_8c.html#a43b79742346b98ca315a58d6a059e57d">target_ioreq_seg_add()</a> will be modified to accommodate pages belonging to use-case where repair has completed for given file and the pages belonging to failed device need to be diverted to appropriate spare unit in same parity group.</li>
</ul>
</li>
</ul>
</li>
<li>IO reply on-wire fop will be enhanced with a U64 field which will imply if SNS repair has completed for global fid in IO request fop or not. This field is only used in case of ongoing SNS repair. It is not used during healthy pool state.</li>
<li>End user is unaware of degraded mode write IO. It can be characterised by low IO throughput.</li>
</ul>
<h2><a class="anchor" id="rmw-dgwriteIO-limitations"></a>
rmw-dgwriteIO-limitations</h2>
<ul>
<li>Since degraded mode write IO requires distributed locks and distributed locks are not available yet, the implementation tries to stick to implement the business logic of degraded mode write IO. Since by using file granularity distributed locks, either SNS repair or write IO request will have exclusive access to given file at a time and hence this task tries to implement the business logic of degraded mode write IO <em>assuming</em> the distributed lock has been acquired on given file. Later when distributed locks are available in Motr, they will be incorporated in Motr client IO path and SNS repair code.</li>
<li>As is the case with every other subcomponent of m0t1fs, only XOR is supported at the moment. And it can recover only one failure in a storage pool at a time.</li>
</ul>
<h2><a class="anchor" id="rmw-dgwriteIO-conformance"></a>
rmw-dgwriteIO-conformance</h2>
<p><b>I.dg.mode.writeIO.consistency</b> In either of possible use-cases, write IO request will write enough data in parity group so that the data for lost device is either</p><ul>
<li>re-generated by SNS repair process (repair yet to happen on given file) OR</li>
<li>is available on spare units (repair completed for given file) This can be illustrated by having a subsequent read IO on same file extent which can confirm file contents are sane.</li>
</ul>
<p><b>I.dg.mode.writeIO.efficient</b> The implementation shall provide an async way of sending fops. All pages are aggregated and sent as one/more IO fops. Code is written in such a manner that normal IO requests are not affected by degraded mode functionality.</p>
<p><b>I.dg.mode.writeIO.dist_locks</b> The implementation shall use dummy calls for acquiring distributed locks since distributed locks are not yet available in Motr. Later when distributed locks are available in Motr, they will be incorporated in client IO code.</p>
<h2><a class="anchor" id="rmw-dgwriteIO-ut"></a>
rmw-dgwriteIO-ut</h2>
<p>The existing UT will be modified in order to accommodate tests for degraded mode write IO. The unit tests will focus on checking function level correctness, while ST will use different combinations of file sizes to be repaired in order to exercise degraded mode write IO code.</p>
<p>The ST especially can exercise the 2 use-cases mentioned in logical spec, </p><dl class="section see"><dt>See also</dt><dd>rmw-dgwriteIO-lspec.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000077">Test:</a></b></dt><dd>In order to exercise the use-case where SNS repair is yet to start on the file,<ul>
<li>Write 2 files, one which is sufficiently big in size (for instance, worth thousands of parity groups in size) and another which is smaller (worth one/two parity groups in size).</li>
<li>Keep a known data pattern in the smaller file which can be validated for correctness.</li>
<li>Write the big file first to m0t1fs and then the smaller one.</li>
<li>Start SNS repair manually by specifying failed device.</li>
<li>Repair will start in lexicographical order and will engage the bigger file first.</li>
<li>Issue a write IO request immediately (while repair is going on) on smaller file which will exercise the use-case of given file still to be repaired by SNS repair process.</li>
</ul>
</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000078">Test:</a></b></dt><dd>In order to exercise the use-case where SNS repair has completed for given file,<ul>
<li>Write 2 files, one which is sufficiently big in size (worth thousands of parity groups in size) and another which is smaller (worth one/two parity groups in size).</li>
<li>Keep a known data pattern in smaller file in order to verify the write IO later.</li>
<li>Write the smaller file first to m0t1fs and then the bigger one.</li>
<li>Start SNS repair manually by specifying failed device.</li>
<li>Repair will start in lexicographical order and will engage the smaller file first.</li>
<li>Issue a write IO request immediately (while repair is going on) on the smaller file which will exercise the use-case of given file being repaired by SNS repair.</li>
</ul>
</dd></dl>
<hr/>
 <h1><a class="anchor" id="rmw-conformance"></a>
Conformance</h1>
<ul>
<li><b>I.m0t1fs.rmw_io.rmw</b> The implementation maintains an io map per parity group in a data structure <a class="el" href="../../d0/d55/structpargrp__iomap.html">pargrp_iomap</a>. The io map rounds up/down the incoming io segments to nearest page boundaries. The missing data will be read first from data server (later from client cache which is missing at the moment and then from data server). Data is copied from user-space at desired file offsets and then it will be sent to server as a write IO request.</li>
<li><b>I.m0t1fs.rmw_io.efficient</b> The implementation uses an asynchronous way of waiting for IO requests and does not send the requests one after another as is done with current implementation. This leads in only one conditional wait instead of waits proportional to number of IO requests as is done with current implementation.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="rmw-ut"></a>
Unit Tests</h1>
<p>The UT will exercise following unit test scenarios. </p><dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000140">Todo:</a></b></dt><dd>However, with all code in kernel and no present UT code for m0t1fs, it is still to be decided how to write UTs for this component.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000079">Test:</a></b></dt><dd>Issue a full parity group size IO and check if it is successful. This test case should assert that full parity group IO is intact with new changes.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000080">Test:</a></b></dt><dd>Issue a partial parity group read IO and check if it successful. This test case should assert the fact that partial parity group read IO is working properly.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000081">Test:</a></b></dt><dd>Issue a partial parity group write IO and check if it is successful. This should confirm the fact that partial parity group write IO is working properly.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000082">Test:</a></b></dt><dd>Write very small amount of data (10 - 20 bytes) to a newly created file and check if it is successful. This should stress 2 boundary conditions<ul>
<li>a partial parity group write IO request and</li>
<li>unavailability of all data units in a parity group. In this case, the non-existing data units will be assumed as zero filled buffers and the parity will be calculated accordingly.</li>
</ul>
</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000083">Test:</a></b></dt><dd>Kernel mode fault injection can be used to inject failure codes into IO path and check for results.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000084">Test:</a></b></dt><dd>Test read-rest test case. If io request spans a parity group partially, and reading the rest of parity group units is more economical (in terms of io requests) than reading the spanned extent, the feature will read rest of parity group and calculate new parity. For instance, in an 8+1+1 layout, first 5 units are overwritten. In this case, the code should read rest of the 3 units and calculate new parity and write 9 pages in total.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000085">Test:</a></b></dt><dd>Test read-old test case. If io request spans a parity group partially and reading old units and calculating parity <em>iteratively</em> is more economical than reading whole parity group, the feature will read old extent and calculate parity iteratively. For instance, in an 8+1+1 layout, first 2 units are overwritten. In this case, the code should read old data from these 2 units and old parity. Then parity is calculated iteratively and 3 units (2 data + 1 parity) are written.</dd></dl>
<hr/>
 <h1><a class="anchor" id="rmw-st"></a>
System Tests</h1>
<p>A bash script will be written to send partial parity group IO requests in loop and check the results. This should do some sort of stress testing for the code.</p>
<hr/>
 <h1><a class="anchor" id="rmw-O"></a>
Analysis</h1>
<p>Only one <a class="el" href="../../d6/d09/structio__request.html">io_request</a> structure is created for every system call. Each IO request creates sub requests proportional to number of blocks addressed by io vector. Number of IO fops created is also directly proportional to the number of data buffers.</p>
<hr/>
 <h1><a class="anchor" id="rmw-ref"></a>
References</h1>
<ul>
<li>Detailed level design HOWTO (an older document on which this style guide is partially based) : For documentation links, please refer to this file : doc/motr-design-doc-list.rst </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d3/dd6/_d_l_d_i_x.html">Detailed Designs</a></li>
    <li class="footer">Generated on Thu Apr 14 2022 14:03:25 for Motr by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
