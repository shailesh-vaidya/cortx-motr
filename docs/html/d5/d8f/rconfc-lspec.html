<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Motr: rconfc Internals</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Motr
   &#160;<span id="projectnumber">M0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d5/d8f/rconfc-lspec.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">rconfc Internals </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="../../d5/d8f/rconfc-lspec.html#rconfc-lspec-sm">Rconfc state machine</a></li>
<li><a class="el" href="../../d5/d8f/rconfc-lspec.html#rconfc-lspec-entrypoint">Request cluster entry point from HA</a></li>
<li><a class="el" href="../../d5/d8f/rconfc-lspec.html#rconfc-lspec-rlock">Read Lock Acquisition and Revocation</a></li>
<li><a class="el" href="../../d5/d8f/rconfc-lspec.html#rconfc-lspec-elect">Version Election and Quorum</a></li>
<li><a class="el" href="../../d5/d8f/rconfc-lspec.html#rconfc-lspec-ha-notification">Processing HA notifications</a></li>
<li><a class="el" href="../../d5/d8f/rconfc-lspec.html#rconfc-lspec-gate">Gating confc operations</a><ul>
<li><a class="el" href="../../d5/d8f/rconfc-lspec.html#rconfc-lspec-gate-check">Blocking confc context initialisation</a></li>
<li><a class="el" href="../../d5/d8f/rconfc-lspec.html#rconfc-lspec-gate-drain">Cleaning confc cache data</a></li>
<li><a class="el" href="../../d5/d8f/rconfc-lspec.html#rconfc-lspec-gate-skip">Reconnecting confc to another confd</a></li>
</ul>
</li>
<li><a class="el" href="../../d5/d8f/rconfc-lspec.html#rconfc-lspec-clean">Cleaning configuration cache during stopping.</a></li>
<li><a class="el" href="../../db/d90/group__rconfc__dlspec.html">Detailed Logical Specification</a></li>
</ul>
<hr/>
 <h1><a class="anchor" id="rconfc-lspec-sm"></a>
Rconfc state machine</h1>
<div class="dotgraph">
<img src="../../dot_inline_dotgraph_12.png" alt="dot_inline_dotgraph_12.png" border="0" usemap="#dot_inline_dotgraph_12.map"/>
<map name="dot_inline_dotgraph_12.map" id="dot_inline_dotgraph_12.map"></map>
</div>
<p>Color agenda: <br />
<b>green</b> - States during startup or reelection <br />
<b>pink</b> - Reelection-only states <br />
<b>dark</b> <b>grey</b> - Stopping states <br />
 After successful start rconfc is in M0_RCS_IDLE state, waiting for one of two events: read lock conflict or user request for stopping. These two events are handled only when rconfc is in M0_RCS_IDLE state. If rconfc was in other state, then a fact of the happened event is stored, but its handling is delayed until rconfc state is M0_RCS_IDLE.</p>
<p>If failure is occurred that prevents rconfc from functioning properly, then rconfc goes to M0_RCS_FAILURE state. SM in this state do nothing until user requests for stopping.</p>
<p>Rconfc internal state is protected by SM group lock. SM group is provided by user on rconfc initialisation.</p>
<hr/>
 <h1><a class="anchor" id="rconfc-lspec-entrypoint"></a>
Request cluster entry point from HA</h1>
<p>The first stage of rconfc startup is determining the entry point of motr cluster, which configuration should be accessed. The entry point consists of several components. All of them can be changed during cluster lifetime.</p>
<p>Cluster entry point includes:</p><ul>
<li>List of confd servers fids along with RPC endpoints.</li>
<li>Fid and RPC endpoint of active RM creditor that manages concurrent access to the cluster configuration database.</li>
<li>Quorum value. Minimum number of confd servers running the same configuration version number necessary to elect this version.</li>
</ul>
<p>HA subsystem is responsible for serving queries for current cluster entry point. Rconfc makes query to HA subsystem through a local HA agent.</p>
<p>It may happen that rconfc is not able to succeed with version election for some reason, (e.g. connection to active RM cannot be established, current set of confds reported by HA does not yield the quorum, etc.) In this case rconfc repeats entry point request to HA and attempts to elect version with the most recent entry point data set. There is no limit imposed on the number of attempts.</p>
<hr/>
 <h1><a class="anchor" id="rconfc-lspec-rlock"></a>
Read Lock Acquisition and Revocation</h1>
<p>During <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga30d22166cd72ba7dca127c14eac03e59">m0_rconfc_start()</a> execution rconfc requesting read lock from Resource Manager (RM) by calling <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga16c8369c9fad53c5462cc6ab62344861">rconfc_read_lock_get()</a>. On request completion <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga4be51742636b0f6ff44a580ae7bf51ed">rconfc_read_lock_complete()</a> is called. Successful lock acquisition indicates no configuration change is in progress and configuration reading is allowed.</p>
<p>The read lock is retained by rconfc instance until finalisation. But the lock can be revoked by RM in case a conflicting lock is requested. On the lock revocation <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga6a2400f11f2c3b99f33a9c75d9f57039">rconfc_read_lock_conflict()</a> is called. The call installs <a class="el" href="../../d9/dc4/structm0__confc__gate__ops.html#aeb156a820e7a88e2308b505a6e6a5261">m0_confc_gate_ops::go_drain()</a> callback to be notified when the last reading context is detached from <a class="el" href="../../d2/d9e/structm0__rconfc.html#ab4c2761f81f0911021207cfe20b75f22">m0_rconfc::rc_confc</a> instance. The callback ends in calling <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga6d2d56a2c120a4b78287f259e1e1940f">rconfc_gate_drain()</a> where rconfc starts conductor cache drain. In <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga10405ae0c820cb8345c75582142331d3">rconfc_conductor_drained()</a> rconfc eventually puts the read lock back to RM.</p>
<p>Being informed about the conflict, rconfc disallows configuration reading done via <a class="el" href="../../d2/d9e/structm0__rconfc.html#ab4c2761f81f0911021207cfe20b75f22">m0_rconfc::rc_confc</a> until the next read lock acquisition is complete. Besides, in <a class="el" href="../../db/d90/group__rconfc__dlspec.html#gafbd29751542858fde9e2d9c18184883f">rconfc_conductor_drain()</a> the mentioned confc's cache is drained to prevent consumer from reading cached-but-outdated configuration values. However, the cache data remains untouched and readable to the very moment when there is no cache object pinned anymore, and the last reading context detaches from the confc being in use.</p>
<p>When done with the cache, <a class="el" href="../../d2/d9e/structm0__rconfc.html#ab4c2761f81f0911021207cfe20b75f22">m0_rconfc::rc_confc</a> is disconnected from confd server to prevent unauthorized read operations. Then the conflicting lock is returned back to RM complying with the conflict request.</p>
<p>Immediately after revocation rconfc attempts to acquire read lock again. The lock will be granted once the conflicting lock is released.</p>
<hr/>
 <h1><a class="anchor" id="rconfc-lspec-elect"></a>
Version Election and Quorum</h1>
<p>In the course of <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga4be51742636b0f6ff44a580ae7bf51ed">rconfc_read_lock_complete()</a> under condition of successful read lock acquisition rconfc transits to M0_RCS_VERSION_ELECT state. It initialises every confc instance of the <a class="el" href="../../d2/d9e/structm0__rconfc.html#a69e11637e42c26204bc9123503b13495">m0_rconfc::rc_herd</a> list, attaches <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga84a1c8072034af774de0a84486e4c76a">rconfc__cb_quorum_test()</a> to its context and initiates asynchronous reading from the corresponding confd server. When version quorum is either reached or found impossible <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga9d1c8fb2df194543e51785b1d4ec9b69">rconfc_version_elected()</a> is called.</p>
<p>On every reading event <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga84a1c8072034af774de0a84486e4c76a">rconfc__cb_quorum_test()</a> is called. In case the reading context is not completed, the function returns zero value indicating the process to go on. Otherwise <a class="el" href="../../db/d90/group__rconfc__dlspec.html#gaf73a45fb232de3be09025947de009ad5">rconfc_quorum_test()</a> is called to see if quorum is reached with the last reply. If quorum is reached or impossible, then <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga9d1c8fb2df194543e51785b1d4ec9b69">rconfc_version_elected()</a> is called.</p>
<p>Quorum is considered reached when the number of confd servers reported the same version number is greater or equal to the value provided to <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga7371c86b0f8ffc8fd70016b1d6f39da2">m0_rconfc_init()</a>. In case zero value was provided, the required quorum number is automatically calculated as a half of confd server count plus one.</p>
<p>If quorum is reached, <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga70de144f1a092217192b3965ca3522b0">rconfc_conductor_engage()</a> is called connecting <a class="el" href="../../d2/d9e/structm0__rconfc.html#ab4c2761f81f0911021207cfe20b75f22">m0_rconfc::rc_confc</a> with a confd server from active list. Starting from this moment configuration reading is allowed until read lock is revoked.</p>
<p>If quorum was not reached, rconfc repeats request to HA about entry point information and starts new version election with the most recent entry point data set.</p>
<hr/>
 <h1><a class="anchor" id="rconfc-lspec-ha-notification"></a>
Processing HA notifications</h1>
<p>Rconfc is interested in the following notifications from HA:</p><ul>
<li>Permanent failure of active RM creditor.</li>
<li>Permanent failure of one of confd servers from the herd.</li>
</ul>
<p>In order to receive these notifications rconfc creates phony confc (<a class="el" href="../../d2/d9e/structm0__rconfc.html#a039d62f869807abc018c5241025ec803">m0_rconfc::rc_phony</a>) and adds fake objects for RM creditor service and confd services upon receiving cluster entry point. Using general non-phony confc instance is not possible, because configuration version election isn't done to that moment.</p>
<p>Actions performed on RM creditor death:</p><ul>
<li>If read lock is not acquired yet, then rconfc restarts election process from requesting cluster entry point. HA subsystem is expected to return information about newly chosen active RM creditor or an error if it was unable to choose one. Please note that if HA subsystem constantly returns already dead RM creditor, then rconfc will go to infinite loop.</li>
<li>If read lock is held by rconfc, then RM creditor death is observed by checking local owner state in <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga6a2400f11f2c3b99f33a9c75d9f57039">rconfc_read_lock_conflict()</a>. The thing is that local owner also tracks changes in RM creditor HA state (see <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga53d533a0b549a31214e4b2f94cadd38d">rlock_ctx_creditor_setup()</a>). On RM creditor death owner goes to ROS_QUIESCE state and calls conflict callbacks for all held credits. Rconfc unsets local owner creditor and restarts election process in order to receive newly chosen creditor from HA.</li>
</ul>
<p>Actions performed on death of confd server from herd:</p><ul>
<li>Drop connection.</li>
<li>Finalise internal confc.</li>
<li>Mark herd link as CONFC_DEAD, so this confd doesn't participate in possible confd switch (see <a class="el" href="../../d5/d8f/rconfc-lspec.html#rconfc-lspec-gate-skip">Reconnecting confc to another confd</a>).</li>
</ul>
<p>Death notification is basically handled by <a class="el" href="../../da/dec/structrconfc__link.html#a2bc849cc43d94eaec847de799812331f">rconfc_link::rl_fom</a> that is queued from <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga613bd36b238273c84550c83970abd750">rconfc_herd_link__on_death_cb()</a>. The FOM is intended to safely disconnect herd link from problematic confd when session and connection termination may be timed out. The FOM prevents client's locality from being blocked for a noticeably long time.</p>
<pre class="fragment">                                    |  m0_fom_init()
      !m0_confc_is_inited() ||      |  m0_fom_queue()
      !m0_confc_is_online()         V
   +--------------------------- M0_RLF_INIT
   |                                |
   |                                |  wait for M0_RPC_SESSION_IDLE
   |                                V
   +---------------------- M0_RLF_SESS_WAIT_IDLE
   |                                |
   |                                |  m0_rpc_session_terminate()
   |                                V
   +---------------------- M0_RLF_SESS_TERMINATING
   |                                |  m0_rpc_session_fini()
   |                                |  m0_rpc_conn_terminate()
   |                                V
   +---------------------- M0_RLF_CONN_TERMINATING
   |                                |  m0_rpc_conn_fini()
   |                                V
   +---------------------------&gt;M0_RLF_FINI
                                    |  m0_fom_fini()
                                    |  rconfc_herd_link_fini()
                                    V
</pre><dl class="section attention"><dt>Attention</dt><dd>Currently HA notifications processing doesn't take "conductor" confc into account. This confc instance is separated from those used in herd and is not affected even if death of confd server it communicates with is observed. It is assumed that RPC eventually will return an error and "conductor" confc will be reconnected to another confd.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There are no special HA notifications about the fact that confd servers list has changed. In order to make rconfc logic correct in such case the following behaviour is expected from HA:<ul>
<li>Confd server can't be excluded from list without prior HA notification about permanent failure of this confd server. Rconfc will receive this notification and will stop working with it.</li>
<li>Confd server can't be added to the list without prior configuration database update, that adds this service to database. Rconfc will observe read lock conflict and eventually will restart election process, thus obtaining updated confd list.</li>
</ul>
</dd></dl>
<hr/>
 <h1><a class="anchor" id="rconfc-lspec-gate"></a>
Gating confc operations</h1>
<h2><a class="anchor" id="rconfc-lspec-gate-check"></a>
Blocking confc context initialisation</h2>
<p>Rconfc performs gating read operations conducted through the confc instance governed by the rconfc, i.e. <a class="el" href="../../d2/d9e/structm0__rconfc.html#ab4c2761f81f0911021207cfe20b75f22">m0_rconfc::rc_confc</a>. When read lock is acquired by rconfc, the reading is allowed. To be allowed to go on with reading, <a class="el" href="../../d5/d25/group__confc__dlspec.html#ga91bf72b4f1a8aac4121111c141d804d4">m0_confc_ctx_init()</a> performs checking by calling previously set callback m0_confc::cc_gops::go_check(), that in fact is <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga48a6563ca33bd47c6b032ff32aaef819">rconfc_gate_check()</a>.</p>
<p>With the read lock revoked inside <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga48a6563ca33bd47c6b032ff32aaef819">rconfc_gate_check()</a> rconfc blocks any <a class="el" href="../../d5/d25/group__confc__dlspec.html#ga91bf72b4f1a8aac4121111c141d804d4">m0_confc_ctx_init()</a> calls done with this particular <a class="el" href="../../d2/d9e/structm0__rconfc.html#ab4c2761f81f0911021207cfe20b75f22">m0_rconfc::rc_confc</a>. On next successful read lock acquisition all the previously blocked contexts get unblocked. Once being allowed to read, the context can be used as many times as required.</p>
<div class="mscgraph">
<img src="../../msc_inline_mscgraph_1.png" alt="msc_inline_mscgraph_1" border="0" usemap="#msc_inline_mscgraph_1.map"/>
<map name="msc_inline_mscgraph_1.map" id="msc_inline_mscgraph_1.map"></map>
</div>
<p><br />
</p><center> <b>Diag.1</b>: <b>"Reading allowed at the moment of context initialisation"</b> </center><p><br />
</p>
<div class="mscgraph">
<img src="../../msc_inline_mscgraph_2.png" alt="msc_inline_mscgraph_2" border="0" usemap="#msc_inline_mscgraph_2.map"/>
<map name="msc_inline_mscgraph_2.map" id="msc_inline_mscgraph_2.map"></map>
</div>
<p><br />
</p><center> <b>Diag.2</b>: <b>"Reading disallowed at the moment of context initialisation"</b> </center><p><br />
</p>
<div class="mscgraph">
<img src="../../msc_inline_mscgraph_3.png" alt="msc_inline_mscgraph_3" border="0" usemap="#msc_inline_mscgraph_3.map"/>
<map name="msc_inline_mscgraph_3.map" id="msc_inline_mscgraph_3.map"></map>
</div>
<p><br />
</p><center> <b>Diag.3</b>: <b>"Reading remains disallowed because of
               RM communication failure"</b> </center><p><br />
</p>
<h2><a class="anchor" id="rconfc-lspec-gate-drain"></a>
Cleaning confc cache data</h2>
<p>When new configuration change is in progress, and therefore, read lock is revoked, <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga6a2400f11f2c3b99f33a9c75d9f57039">rconfc_read_lock_conflict()</a> defers cache draining until there is no reading context attached. It installs m0_confc::cc_gops::go_drain() callback, that normally remains set to NULL and this way does not affect execution of <a class="el" href="../../d5/d25/group__confc__dlspec.html#ga56b93a0699b96051fc7430fd0ce40286">m0_confc_ctx_fini()</a> anyhow. But with the callback set up, at the moment of the very last detach <a class="el" href="../../d5/d25/group__confc__dlspec.html#ga56b93a0699b96051fc7430fd0ce40286">m0_confc_ctx_fini()</a> calls m0_confc::cc_gops::go_drain() callback, that in fact is <a class="el" href="../../db/d90/group__rconfc__dlspec.html#ga6d2d56a2c120a4b78287f259e1e1940f">rconfc_gate_drain()</a>, where cache cleanup is finally invoked by setting M0_RCS_CONDUCTOR_DRAIN state. Rconfc SM remains in M0_RCS_CONDUCTOR_DRAIN_CHECK state until all conf objects are unpinned. Once there are no pinned objects, rconfc cleans cache, put read lock and starts reelection process.</p>
<div class="mscgraph">
<img src="../../msc_inline_mscgraph_4.png" alt="msc_inline_mscgraph_4" border="0" usemap="#msc_inline_mscgraph_4.map"/>
<map name="msc_inline_mscgraph_4.map" id="msc_inline_mscgraph_4.map"></map>
</div>
<p><br />
</p><center> <b>Diag.4</b>: <b>"Deferred Cache Cleanup"</b> </center><p><br />
</p>
<dl class="section note"><dt>Note</dt><dd>Forced cache draining occurs when <a class="el" href="../../d9/dc4/structm0__confc__gate__ops.html#aeb156a820e7a88e2308b505a6e6a5261">m0_confc_gate_ops::go_drain</a> callback is installed, which happens only when reading is not allowed. Normally the callback is set to NULL, and therefore, confc cache remains unaffected during <a class="el" href="../../d5/d25/group__confc__dlspec.html#ga56b93a0699b96051fc7430fd0ce40286">m0_confc_ctx_fini()</a>.</dd></dl>
<h2><a class="anchor" id="rconfc-lspec-gate-skip"></a>
Reconnecting confc to another confd</h2>
<p>In case configuration reading fails because of network error, the confc context requests the confc to skip its current connection to confd and switch to some other confd server running the same version. This is done inside state machine being in S_SKIP_CONFD state by calling callback function m0_confc::cc_gops::go_skip() that in fact is <a class="el" href="../../db/d90/group__rconfc__dlspec.html#gac8c940d5b7f0e986c57a91a2f0ff99f2">rconfc_gate_skip()</a>. The function iterates through the <a class="el" href="../../d2/d9e/structm0__rconfc.html#a872684e3cec2c2b47fee89f99b86f038">m0_rconfc::rc_active</a> list and returns on the first successful connection established. In case of no success, the function returns with -ENOENT making the state machine end in S_FAILURE state.</p>
<dl class="section note"><dt>Note</dt><dd>As long as confc is switched to confd of the same version number, the cache data remains valid and needs no special attendance.</dd></dl>
<h2><a class="anchor" id="rconfc-lspec-clean"></a>
Cleaning configuration cache during stopping.</h2>
<p>When rconfc is stopping, it scans configuration for pinned objects (i. e. objects with <a class="el" href="../../df/da6/structm0__conf__obj.html#a55f887d4c660e091768919fa3441d8e5">m0_conf_obj::co_nrefs</a> &gt; 0). If such object is found then rconfc waits until it will be unpinned by a configuration consumer. The consumer must be subscribed to m0_reqh::rh_confc_cache_expired chan and put its pinned objects in the callback registered with this chan. When all configuration objects become unpinned, rconfc is able to clean configuration cache and go to M0_RCS_FINAL state. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d3/dd6/_d_l_d_i_x.html">Detailed Designs</a></li><li class="navelem"><a class="el" href="../../d2/dd9/conf.html">DLD of configuration caching</a></li>
    <li class="footer">Generated on Fri May 20 2022 10:35:31 for Motr by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
