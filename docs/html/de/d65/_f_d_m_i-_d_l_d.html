<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Motr: FDMI Detailed Design</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Motr
   &#160;<span id="projectnumber">M0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('de/d65/_f_d_m_i-_d_l_d.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">FDMI Detailed Design </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-ovw">Overview</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-def">Definitions</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-req">Requirements</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-depends">Dependencies</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-highlights">Design Highlights</a></li>
<li><a class="el" href="../../de/d0a/_f_d_m_i-_d_l_d-fspec.html">Functional Specification</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec">Logical Specification</a><ul>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-comps">Component Overview</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-service">FDMI service</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-source">FDMI source</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-source-dock">FDMI Source Dock</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-filter">FDMI Filter</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-plugin-dock">FDMI Plugin dock</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-numa">NUMA optimizations</a></li>
</ul>
</li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-conformance">Conformance</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-ut">FDMI Unit Tests</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-st">System Tests</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-O">Analysis</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-ref">References</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-impl-plan">Implementation Plan</a></li>
</ul>
<h1><a class="anchor" id="FDMI-DLD-ovw"></a>
Overview</h1>
<p>The document is intended to specify the detailed level design for of Motr FDMI interface. FDMI is a part of Motr product. FDMI provides interface for Motr plugins and allows Motr scale horizontally extending the features and capabilities of the system.</p>
<h1><a class="anchor" id="FDMI-DLD-def"></a>
Definitions</h1>
<ul>
<li>FDMI - File data manipulation interface</li>
<li>FDMI source - Motr entity that provides data to be distributed</li>
<li>FDMI plugin - An application that uses FDMI API to access Motr source data</li>
<li>FDMI source dock - FDMI subsystem responsible for handling FDMI records, posted by source</li>
<li>FDMI plugin dock - FDMI subsystem responsible for providing FDMI API to plugin application</li>
<li>FDMI record - FDMI data, posted by source.</li>
<li>FDMI record type - FDMI entity that clearly defines FDMI data type. FDMI source provides records of a particular type.</li>
<li>FDMI filter - Set of rules, defined by plugin, to filter out FDMI records.</li>
</ul>
<h1><a class="anchor" id="FDMI-DLD-req"></a>
Requirements</h1>
<p>The requirements are fully described in <a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-ref-HLD">[0]</a> <b>TBD</b> </p>
<h1><a class="anchor" id="FDMI-DLD-depends"></a>
Dependencies</h1>
<p><b>TBD</b> </p>
<h1><a class="anchor" id="FDMI-DLD-highlights"></a>
Design Highlights</h1>
<p><b>TBD</b> </p>
<h1><a class="anchor" id="FDMI-DLD-lspec"></a>
Logical Specification</h1>
<ul>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-comps">Component Overview</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-service">FDMI service</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-source">FDMI source</a><ul>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-source-impl">FDMI source implementation guideline</a></li>
</ul>
</li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-source-dock">FDMI Source Dock</a><ul>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-source-reg">FDMI source registration</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-source-rec-post">FDMI record post</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-source-source-dock-fom">FDMI source dock FOM</a></li>
</ul>
</li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-filter">FDMI Filter</a><ul>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-filter-d">FDMI filterD</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-filter-c">FDMI filterC</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-filter-evaluator">FDMI filter evaluator</a></li>
</ul>
</li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-plugin-dock">FDMI Plugin dock</a><ul>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-plugin-dock-reg">FDMI plugin registration</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-plugin-dock-papi">FDMI plugin dock private API</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-plugin-dock-fom">FDMI plugin dock FOM Received</a></li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-plugin-impl">FDMI plugin implementation guideline</a></li>
</ul>
</li>
<li><a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-numa">NUMA optimizations</a></li>
</ul>
<h2><a class="anchor" id="FDMI-DLD-lspec-comps"></a>
Component Overview</h2>
<p>FDMI consists of the following components:</p><ul>
<li>FDMI service</li>
<li>FDMI source</li>
<li>FDMI source dock</li>
<li>FDMI plugin dock</li>
</ul>
<h2><a class="anchor" id="FDMI-DLD-lspec-fdmi-service"></a>
FDMI service</h2>
<p>FDMI service runs as a part of Motr instance. FDMI service stores context data for both FDMI source dock and FDMI plugin dock. FDMI service is initialized and started on Motr instance start up, FDMI Source dock and FDMI plugin dock are both initialised on the service start unconditionally.</p>
<h3><a class="anchor" id="FDMI-DLD-lspec-fdmi-source"></a>
FDMI source</h3>
<p>FDMI source instance main task is to post FDMI records of a specific type to FDMI source dock for further analysis, Only 1 FDMI source instance with a specific type should be registered in a Motr process: FDMI record type uniquely identifies FDMI source instance. A list of FDMI record types (<a class="el" href="../../d3/d97/group__fdmi__main.html#gab788ad97d572d213db9a8b9a9fe1dd83">m0_fdmi_rec_type_id</a>): - FOL record type - ADDB record type - TBD</p>
<p>FDMI source instance provides the following interface functions for FDMI source dock to handle FDMI records:</p><ul>
<li>Get source specific value, <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#a13b2f44322ed4d40626f4f1d8d8f9333">m0_fdmi_src::fs_node_eval()</a></li>
<li>Increase record reference counter, <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#a03c0ea9e9e7b2560728f099e93452166">m0_fdmi_src::fs_get()</a></li>
<li>Decrease record reference counter, <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#aa817fb1f3cc307fd41d5e7f9a650d7de">m0_fdmi_src::fs_put()</a></li>
<li>FDMI record processing start, <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#ac672f4b5c1a9b1838d689d69647e46cd">m0_fdmi_src::fs_begin()</a></li>
<li>FDMI record processing complete, <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#a6fc401f6e8f472066f4b2e5ab36cb7bb">m0_fdmi_src::fs_end()</a></li>
</ul>
<p>FDMI source provides records of specific FDMI record type m0_fdmi_rec_type. FDMI record type is identified by id <a class="el" href="../../d3/d97/group__fdmi__main.html#gab788ad97d572d213db9a8b9a9fe1dd83">m0_fdmi_rec_type_id</a>. FDMI source provides Xcode functions <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#a106295ea30b6a88e898dd7531457e9b2">m0_fdmi_src::fs_encode()</a> and <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#adb45303d2b805910e7c0a5c33fb8321b">m0_fdmi_src::fs_decode()</a>.</p>
<h3><a class="anchor" id="FDMI-DLD-lspec-fdmi-source-impl"></a>
FDMI source implementation guideline</h3>
<p>FDMI source implementation depends on data domain. Specific FDMI source type stores</p><ul>
<li>FDMI generic source interface <a class="el" href="../../d8/d9c/structm0__fdmi__src.html">m0_fdmi_src</a></li>
<li>FDMI specific source context data (source private data)</li>
</ul>
<p>FDMI Source must:</p><ul>
<li>define FDMI record type ID (see <a class="el" href="../../d3/d97/group__fdmi__main.html#gab788ad97d572d213db9a8b9a9fe1dd83">m0_fdmi_rec_type_id</a>)</li>
<li>implement record type operations (see <a class="el" href="../../d8/d9c/structm0__fdmi__src.html">m0_fdmi_src</a>)</li>
<li>implement required FDMI callbacks (see <a class="el" href="../../d8/d9c/structm0__fdmi__src.html">m0_fdmi_src</a> for list of callbacks)</li>
<li>allocate source structure with <a class="el" href="../../d0/de2/group__fdmi__sd.html#gaee22134bd7d1ff475f7f01532e9704a2">m0_fdmi_source_alloc()</a> call</li>
<li>register it with FDMI (call to <a class="el" href="../../d0/de2/group__fdmi__sd.html#ga421c5e68bc554fcc0b0e892c4a65e204">m0_fdmi_source_register()</a>, pass on source)</li>
<li>post FDMI records using the callback returned by <a class="el" href="../../d0/de2/group__fdmi__sd.html#ga421c5e68bc554fcc0b0e892c4a65e204">m0_fdmi_source_register()</a> &ndash; see <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#a42eba24a3ad0d88b65dabffa01684460">m0_fdmi_src::fs_record_post()</a>, m0_fdmi_src_dock_pops::fdmi_post_record. It's recommended to use macro <a class="el" href="../../d0/de2/group__fdmi__sd.html#ga96777865fe2c0169014d252b4849e172">M0_FDMI_SOURCE_POST_RECORD()</a> for that.</li>
<li>deregister the source with FDMI on finalisation using <a class="el" href="../../d0/de2/group__fdmi__sd.html#ga3d5ce259696db7f15eb2b756d5a80b8e">m0_fdmi_source_deregister()</a></li>
<li>free the allocated source structure with <a class="el" href="../../d0/de2/group__fdmi__sd.html#ga62f14a451b9a0256efdc7d29843dd65e">m0_fdmi_source_free()</a></li>
</ul>
<p>To pass FDMI record to FDMI source dock, API uses pointer to <a class="el" href="../../d4/d48/structm0__fdmi__src__rec.html">m0_fdmi_src_rec</a>. The source must include this struct as a member of some other structure (preferrably the one which contains the data of the record itself) &ndash; for example, for FOL source, the struct is embedded into FOL record, <a class="el" href="../../d5/d12/structm0__fol__rec.html">m0_fol_rec</a>. Later on, source dock will pass the pointer back in all the calls, and source will be able to use container_of to obtain the pointer to ambient structure, and perform the operations required. Source must make sure that the structure is NOT deallocated before source dock calls the last <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#aa817fb1f3cc307fd41d5e7f9a650d7de">m0_fdmi_src::fs_put()</a> &ndash; otherwise it will lead to a crash.</p>
<p>Now, workflow for a single FDMI record:</p><ul>
<li>Source: issues post-record callback, passes on a pointer to src_rec.</li>
<li>FDMI: saves the pointer in internal queue of records to be processed.</li>
<li>Source: increases ref counter on this record (will be released later on by FDMI).</li>
<li>... some time passes,</li>
<li>FDMI worker picks this record from the queue and starts processing.</li>
<li>FDMI calls <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#ac672f4b5c1a9b1838d689d69647e46cd">m0_fdmi_src::fs_begin()</a> &ndash; this is an indicator to the source that it's time to cache the record in memory for fast access.</li>
<li>FDMI starts filter evaluation, and will repeatedly call <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#a13b2f44322ed4d40626f4f1d8d8f9333">m0_fdmi_src::fs_node_eval()</a> for each filter.</li>
<li>for each matched filter, FDMI will call <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#a03c0ea9e9e7b2560728f099e93452166">m0_fdmi_src::fs_get()</a>, and send the record to the plugin.</li>
<li>Once all filters are processed, FDMI calls <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#aa817fb1f3cc307fd41d5e7f9a650d7de">m0_fdmi_src::fs_put()</a> to balance fs_get().</li>
<li>At some moment between fs_begin() and fs_end(), FDMI will call <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#a106295ea30b6a88e898dd7531457e9b2">m0_fdmi_src::fs_encode()</a> (possibly multiple times) to generate serialized representation of this given record.</li>
<li><p class="startli">Once all filters are processed, and encoding compete, FDMI calls <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#a6fc401f6e8f472066f4b2e5ab36cb7bb">m0_fdmi_src::fs_end()</a>, which is an indicator to the source that record data is no longer needed in memory and can be saved in "slow" storage (no more fs_node_eval() or fs_encode() calls).</p>
<dl class="section note"><dt>Note</dt><dd>If source supports transactions and re-sending, record cannot be completely discarded until all plugins replied with 'release'.</dd></dl>
</li>
<li>... some time passes</li>
<li>When done with record processing, plugins, independent from each other, post a 'release' request to source that originally produced the precessed FDMIrecord. For each 'release', FDMI calls <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#aa817fb1f3cc307fd41d5e7f9a650d7de">m0_fdmi_src::fs_put()</a>. Total count of dec_refc calls will match count of inc_refc calls. Once ref counter is zero the record can be completely discarded.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<ul>
<li>'Release' request needs to be not confused with regular RPC reply. The reply is sent immediately when FDMI record appears registered in receiving plugin dock. But 'release' request is issued to source when there remains no plugin having the record in process.</li>
<li>If record matched no filters, there will be only one fs_put() call, see above, and it will happen <em>before</em> fs_end() call.</li>
<li>During _fini phase, source dock will NOT call fs_end()/fs_put(). This way, source will have information on which records have to be resend on next startup. Note that source must NOT free these records before source dock _fini call &ndash; dock fini needs these records for finalization.</li>
</ul>
<hr/>
<p>For the moment FDMI FOL source is implemented as the 1st (and currently the only) FDMI source. FDMI FOL source provides ability for detailed FOL data analysis.</p>
<dl class="section note"><dt>Note</dt><dd>Algorithm described below is not implemented yet.</dd></dl>
<p>For FOL record specific data handling FDMI FOL record type is declared and registered for each specific FOL record type (example: write operation FOL record, set attributes FOL record, etc.)</p>
<p>FDMI FOL record type context stores the following:</p><ul>
<li>FOL operation code</li>
<li>FOL record interface</li>
</ul>
<p>On FDMI FOL record type FDMI record registration all its internals are initialized and saved as FDMI FOL record context data. Pointer to FDMI FOL record type is stored as a list in FDMI specific source context data.</p>
<h3><a class="anchor" id="FDMI-DLD-lspec-fdmi-source-dock"></a>
FDMI Source Dock</h3>
<p>FDMI Source dock (FDMI service), responsible for:</p><ul>
<li>Source registration</li>
<li>Retrieving/refreshing filter set for the source</li>
<li>Input data filtration</li>
<li>Deciding on and posting notifications to filter subscribers over Motr RPC</li>
<li>Deferred input data release</li>
</ul>
<h3><a class="anchor" id="FDMI-DLD-lspec-fdmi-source-reg"></a>
FDMI source registration</h3>
<p>On FDMI source registration all its internals are initialized and saved as FDMI generic source context data <a class="el" href="../../d3/dbb/structm0__fdmi__src__dock.html">m0_fdmi_src_dock</a>. Pointer to FDMI source instance is passed to FDMI source dock and saved in a list. In its turn, FDMI source dock provides back to FDMI source instance an interface function to perform FDMI record posting m0_fdmi_src_dock_pops. FDMI generic source context contains the following:</p><ul>
<li>FDMI record type</li>
<li>FDMI generic source interface</li>
<li>FDMI source dock interface</li>
</ul>
<p><a class="el" href="../../d8/d9c/structm0__fdmi__src.html">m0_fdmi_src</a> structure stores all FDMI generic source context data. It is populated on source side right after being allocated providing source specific callbacks, as well as on FDMI side during source registartion providing source dock private APIs. Registered FDMI sources are stored in the list <a class="el" href="../../d3/dbb/structm0__fdmi__src__dock.html#aa1abae55da3998104145f333e50e1105">m0_fdmi_src_dock::fsdc_src_list</a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/de2/group__fdmi__sd.html#ga421c5e68bc554fcc0b0e892c4a65e204">m0_fdmi_source_register()</a>.</dd></dl>
<h2><a class="anchor" id="FDMI-DLD-lspec-fdmi-source-rec-post"></a>
FDMI record post</h2>
<p>Source starts with local locking data to be fed to FDMI interface, then it calls posting FDMI API <a class="el" href="../../d0/de2/group__fdmi__sd.html#ga96777865fe2c0169014d252b4849e172">M0_FDMI_SOURCE_POST_RECORD()</a>. An argument to that post method is a pointer to <a class="el" href="../../d4/d48/structm0__fdmi__src__rec.html">m0_fdmi_src_rec</a>. This same pointer will be later used by source dock when calling back to issue operations on the record. The source will then need to trace the pointer back to the object which triggered the record post. The suggested method to achieve this is: embed the <a class="el" href="../../d4/d48/structm0__fdmi__src__rec.html">m0_fdmi_src_rec</a> into the same structure which caused the posting. Later on, when source dock calls back, source can use container_of to get original pointer to ambient structure and perform the operation.</p>
<p>So once record is posted, on FDMI side, the record is added to a waiting queue and assigned a record id. Posted FDMI records are stored in the list <a class="el" href="../../d3/dbb/structm0__fdmi__src__dock.html#a96689e7b7959e89e0403be446ad773a5">m0_fdmi_src_dock::fsdc_posted_rec_list</a>. Posted records are then handled by FDMI source dock FOM.</p>
<p>Record id is 128bit int (m0_int128). High part, u_hi, is set to <a class="el" href="../../d3/dbb/structm0__fdmi__src__dock.html#a689f33b3e81c1a2c8e853996a9ce726e">m0_fdmi_src_dock::fsdc_instance_id</a>. Lower part, u_lo, is set to a pointer value passed to <a class="el" href="../../d0/de2/group__fdmi__sd.html#ga96777865fe2c0169014d252b4849e172">M0_FDMI_SOURCE_POST_RECORD()</a> &ndash; see <a class="el" href="../../d6/dc3/group__fdmi__sd__int.html#gacc2caa412499b0d67e20f5882103842e">m0_fdmi__rec_id_gen()</a>. This way, the source dock does not need to keep any mapping structures &ndash; e.g. when 'release' comes in, and dock needs to call <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#aa817fb1f3cc307fd41d5e7f9a650d7de">m0_fdmi_src::fs_put()</a>, it will simply pass the u_lo as a pointer to <a class="el" href="../../d4/d48/structm0__fdmi__src__rec.html">m0_fdmi_src_rec</a>. To prevent issues on restart (e.g. source dock sends a record to plugin, then gets restarted, and then receives 'release' from plugin; takes u_lo and tries to dereference, and crashes since that pointer is no longer valid) &ndash; to prevent these issues, fsdc_instance_id must be a unique ID and it must change on each restart.</p>
<h2><a class="anchor" id="FDMI-DLD-lspec-fdmi-source-source-dock-fom"></a>
FDMI source dock FOM</h2>
<p>FDMI source dock FOM implements the main control flow for FDMI source dock:</p><ul>
<li>Takes out posted FDMI records</li>
<li>Examines filters</li>
<li>Sends notifications to FDMI plugins</li>
<li>Analyzes FDMI plugin responses</li>
</ul>
<p><b>Normal</b> <b>workflow</b> </p>
<p>FDMI source dock FOM remains in an idle state if no FDMI record is posted (FDMI record queue <a class="el" href="../../d3/dbb/structm0__fdmi__src__dock.html#a96689e7b7959e89e0403be446ad773a5">m0_fdmi_src_dock::fsdc_posted_rec_list</a> is empty). If any FDMI record is posted, the FOM switches to busy state, takes out FDMI record from a queue and starts analysis. Source dock informs the source on FDMI record analysis start using interface functioin <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#ac672f4b5c1a9b1838d689d69647e46cd">m0_fdmi_src::fs_begin()</a></p>
<p>Before examining against all the filters, FOM requests filter list from filterc. On getting filter list, FOM iterates through the filter list and examines filters one by one.</p>
<p>If no filter shows a match for the FDMI record, the record is released. To inform FDMI source that this record is no more needed for FDMI system, FDMI generic source interface function "decrease record reference counter" <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#aa817fb1f3cc307fd41d5e7f9a650d7de">m0_fdmi_src::fs_put()</a> is used.</p>
<p>If one or more filters match the FDMI record, the record is scheduled to be sent to a particular FDMI node(s). If several filters matched, the following operations are performed to optimize data flow:</p>
<ul>
<li>Send FDMI record only once to a particular FDMI node (filter provides RPC endpoint to communicate with).</li>
<li>Specify a list of matched filters, include only filters that are related to the node.</li>
<li>On receipt, FDMI plugin dock is responsible for dispatching received FDMI records and pass it to plugins according to specified matched filters list.</li>
</ul>
<p>In order to manage FDMI records transportation, the following information should be stored as FDMI source dock context information:</p>
<ul>
<li>Relation between destination Filter Id and FDMI record id being sent to the specified Filter ID<ul>
<li>Map &lt;Filter Id, FDMI record id&gt; may be used in this case</li>
<li>This information is needed to handle Corner case "Motr instance
  running FDMI plugin dock death"</li>
</ul>
</li>
</ul>
<p>FDMI record being sent is serialized using FDMI record type interface function "Xcode functions" (see <a class="el" href="../../d8/d9c/structm0__fdmi__src.html">m0_fdmi_src</a>)</p>
<p>On sending FDMI record its reference counter is increased: FDMI generic source interface function "increase record reference counter" <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#a03c0ea9e9e7b2560728f099e93452166">m0_fdmi_src::fs_get()</a> is used.</p>
<p>FDMI source dock increments internal FDMI record reference counter for the FDMI record being sent for each sending operation.</p>
<p>On FDMI record receipt, FDMI plugin dock should answer with a reply that is understood as a data delivery acknowledgement. The data acknowledgment should be sent as soon as possible.</p>
<p>On reply receive, internal FDMI record reference counter for the FDMI record is decremented in order to check if FDMI record notification is replied by all the plugins. If internal reference counter becomes 0, FDMI source is informed on record processing complete using API call <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#a6fc401f6e8f472066f4b2e5ab36cb7bb">m0_fdmi_src::fs_end()</a>. Then FDMI record is removed from the FDMI source dock communication context.</p>
<p>After FDMI record is handled by all involved plugins, FDMI plugin dock should send FDMI record release request to the FDMI record originator (FDMI source dock). On receiving this request, FDMI source dock removes appropriate pair &lt;Filter Id, FDMI record id&gt; from its context and informs FDMI source that the record is released. FDMI generic source interface function "decrease
record reference counter" <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#aa817fb1f3cc307fd41d5e7f9a650d7de">m0_fdmi_src::fs_put()</a> is used for this purpose. If FDMI source reference counter for a particular FDMI record becomes 0, FDMI source may release this FDMI record.</p>
<p>FDMI source dock normal workflow is described on the picture below.</p>
<div class="image">
<img src="../../../../fdmi/img/FDMI-source-dock--FDMI-FOM.png" alt="FDMI-source-dock--FDMI-FOM.png"/>
<div class="caption">
FDMI Source Dock FOM</div></div>
<p><b>Corner</b> <b>cases</b> </p>
<p>Special handling should be applied for the following corner cases:</p><ul>
<li>Motr instance running "FDMI plugin dock" death</li>
<li>FDMI filter is disabled Motr instance running "FDMI plugin dock" death may cause 2 cases:</li>
<li>RPC error while sending FDMI record to a FDMI source dock. No RPC reply received.</li>
<li>No "FDMI record release" request is received from FDMI plugin dock</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Corner cases handling needs HA support, not implemented now. For now they are handled using basic mechanisms like timeout, etc. Adding HA support allows handling them in a more straightforward way.</dd></dl>
<h2><a class="anchor" id="FDMI-DLD-lspec-fdmi-filter"></a>
FDMI Filter</h2>
<p>FDMI filter is a set of rules, defined by plugin, to filter out FDMI records. Filters are registered and propagated over Motr system using features and API provided by FilterC and FilterD subsystems.</p>
<h2><a class="anchor" id="FDMI-DLD-lspec-fdmi-filter-d"></a>
FDMI filterD</h2>
<p>FDMI plugin creates filter in order to specify criteria for FDMI records it is interested in. FDMI filter service (filterD) maintains central database of the FDMI filters existing in Motr cluster. There is only one (possibly duplicated) motr instance with filterD service in the whole Motr cluster. FilterD provides to users read/write access to its database via RPC requests.</p>
<p>FilterD service is started as a part of chosen for this purpose motr instance. Address of filterD service endpoint is stored in confd database. FilterD database is empty after cluster initialisation. The database won't be typically empty after filterD restart for any reason.</p>
<p>FilterD database is protected by a distributed read/write lock. When filterD database should be changed, filterD service acquires exclusive write lock from Resource Manager (RM), thus invalidating all read locks held by database readers. This mechanism is used to notify readers about filterD database changes, forcing them to re-read database content afterwards.</p>
<p>There are two types of filterD users:</p><ul>
<li>FDMI plugin dock (<a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-plugin-dock">FDMI Plugin dock</a>)</li>
<li>FDMI filter client (filterC) (<a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-filter-c">FDMI filterC</a>)</li>
</ul>
<p>FDMI filter description stored in database is represented by structure <a class="el" href="../../d4/db7/structm0__conf__fdmi__filter.html">m0_conf_fdmi_filter</a></p>
<p>FDMI plugin dock can issue following requests:</p><ul>
<li>Add filter with provided description</li>
<li>Remove filter by filter ID</li>
<li>Activate filter by filter ID</li>
<li>Deactivate filter by filter ID</li>
<li>Remove all filters by FDMI plugin dock RPC endpoint</li>
</ul>
<p>Also there are other events that cause some filters deactivation in database:</p><ul>
<li>HA notification about node death</li>
</ul>
<p>Filters stored in database are grouped by FDMI record type ID they are intended for. FilterC clients can issue following queries to filterD:</p><ul>
<li>Get all FDMI record type ID's known to filterD</li>
<li>Get all FDMI filters registered for specific FDMI record type ID</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Currently FilterD doesn't exist as a separate module, confd is used instead.</dd></dl>
<h2><a class="anchor" id="FDMI-DLD-lspec-fdmi-filter-c"></a>
FDMI filterC</h2>
<p>FilterC is a part of Motr instance that caches locally filters obtained from filterD. FilterC is initialized by FDMI source dock service at its startup. Also, filterC have a channel in its context which is signaled when some filter state is changed from enabled to disabled.</p>
<p>FilterC achieves local cache consistency with filterD database content by using distributed read/write lock mechanism. FilterD database change is the only reason for filterC local cache update. HA notifications about filter or node, running confd, death - are ignored by filterC.</p>
<dl class="section note"><dt>Note</dt><dd>Currently FilterC implementation is based on confc.</dd></dl>
<h2><a class="anchor" id="FDMI-DLD-lspec-fdmi-filter-evaluator"></a>
FDMI filter evaluator</h2>
<p>FDMI filter evaluator is responsible for filter expression calculation. Filter expression is defined in FDMI filter (<a class="el" href="../../d8/d01/structm0__fdmi__filter.html">m0_fdmi_filter</a>) and is represented either by:</p><ul>
<li>tree structure. FDMI filter evaluator traverses filter expression tree and calculates a result;</li>
<li>CAS pool and a substring for KV pair. FDMI filter checks if all of the substrings are present in value part of kv pair. The result is always boolean and indicates whether posted FDMI record notification matches against filter or not.</li>
</ul>
<h2><a class="anchor" id="FDMI-DLD-lspec-fdmi-plugin-dock"></a>
FDMI Plugin dock</h2>
<p>FDMI Plugin dock is responsible for:</p><ul>
<li>Plugin registration in FDMI instance</li>
<li>Filter registration in Motr Filter Database</li>
<li>Listening to notifications coming over RPC</li>
<li>Payload processing</li>
</ul>
<h2><a class="anchor" id="FDMI-DLD-lspec-fdmi-plugin-dock-reg"></a>
FDMI plugin registration</h2>
<p>There is no clearly defined procedure for plugin registration. The only mandatory step is obtaining <a class="el" href="../../de/d65/_f_d_m_i-_d_l_d.html#FDMI-DLD-lspec-fdmi-plugin-dock-papi">private plugin dock API</a>.</p>
<p>As long as FDMI record delivery is stipulated by record matching to certain filtering conditions plugin needs to register some set of filter definitions specific to plugin's operational logic. Plugin is free to register any subset of filter definitions any time it needs those be put in use.</p>
<p>Newly added filter definition remains inactive until being activated explicitly. Filter activation is a bulk operation allowing activate/deactivate some subset of filters at a time.</p>
<p>Unlike to its registration, plugin is expected to deregister all filter definitions it ever added during the current session.</p>
<h2><a class="anchor" id="FDMI-DLD-lspec-fdmi-plugin-dock-papi"></a>
FDMI plugin dock private API</h2>
<p>Private API provides the following functionality for plugin writers:</p><ul>
<li>register filter - registering single filter definition</li>
<li>enable filters - enabling/disabling a bunch of filter definitions</li>
<li>release fdmi rec - indicating the record can be released on source side</li>
<li>deregister plugin - unregistering all previously registered filter definitions</li>
</ul>
<p>The API is intended to be not used directly. Instead, it is obtained explicitly by plugin side using <a class="el" href="../../d4/d70/group__fdmi__pd.html#gae1df658f2c42afb1d5c406e9aa34a15b">m0_fdmi_plugin_dock_api_get()</a>.</p>
<dl class="section see"><dt>See also</dt><dd>struct m0_fdmi_pd_if </dd>
<dd>
<a class="el" href="../../d4/d70/group__fdmi__pd.html#gae1df658f2c42afb1d5c406e9aa34a15b">m0_fdmi_plugin_dock_api_get()</a></dd></dl>
<h2><a class="anchor" id="FDMI-DLD-lspec-fdmi-plugin-dock-fom"></a>
FDMI plugin dock FOM Received</h2>
<p>FDMI record goes directly to Plugin Dock's FOM. At this time incoming RPC connection endpoint address needs to be stored in communication context being associated with fdmi record id. Immediately on FOM initialisation step RPC reply is sent confirming fdmi record delivery.</p>
<p>Per filter id, corresponding plug-in is called feeding it with fdmi data, fdmi record id and filter id specific to the plug-in. Every successful plug-in feed results in incrementing fdmi record id reference counter. When done with the ids, FOM needs to test if at least a single feed succeeded. In case it was no success, i.e. there was not a single active filter encountered, or plug-ins never confirmed fdmi record acceptance, the fdmi record has to be released immediately.</p>
<p>Plug-in decides on its own when to report fdmi original record to be released by Source. It calls Plug-in Dock about releasing particular record identified by fdmi record id. In context of the call fdmi record reference counter is decremented locally, and in case the reference counter gets to 0, the corresponding Source is called via RPC to release the record (see Normal workflow, FDMI Source Dock: Release Request from Plug-in).</p>
<div class="image">
<img src="../../../../fdmi/img/FDMI-plugin-dock--On-FDMI-Record.png" alt="FDMI-plugin-dock--On-FDMI-Record.png"/>
<div class="caption">
FDMI plugin dock FOM</div></div>
<p> FOM being initialised prepares context for filter array iterative processing. On every iteration plugin is fed with the FDMI record along with current filter id. When done with the array, FOM deincrements record registration and finalises itself.</p>
<pre class="fragment">           |
           |
           V
      INITIALISED
           |
           |  pdock_fom_tick__init()
           |
           |
           |      /-------\
           |      |       |
           V      V       |
 FEED_PLUGINS_WITH_REC    |
           |              |
           | ++pf_pos     |  pf_pos &lt; fmf_count
           |              |
           |              |
           |              |
           |  pdock_fom_tick__feed_plugin_with_rec()
           |              |
           |              |
           +--------------/
           |
           |
           |  pf_pos == fmf_count
           |
           |
           |
           V
    FINISH_WITH_REC
           |
           |
           |
           |  pdock_fom_tick__finish_with_rec()
           |
           |
           V
       FINALISED</pre><h2><a class="anchor" id="FDMI-DLD-lspec-fdmi-plugin-impl"></a>
FDMI plugin implementation guideline</h2>
<p>The main logic behind making use of a FDMI plug-in is a subscription to some events in sources that comply with conditions described in filters that plug-in registers at its start. In case some source record matches with at least one filter, the source-originated record is routed to corresponding plug-in.</p>
<p>Plug-in responsibilities</p>
<p>During standard initialization workflow plug-in:</p><ul>
<li>Obtains private Plug-in Dock callback interface</li>
<li><p class="startli">Registers set of filters, where filter definition:</p><ul>
<li>Identifies FDMI record type to be watched</li>
<li>Provides filter id value unique across entire Motr cluster</li>
<li>Provides plug-in callback interface</li>
<li>Provides description of condition(s) the source record to meet to invoke notification</li>
</ul>
<p class="startli">During active subscription workflow looks like following:</p><ul>
<li>Plug-in is called back with:<ul>
<li>FDMI record id</li>
<li>FDMI record data</li>
<li>Filter id indicating the filter that signaled during the original source record processing</li>
</ul>
</li>
<li>Plug-in must keep trace of FDMI record (identified by FDMI record id globally unique across the Motr cluster) during its internal processing.</li>
<li>Plug-in must return from the callback as quick as possible to not block other callback interfaces from being called. Plug-in writers must take into account the fact that several plug-ins may be registered simultaneously, and therefore, must do their best to provide smooth cooperation among those.</li>
<li>However plug-in is allowed to take as much time as required for FDMI record processing. During the entire processing the FDMI record remains locked in its source.</li>
<li>When done with the record, plug-in is responsible for the record release.</li>
<li>Plug-in is allowed to activate/deactivate any subset of its registered filters. The decision making is entirely on plug-in's side.</li>
<li>The same way plug-in is allowed to de-register and quit any time it wants. The decision making is again entirely on plug-in's side. After de-registering itself the plug-in is not allowed to call private FDMI Plug-in Dock in part of filter activation/deactivation as well as fdmi record releasing. The said actions become available only after registering filter set another time.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="FDMI-DLD-lspec-numa"></a>
NUMA optimizations</h2>
<p><b>TBD</b> </p>
<hr/>
 <h1><a class="anchor" id="FDMI-DLD-conformance"></a>
Conformance</h1>
<p><b>TBD</b> </p>
<hr/>
 <h1><a class="anchor" id="FDMI-DLD-ut"></a>
FDMI Unit Tests</h1>
<ul>
<li>Verify FDMI source dock</li>
<li>Verify FDMI plugin dock</li>
<li>Verify FDMI filter subsystem</li>
<li>Verify FOL FDMI source implementation</li>
<li>Verify FDMI Connection Pool module</li>
</ul>
<h2><a class="anchor" id="FDMI-DLD-ut-fdmi-sd"></a>
FDMI source dock unit tests</h2>
<ul>
<li>Source dock<ul>
<li>Verify registering/deregistering sources in source dock</li>
<li>Verify FDMI record posting interface</li>
<li>Verify registered source callbacks are called in right order and with right arguments</li>
</ul>
</li>
<li>Source dock FOM<ul>
<li>Verify FOM start/stop</li>
<li>Verify FOM fetches posted FDMI records</li>
<li>Verify FOM acquire necessary filters from FilterC and apply them to FDMI records being processed</li>
<li>Verify that if filter is matched, then FDMI record is sent to plugin dock over RPC</li>
</ul>
</li>
<li>Source dock release FOM<ul>
<li>FOM is created on 'Release FDMI record notification' FOP</li>
<li>Registered source callback for decrementing reference counter is called</li>
</ul>
</li>
</ul>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000012">Test:</a></b></dt><dd><a class="el" href="../../d0/de2/group__fdmi__sd.html#ga421c5e68bc554fcc0b0e892c4a65e204">m0_fdmi_source_register()</a> assigns correct private callbacks (see <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#a42eba24a3ad0d88b65dabffa01684460">m0_fdmi_src::fs_record_post()</a>)</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000013">Test:</a></b></dt><dd><a class="el" href="../../d0/de2/group__fdmi__sd.html#ga3d5ce259696db7f15eb2b756d5a80b8e">m0_fdmi_source_deregister()</a> clears private callbacks in source registration structure</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000014">Test:</a></b></dt><dd><a class="el" href="../../d6/dc3/group__fdmi__sd__int.html#ga986f75b727060da7b6b03d07fe3a5954">m0_fdmi__record_post()</a> puts FDMI record into list and wake-ups source dock FOM if list was empty</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000015">Test:</a></b></dt><dd>m0_fdmi__handle_reply() calls registered <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#aa817fb1f3cc307fd41d5e7f9a650d7de">m0_fdmi_src::fs_put()</a> in case of RPC packet sending failure</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000016">Test:</a></b></dt><dd><a class="el" href="../../d6/dc3/group__fdmi__sd__int.html#gad8df64791a154bc36eb33b62ae130cc5">m0_fdmi__handle_release()</a> calls registered <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#aa817fb1f3cc307fd41d5e7f9a650d7de">m0_fdmi_src::fs_put()</a></dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000017">Test:</a></b></dt><dd><a class="el" href="../../d6/dc3/group__fdmi__sd__int.html#ga3c212c7128d6d40e45207375eb74b4a1">m0_fdmi__src_dock_fom_start()</a> starts FOM correctly</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000018">Test:</a></b></dt><dd><a class="el" href="../../d6/dc3/group__fdmi__sd__int.html#ga773e0900a2a81f191c1bddca59c99c60">m0_fdmi__src_dock_fom_stop()</a> wakes up FOM so it can stop itself</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000019">Test:</a></b></dt><dd><a class="el" href="../../d0/d55/source__dock__fom_8c.html#a04c54396700e3ef8654f515bcd7d32ec">process_fdmi_rec()</a> calls registered source callback <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#ac672f4b5c1a9b1838d689d69647e46cd">m0_fdmi_src::fs_begin()</a> and applies all filters stored in filterC for this record type, calling registered source callback <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#a13b2f44322ed4d40626f4f1d8d8f9333">m0_fdmi_src::fs_node_eval()</a> when necessary. For each matched filter registered source callback <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#a03c0ea9e9e7b2560728f099e93452166">m0_fdmi_src::fs_get()</a> is called.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000020">Test:</a></b></dt><dd><a class="el" href="../../d0/d55/source__dock__fom_8c.html#abedc41df26c3fe0beae685ba8e0d6811">sd_fom_process_matched_filters()</a> creates 'FDMI record notification' FOPs for all matched filters and sends them over RPC.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000021">Test:</a></b></dt><dd>fdmi_rr_fom_tick calls registered source callback <a class="el" href="../../d8/d9c/structm0__fdmi__src.html#aa817fb1f3cc307fd41d5e7f9a650d7de">m0_fdmi_src::fs_put()</a> and posts reply with <a class="el" href="../../d7/d2c/structm0__fop__fdmi__rec__release__reply.html#a8f0ce4a3fce54510a14dfd66aa39e56d">m0_fop_fdmi_rec_release_reply::frrr_rc</a> set to 0</dd></dl>
<h2><a class="anchor" id="FDMI-DLD-ut-fdmi-pd"></a>
FDMI plugin dock unit tests</h2>
<ul>
<li>Plugin dock<ul>
<li>Verify plugin dock start/stop routines</li>
<li>Verify FDMI filter addition correct and incorrect data cases</li>
<li>Verify FDMI filter enabling/disabling with registered and non-existen ids</li>
<li>Verify FDMI plugin deregistration</li>
<li>Verify FDMI record release commands with:<ul>
<li>registered record id<ul>
<li>ref counter greater than 1</li>
<li>ref counter equal to 1</li>
</ul>
</li>
<li>unknown record id</li>
</ul>
</li>
<li>Verify all memory allocation failure cases</li>
<li>Verify FDMI filter lookup failure cases</li>
</ul>
</li>
<li>Plugin dock FOM<ul>
<li>Verify FOM creation with FDMI record notification FOP<ul>
<li>complete notification data</li>
<li>incomplete/crippled notification data</li>
</ul>
</li>
<li>Verify FOM finalisation</li>
<li>Verify FOM state transitions flow</li>
<li>Verify automatic FDMI record release request posting in case there was no record acceptance on plugin side</li>
<li>Verify all memory allocation failure cases</li>
<li>Verify FDMI record lookup failure cases</li>
<li>Verify FDMI filter lookup failure cases</li>
</ul>
</li>
</ul>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000022">Test:</a></b></dt><dd><a class="el" href="../../d0/d50/group__fdmi__pd__int.html#ga5538e16e6811f08d5cb61c14476a8932">m0_fdmi__plugin_dock_init()</a> and <a class="el" href="../../d0/d50/group__fdmi__pd__int.html#ga1e0caf14ad7e104d0a7db824735ab368">m0_fdmi__plugin_dock_start()</a> initialise plugin dock correctly</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000023">Test:</a></b></dt><dd><a class="el" href="../../d0/d50/group__fdmi__pd__int.html#ga3af628a67d4944b8cdebc75e6bd8e763">m0_fdmi__plugin_dock_stop()</a> and <a class="el" href="../../d0/d50/group__fdmi__pd__int.html#gaad6330a2da8bbd97b2abd4be906de933">m0_fdmi__plugin_dock_fini()</a> finalise plugin dock correctly unregistering filter and record registrations if any remained to the moment</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000024">Test:</a></b></dt><dd>Plugin correctly obtains private API interface with <a class="el" href="../../d4/d70/group__fdmi__pd.html#gae1df658f2c42afb1d5c406e9aa34a15b">m0_fdmi_plugin_dock_api_get()</a></dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000025">Test:</a></b></dt><dd><a class="el" href="../../d9/d6b/plugin__dock_8c.html#ad3af82f6446da5310a8c3c58dc0a2351">register_filter()</a> successfully registers filter with correct filter attributes setting filter registration to deactivated state</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000026">Test:</a></b></dt><dd><a class="el" href="../../d9/d6b/plugin__dock_8c.html#ad3af82f6446da5310a8c3c58dc0a2351">register_filter()</a> fails with incorrect filter attributes</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000027">Test:</a></b></dt><dd><a class="el" href="../../d9/d6b/plugin__dock_8c.html#add6efb609c571ac4678a18d836c62f61">enable_filters()</a> correctly activates/deactivates filter registration entries with known filter ids, and being provided with unknown filter ids successfully ignores those</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000028">Test:</a></b></dt><dd><a class="el" href="../../d9/d6b/plugin__dock_8c.html#a238256b660888a46b802a09b7cd51195">release_fdmi_rec()</a> successfully finds record with know id and decrements its ref counter causing release request when counter reaches to zero resulting in <a class="el" href="../../d9/d6b/plugin__dock_8c.html#ae9a0591605d7de205c276f1428d1daec">pdock_record_release()</a> call</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000029">Test:</a></b></dt><dd><a class="el" href="../../d9/d6b/plugin__dock_8c.html#a278492a6cd51e901bf0012a1619faad2">deregister_plugin()</a> successfully unregisters all known filter registrations with ids provided by plugin</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000030">Test:</a></b></dt><dd><a class="el" href="../../d0/d50/group__fdmi__pd__int.html#ga1801acf49d2779ec4823202a624137ab">m0_fdmi__pdock_fdmi_record_register()</a> is able to create record registration entry with complete and correctly built FOP</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000031">Test:</a></b></dt><dd><a class="el" href="../../d7/d9f/plugin__dock__fom_8c.html#a41bc6b7e8349240c76085fda1249e62a">pdock_fom_create()</a> is able to successfully create FOM being provided with complete and correctly built FOP and register FDMI record for further processing</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000032">Test:</a></b></dt><dd><a class="el" href="../../d7/d9f/plugin__dock__fom_8c.html#a41bc6b7e8349240c76085fda1249e62a">pdock_fom_create()</a> correctly terminates when having FOP information not enough to register FDMI record, or having memory allocation failed. Disregarding FOM creation cancelling release request will be posted anyway in case FDMI record id is identifiable in FOP.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000033">Test:</a></b></dt><dd><a class="el" href="../../d7/d9f/plugin__dock__fom_8c.html#a07245e7a6a67fb9aaf7ab98130b3866f">pdock_fom_tick__init()</a> correctly replies to source over RPC and initialises record processing context</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000034">Test:</a></b></dt><dd><a class="el" href="../../d7/d9f/plugin__dock__fom_8c.html#a98fad52c21812c066b5b5e9ec9bfba6c">pdock_fom_tick__feed_plugin_with_rec()</a> correctly iterates through filter ids, calls plugin back and is able to find existent FDMI record registeration each time when plugin accepts the record</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000035">Test:</a></b></dt><dd><a class="el" href="../../d7/d9f/plugin__dock__fom_8c.html#aedf3822609b2b6f547a28338d0eeb7f7">pdock_fom_tick__finish_with_rec()</a> is able to find the processed record and correctly unregister the one</dd></dl>
<h2><a class="anchor" id="FDMI-DLD-ut-fdmi-filter"></a>
FDMI filter subsystem unit tests</h2>
<ul>
<li>FilterC<ul>
<li>Verify FilterC start/sop routines</li>
<li>Verify routines to connect to confd and load filters definitions</li>
</ul>
</li>
<li>Filter Evaluation<ul>
<li>Verify routines to construct filter (init/fini/create node)</li>
<li>Verify routines to apply filter to an FDMI record (evaluate)</li>
<li>Verify routines to convert filter to/from string</li>
<li>Verify that filter evaluator is able to handle source-specific operations</li>
</ul>
</li>
</ul>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000036">Test:</a></b></dt><dd><a class="el" href="../../d1/d1a/structm0__filterc__ops.html#acd52d8acd2f1696ee0aa9c2fcbed647f">m0_filterc_ops::fco_start</a> is called and successfully completes when FDMI service is started (which means filterc has started successfully).</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000037">Test:</a></b></dt><dd><a class="el" href="../../d4/dfa/filterc_8c.html#ae38c2e0009a481b0b6ff52305455330f">m0_filterc_start()</a> is able to connect to confd and load filters from it.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000038">Test:</a></b></dt><dd><a class="el" href="../../d4/dfa/filterc_8c.html#a46e2fef329554d16c126cbaba2127b28">m0_filterc_stop()</a> is able to properly finalise filterc.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000039">Test:</a></b></dt><dd><a class="el" href="../../d0/d9a/group___f_d_m_i___d_l_d__fspec__filter__eval.html#gacd1dac30b71fc1d32f13949f72a2cc08">m0_fdmi_eval_flt()</a> evaluates results properly (for each supported operator and each type, including error cases e.g. unsupported operand types).</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000040">Test:</a></b></dt><dd><a class="el" href="../../d0/d9a/group___f_d_m_i___d_l_d__fspec__filter__eval.html#gacd1dac30b71fc1d32f13949f72a2cc08">m0_fdmi_eval_flt()</a> properly handles source-specific operations, specified using <a class="el" href="../../d0/d9a/group___f_d_m_i___d_l_d__fspec__filter__eval.html#ga352552ffe4e7e91244e7844885daa44b">m0_fdmi_eval_add_op_cb()</a>.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000041">Test:</a></b></dt><dd><a class="el" href="../../dd/d6d/group__xcode.html#ga0b575a0ee88208bebd0ef0f707383404">m0_xcode_print()</a> and <a class="el" href="../../dd/d6d/group__xcode.html#ga0a606c1fc85dce6a6f9f4d0e2ec91062">m0_xcode_read()</a> are able to digest filter structures (definitions).</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000042">Test:</a></b></dt><dd>m0_fdmi_flt_node_to_str() and m0_fdmi_flt_node_from_str() are able to serialize/deserialize filter definitions properly.</dd></dl>
<h2><a class="anchor" id="FDMI-DLD-ut-fdmi-fol"></a>
FOL FDMI source implementation unit tests</h2>
<ul>
<li>Verify that FOL source init/fini routines work properly.</li>
<li>Run FOL source interface functions in the same order they would be called by FDMI source dock, and make sure they behave properly.</li>
<li>Make sure encode/decode do not corrupt data (no data loss, and no added unwanted data).</li>
<li>Check error cases for FOL source interface functions.</li>
</ul>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000043">Test:</a></b></dt><dd><a class="el" href="../../dd/dc6/group__fdmi__fol__src.html#ga03570d2bc28b2ca6397e223f111c69b5">m0_fol_fdmi_src_init()</a> call followed by <a class="el" href="../../dd/dc6/group__fdmi__fol__src.html#ga80f486049c8f8188614c00631ee54bcf">m0_fol_fdmi_src_fini()</a> call work as expected.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000044">Test:</a></b></dt><dd><a class="el" href="../../dd/dc6/group__fdmi__fol__src.html#ga5ee22d1a77f04f6189f029f7b8af5b6f">ffs_op_node_eval()</a> extract value as expected.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000045">Test:</a></b></dt><dd><a class="el" href="../../dd/dc6/group__fdmi__fol__src.html#gab07b5b9582f937f2274c61223541f014">ffs_op_get()</a> and <a class="el" href="../../dd/dc6/group__fdmi__fol__src.html#ga225f2143c89e83bce0580b13b1aa6467">ffs_op_put()</a> do not modify counters.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000046">Test:</a></b></dt><dd><a class="el" href="../../dd/dc6/group__fdmi__fol__src.html#ga1b72326f4219f4bcad518494f960af1a">ffs_op_encode()</a> succeeds and encodes data properly.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000047">Test:</a></b></dt><dd><a class="el" href="../../dd/dc6/group__fdmi__fol__src.html#ga0685854eb2ed22c90ec54094a4600b98">ffs_op_decode()</a> succeeds and decoded data matches original encoded record.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000048">Test:</a></b></dt><dd><a class="el" href="../../dd/dc6/group__fdmi__fol__src.html#ga07826f5d0de99a2b3d33bc4b462031aa">ffs_op_begin()</a> does not modify counters.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000049">Test:</a></b></dt><dd><a class="el" href="../../dd/dc6/group__fdmi__fol__src.html#ga72077b2e14b25e4d96454cf4025b6af2">ffs_op_end()</a> decreases transaction counter by one (<a class="el" href="../../d5/d54/be_2linux__kernel_2stubs_8c.html#ga9e056c8be3495545fa76d9b7612646a3">m0_be_tx_put()</a>).</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000050">Test:</a></b></dt><dd><a class="el" href="../../dd/dc6/group__fdmi__fol__src.html#ga80f486049c8f8188614c00631ee54bcf">m0_fol_fdmi_src_fini()</a> is able to handle case when there are "un-processed" FDMI records.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000051">Test:</a></b></dt><dd><a class="el" href="../../dd/dc6/group__fdmi__fol__src.html#ga6fb58d3d34cad131bc06891aee77d3f5">m0_fol_fdmi_post_record()</a> calls required Source Dock methods, saves record into internal hash, and calls <a class="el" href="../../d5/d54/be_2linux__kernel_2stubs_8c.html#gacfcc8125c47ad5d88b83d1a36711f767">m0_be_tx_get()</a>.</dd></dl>
<h2><a class="anchor" id="FDMI-DLD-ut-fdmi-cp"></a>
FDMI Connection Pool module implementation</h2>
<p>unit tests</p>
<ul>
<li>FDMI Connection Pool module<ul>
<li>Verify that init/fini routines work properly.</li>
<li>Verify that RPC connect/disconnect works.</li>
<li>Verify that error cases are handled.</li>
</ul>
</li>
</ul>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000052">Test:</a></b></dt><dd>m0_fdmi_conn_pool_init() initializes internals properly.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000053">Test:</a></b></dt><dd>m0_fdmi_conn_pool_get() creates new connection if existing not found.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000054">Test:</a></b></dt><dd>m0_fdmi_conn_pool_get() returns new session on existing connection if found.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000055">Test:</a></b></dt><dd>m0_fdmi_conn_pool_get() and m0_fdmi_conn_pool_put() handle counters properly.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000056">Test:</a></b></dt><dd>m0_fdmi_conn_pool_fini() succeeds.</dd></dl>
<h1><a class="anchor" id="FDMI-DLD-st"></a>
System Tests</h1>
<p>FDMI simple echo plugin is implemented as a system test.</p>
<h1><a class="anchor" id="FDMI-DLD-O"></a>
Analysis</h1>
<p><b>TBD</b> </p>
<h1><a class="anchor" id="FDMI-DLD-ref"></a>
References</h1>
<ul>
<li><a class="anchor" id="FDMI-DLD-ref-HLD"></a></li>
<li>Motr FDMI HLD : For documentation links, please refer to this file : doc/motr-design-doc-list.rst</li>
</ul>
<h1><a class="anchor" id="FDMI-DLD-impl-plan"></a>
Implementation Plan</h1>
<p>Implementation plan is specified as a part of HLD [0] </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri May 20 2022 10:35:32 for Motr by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
