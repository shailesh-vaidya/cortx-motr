<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Motr: LNet Transport Device DLD</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Motr
   &#160;<span id="projectnumber">M0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('da/d74/_l_net_d_r_v_d_l_d.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">LNet Transport Device DLD </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-ovw">Overview</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-def">Definitions</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-req">Requirements</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-depends">Dependencies</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-highlights">Design Highlights</a></li>
<li><a class="el" href="../../dd/dfc/_l_net_d_r_v_d_l_d-fspec.html">Functional Specification</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec">Logical Specification</a><ul>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-comps">Component Overview</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-dev">Device Setup and Shutdown</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-ioctl">Ioctl Request Behavior</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-mem">Shared Memory Management Strategy</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-dominit">Domain Initialization</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-domfini">Domain Finalization</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-reg">Buffer Registration and Deregistration</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-bev">Managing the Buffer Event Queue</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-tmstart">Starting a Transfer Machine</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-tmstop">Stopping a Transfer Machine</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-buf">Transfer Machine Buffer Queue Operations</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-event">Waiting for Buffer Events</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-nids">Node Identifier Support</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-state">State Specification</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-thread">Threading and Concurrency Model</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-numa">NUMA optimizations</a></li>
</ul>
</li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-conformance">Conformance</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-ut">Unit Tests</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-st">System Tests</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-O">Analysis</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-ref">References</a></li>
</ul>
<hr/>
 <h1><a class="anchor" id="LNetDRVDLD-ovw"></a>
Overview</h1>
<p>The Motr LNet Transport device provides user space access to the kernel <a class="el" href="../../d6/de0/_l_net_d_l_d.html">Motr LNet Transport</a>. The <a class="el" href="../../d8/d7d/_u_l_net_core_d_l_d.html">User Space Core</a> implementation uses the device to communicate with the <a class="el" href="../../db/dd7/_k_l_net_core_d_l_d.html">Kernel Core</a>. The device provides a conduit through which information flows between the user space and kernel core layers, initiated by the user space layer. The specific operations that can be performed on the device are documented here. Hooks for unit testing the device are also discussed.</p>
<hr/>
 <h1><a class="anchor" id="LNetDRVDLD-def"></a>
Definitions</h1>
<ul>
<li>HLD of Motr LNet Transport : For documentation links, please refer to this file : doc/motr-design-doc-list.rst</li>
</ul>
<ul>
<li><b>reference</b> A reference to an object is stored in terms of a memory page and offset, rather than as a simple address pointer.</li>
<li><b>pin</b> Keep a page of user memory from being paged out of physical memory and cause it to be paged in if it was previously paged out. Pinned user pages, like pages of kernel memory, are tracked by kernel <code>page</code> objects. Pinning a page does not assign it a kernel logical address; that requires subsequently mapping the page. A pinned page remained pinned until it is explicitly unpinned. Pinning may involve the use of shared, reference counted objects, but one should not depend on this for correctness.</li>
<li><b>map</b> Assign a kernel logical address to a page of memory. A mapped page remains mapped until explicitly unmapped. Both kernel and pinned user pages can be mapped. Mapping may involve the use of shared, reference counted objects and addresses, but one should not depend on this for correctness. Each time a page is mapped, it may be assigned a different logical address.</li>
<li><b>unmap</b> Remove the association of a kernel logical address from a page. After a page is unmapped, it has no logical address until it is explicitly remapped.</li>
<li><b>unpin</b> Allow a previously pinned page to move freely, i.e. an unpinned page can be swapped out of physical memory. Any struct <code>page</code> pointers to the previously pinned page are no longer valid after a page is unpinned.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="LNetDRVDLD-req"></a>
Requirements</h1>
<ul>
<li><b>r.m0.net.xprt.lnet.user-space</b> The implementation must accommodate the needs of the user space LNet transport.</li>
<li><b>r.m0.net.xprt.lnet.dev.pin-objects</b> The implementation must pin shared objects in kernel memory to ensure they will not disappear while in use.</li>
<li><b>r.m0.net.xprt.lnet.dev.resource-tracking</b> The implementation must track all shared resources and ensure they are released properly, even after a user space error.</li>
<li><b>r.m0.net.xprt.lnet.dev.safe-sharing</b> The implementation must ensure that references to shared object are valid.</li>
<li><b>r.m0.net.xprt.lnet.dev.assert-free</b> The implementation must ensure that the kernel module will not assert due to invalid shared state.</li>
<li><b>r.m0.net.xprt.lnet.dev.minimal-mapping</b> The implementation must avoid mapping many kernel pages for long periods of time, avoiding excessive use of kernel high memory page map.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="LNetDRVDLD-depends"></a>
Dependencies</h1>
<ul>
<li><a class="el" href="../../d8/de0/group___l_net_core.html">LNet Transport Core Interface</a> <br />
 Several modifications are required on the Core interface itself:<ul>
<li>A new <code><a class="el" href="../../d1/d4b/structnlx__core__buffer__event.html#a58741a997e3f0bc256d6f2d00fe4b578">nlx_core_buffer_event::cbe_kpvt</a></code> pointer is required that can be set to refer to the new <code><a class="el" href="../../d5/df6/structnlx__kcore__buffer__event.html">nlx_kcore_buffer_event</a></code> object.</li>
<li>The <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga320b9bd08fca9515d270a582f7a2dc3f">nlx_core_tm_start()</a></code> function is changed to remove the <code>cepa</code> and <code>epp</code> parameters. The <code>cepa</code> parameter is always the same as the <code>lctm-&gt;ctm_addr</code>. The Core API does not use a <code><a class="el" href="../../d2/d80/structm0__net__end__point.html">m0_net_end_point</a></code>, so setting the <code>epp</code> at the core layer was inappropriate. The LNet XO layer, which does use the end point, is modified to allocate this end point in the <code><a class="el" href="../../dd/d6e/group___l_net_x_o_d_f_s.html#gae28f349113706579939dc63c9338df55">nlx_tm_ev_worker()</a></code> logic itself.</li>
<li>The user space transport must ensure that shared objects do not cross page boundaries. This applies only to shared core objects such as <code><a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html">nlx_core_transfer_mc</a></code>, not to buffer pages. Since object allocation is actually done in the LNet XO layer (except for the <code><a class="el" href="../../d1/d4b/structnlx__core__buffer__event.html">nlx_core_buffer_event</a></code>), this requires that an allocation wrapper function, <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga25c3e3dfb3b2d507aec2019c29fe32f6">nlx_core_mem_alloc()</a></code>, be added to the Core Interface, implemented separately in the kernel and user transports, because the kernel transport has no such limitation and the <code><a class="el" href="../../d7/ded/group__memory.html#gaba5ec475cae7ec35c8082362f50967aa">m0_alloc_aligned()</a></code> API, which could be used to satisfy this requirement, requires page aligned data or greater in kernel space. A corresponding <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga622bce4a708bc229c403ef0fdee694be">nlx_core_mem_free()</a></code> is required to free the allocated memory.</li>
</ul>
</li>
<li><a class="el" href="../../d3/d35/group___u_l_net_core.html">LNet Transport Core User Private Interface</a> <br />
 Besides the existence of this interface, the following dependencies exist:<ul>
<li>The user space transport must call the ioctl requests specified in this DLD in the manner prescribed in the <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec">Logical Specification</a> below.</li>
<li>The user space transport must implement the new <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga25c3e3dfb3b2d507aec2019c29fe32f6">nlx_core_mem_alloc()</a></code> and <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga622bce4a708bc229c403ef0fdee694be">nlx_core_mem_free()</a></code> required by the Core Interface.</li>
</ul>
</li>
<li><a class="el" href="../../d6/d8a/group___k_l_net_core.html">LNet Transport Core Kernel Private Interface</a> <br />
 Several modifications are required in this interface:<ul>
<li>The kernel core objects with back pointers to the corresponding core objects must be changed to remove these pointers and replace them with use of <code><a class="el" href="../../d4/d08/structnlx__core__kmem__loc.html">nlx_core_kmem_loc</a></code> objects. More details of this dependency are discussed in <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-mem">Shared Memory Management Strategy</a>.</li>
<li>The <code><a class="el" href="../../dd/d08/group__bevcqueue.html#ga6027e82fa54371c2e9335f5366455adf">bev_cqueue_pnext()</a></code> and <code><a class="el" href="../../dd/d08/group__bevcqueue.html#gaef877c0746747aab043617177b5973df">bev_cqueue_put()</a></code> are modified such that they map and unmap the <code><a class="el" href="../../d1/d4b/structnlx__core__buffer__event.html">nlx_core_buffer_event</a></code> object (atomic mapping must be used, because these functions are called from the LNet callback). This also requires use of <code><a class="el" href="../../d4/d08/structnlx__core__kmem__loc.html">nlx_core_kmem_loc</a></code> references in the <code><a class="el" href="../../d1/d60/structnlx__core__bev__link.html">nlx_core_bev_link</a></code>.</li>
<li>Many of the Core APIs implemented in the kernel must be refactored such that the portion that can be shared between the kernel-only transport and the kernel driver is moved into a new API. The Kernel Core API implementation is changed to perform pre-checks, call the new shared API and complete post-shared operations. The User Space Core tasks described in the <a class="el" href="../../d8/d7d/_u_l_net_core_d_l_d.html#ULNetCoreDLD-lspec">User Space Core Logical Specification</a> can be used as a guide for how to refactor the Kernel Core implementation. In addition, the operations on the <code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html">nlx_kcore_ops</a></code> structure guide the signatures of the refactored, shared operations.</li>
<li>The <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#gaceaa27686a38224fa4043f3e2980f37d">nlx_kcore_umd_init()</a></code> function is changed to set the MD <code>user_ptr</code> to the <code><a class="el" href="../../d5/daa/structnlx__kcore__buffer.html">nlx_kcore_buffer</a></code>, not the <code><a class="el" href="../../d7/df3/structnlx__core__buffer.html">nlx_core_buffer</a></code>. <code>kb_buffer_id</code> and <code>kb_qtype</code> fields are added to the <code><a class="el" href="../../d5/daa/structnlx__kcore__buffer.html">nlx_kcore_buffer</a></code> and are set during <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#gad698e59d30658540bb58f488c8c4d6a7">nlx_kcore_buf_register()</a></code> and <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#gaceaa27686a38224fa4043f3e2980f37d">nlx_kcore_umd_init()</a></code> respectively. This allows the lnet event callback to execute without using the <code><a class="el" href="../../d7/df3/structnlx__core__buffer.html">nlx_core_buffer</a></code>. All other uses of the MD <code>user_ptr</code> field must be changed accordingly.</li>
<li>Various blocks of <code><a class="el" href="../../dc/da7/assert_8h.html#a1c063bd08f7e1ab3a6e6008ef825d471">M0_PRE()</a></code> assertions used to validate shared objects before they are referenced should be refactored into new invariant-style functions so the driver can perform the checks and return an error without causing an kernel assertion.</li>
<li>The kernel core must implement the new <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga25c3e3dfb3b2d507aec2019c29fe32f6">nlx_core_mem_alloc()</a></code> and <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga622bce4a708bc229c403ef0fdee694be">nlx_core_mem_free()</a></code> required by the Core Interface.</li>
</ul>
</li>
</ul>
<hr/>
 <h1><a class="anchor" id="LNetDRVDLD-highlights"></a>
Design Highlights</h1>
<ul>
<li>The device provides ioctl-based access to the Kernel LNet Core Interface.</li>
<li>Ioctl requests correspond roughly to the <a class="el" href="../../d8/de0/group___l_net_core.html">LNet Transport Core APIs</a>.</li>
<li>Each user space <code><a class="el" href="../../db/d78/structm0__net__domain.html">m0_net_domain</a></code> corresponds to opening a separate file descriptor.</li>
<li>The device driver tracks all resources associated with the file descriptor.</li>
<li>Well-defined patterns are used for sharing new resources between user and kernel space, referencing previously shared resources, and releasing shared resources.</li>
<li>The device driver can clean up a domain's resources in the case that the user program terminates prematurely.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="LNetDRVDLD-lspec"></a>
Logical Specification</h1>
<ul>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-comps">Component Overview</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-dev">Device Setup and Shutdown</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-ioctl">Ioctl Request Behavior</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-mem">Shared Memory Management Strategy</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-dominit">Domain Initialization</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-domfini">Domain Finalization</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-reg">Buffer Registration and Deregistration</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-bev">Managing the Buffer Event Queue</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-tmstart">Starting a Transfer Machine</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-tmstop">Stopping a Transfer Machine</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-buf">Transfer Machine Buffer Queue Operations</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-event">Waiting for Buffer Events</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-nids">Node Identifier Support</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-state">State Specification</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-thread">Threading and Concurrency Model</a></li>
<li><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-numa">NUMA optimizations</a></li>
</ul>
<h2><a class="anchor" id="LNetDRVDLD-lspec-comps"></a>
Component Overview</h2>
<p>The LNet Device Driver is a layer between the user space transport core and the kernel space transport core. The driver layer provides a mechanism for the user space to interact with the Lustre LNet kernel module. It uses a subset of the kernel space transport core interface to implement this interaction.</p>
<ul>
<li>HLD of Motr LNet Transport : For documentation links, please refer to this file : doc/motr-design-doc-list.rst</li>
</ul>
<p>Refer specifically the Design Highlights component diagram.</p>
<p>For reference, the relationship between the various components of the LNet transport and the networking layer is illustrated in the following UML diagram. </p><div class="image">
<img src="../../../../net/lnet/lnet_xo.png" alt="lnet_xo.png"/>
<div class="caption">
LNet Transport Objects</div></div>
<p> The LNet Device Driver has no sub-components. It has several internal functions that interact with the kernel space transport core layer.</p>
<h2><a class="anchor" id="LNetDRVDLD-lspec-dev"></a>
Device Setup and Shutdown</h2>
<p>The LNet device is registered with the kernel using the <code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga36fd2e4c41d51e4d5c7648e3d475cff6">nlx_dev_init()</a></code> function when the Motr Kernel module is loaded. This function is called by the existing <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga0e206782b67871b67864bb0be70e3d67">nlx_core_init()</a></code> function. The function performs the following tasks.</p><ul>
<li>It registers the device with the kernel. The device is registered as a miscellaneous device named "m0lnet". As such, registration causes the device to appear as "/dev/m0lnet" in the device file system.</li>
<li>Sets a flag, <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga65ded74b721c9e887ffc7ca752a333bd">nlx_dev_registered</a></code>, denoting successful device registration.</li>
</ul>
<p>The LNet device is deregistered with the kernel using the <code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga738edc26ce1fdc35205f17057ec72d30">nlx_dev_fini()</a></code> function when the Motr Kernel module is unloaded. This function is called by the existing <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga03b10c3af5a956a1b02ffafd726a2043">nlx_core_fini()</a></code> function. The function performs the following task.</p><ul>
<li>If device registration was performed successfully, deregisters the device and resets the <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga65ded74b721c9e887ffc7ca752a333bd">nlx_dev_registered</a></code> flag.</li>
</ul>
<h2><a class="anchor" id="LNetDRVDLD-lspec-ioctl"></a>
Ioctl Request Behavior</h2>
<p>The <a class="el" href="../../d3/d35/group___u_l_net_core.html">user space implementation</a> of the <a class="el" href="../../d8/de0/group___l_net_core.html">LNet Transport Core Interface</a> interacts with the <a class="el" href="../../d6/d8a/group___k_l_net_core.html">LNet Transport Kernel Core</a> via ioctl requests. The file descriptor required to make the ioctl requests is obtained during the <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-dominit">Domain Initialization</a> operation.</p>
<p>All further interaction with the device, until the file descriptor is closed, is via ioctl requests. Ioctl requests are served by the <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> function, an implementation of the kernel <code>file_operations::unlocked_ioctl()</code> function. This function performs the following steps.</p>
<ul>
<li>It validates the request.</li>
<li>It copies in (from user space) the parameter object corresponding to the specific request for most _IOW requests. Note that the requests that take pointers instead of parameter objects do not copy in, because the pointers are either references to kernel objects or shared objects to be pinned, not copied.</li>
<li>It calls a helper function to execute the command; specific helper functions are called out in the following sections. The helper function will call a kernel core operation to execute the behavior shared between user space and kernel transports. It does this indirectly from operations defined on the <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#aa7a66970686c19e424ee12541e1ba2e8">nlx_kcore_domain::kd_drv_ops</a></code> operation object.</li>
<li>It copies out (to user space) the parameter object corresponding to the specific request for _IOR and _IOWR requests.</li>
<li>It returns the status, generally of the helper function. This status follows the typical 0 for success, -errno for failure, except as specified for certain helper functions.</li>
</ul>
<p>The helper functions verify that the requested operation will not cause an assertion in the kernel core. This is done by performing the same checks the Kernel Core APIs would do, but without asserting. Instead, they log an ADDB record and return an error status when verification fails. The user space core can detect the error status and assert the user space process. The error code <code>-EBADR</code> is used to report verification failure. The error code <code>-EFAULT</code> is used to report invalid user addresses, such as for use in pinning pages or copying in user data. Specific helper functions may return additional well-defined errors.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html">LNet Transport Device Internals</a></dd></dl>
<h2><a class="anchor" id="LNetDRVDLD-lspec-mem"></a>
Shared Memory Management Strategy</h2>
<p>Some ioctl requests have the side effect of pinning user pages in memory. However, the mapping of pages (i.e. <code>kmap()</code> or <code>kmap_atomic()</code> functions) is performed only while the pages are to be used, and then unmapped as soon as possible. The number of mappings available to <code>kmap()</code> is documented as being limited. Except as noted, <code>kmap_atomic()</code> is used in blocks of code that will not sleep to map the page associated with an object. Each time a shared object is mapped, its invariants are re-checked to ensure the page still contains the shared object. Each shared core object is required to fit within a single page to simplify mapping and sharing. The user space transport must ensure this requirement is met when it allocates core objects. Note that the pages of the <code><a class="el" href="../../da/d2c/structm0__bufvec.html">m0_bufvec</a></code> segments are not part of the shared <code><a class="el" href="../../d7/df3/structnlx__core__buffer.html">nlx_core_buffer</a></code>; they are referenced by the associated <code><a class="el" href="../../d5/daa/structnlx__kcore__buffer.html">nlx_kcore_buffer</a></code> object and are never mapped by the driver or kernel core layers.</p>
<p>The <code><a class="el" href="../../d4/d08/structnlx__core__kmem__loc.html">nlx_core_kmem_loc</a></code> structure stores the page and offset of an object. It also stores a checksum to detect inadvertent corruption of the address or offset. This structure is used in place of pointers within structures used in kernel address space to reference shared (pinned) user space objects. Kernel core structures <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html">nlx_kcore_domain</a></code>, <code><a class="el" href="../../d5/d0b/structnlx__kcore__transfer__mc.html">nlx_kcore_transfer_mc</a></code>, <code><a class="el" href="../../d5/daa/structnlx__kcore__buffer.html">nlx_kcore_buffer</a></code> and <code><a class="el" href="../../d5/df6/structnlx__kcore__buffer__event.html">nlx_kcore_buffer_event</a></code> refer to shared objects, and use fields such as <a class="el" href="../../d1/dab/structnlx__kcore__domain.html#a978a5b6b9b1a3ccc14e97e570dbac597">nlx_kcore_domain::kd_cd_loc</a> to store these references. Structures such as <code><a class="el" href="../../d1/d60/structnlx__core__bev__link.html">nlx_core_bev_link</a></code>, <code><a class="el" href="../../db/d96/structnlx__core__bev__cqueue.html">nlx_core_bev_cqueue</a></code>, while contained in shared objects also use <code><a class="el" href="../../d4/d08/structnlx__core__kmem__loc.html">nlx_core_kmem_loc</a></code>, because these structures in turn need to reference yet other shared objects. When the shared object is needed, it is mapped (e.g. <code>kmap_atomic()</code> returns a pointer to the mapped page, and the code adds the corresponding offset to obtain a pointer to the object itself), used, and unmapped. The kernel pointer to the shared object is only used on the stack, never stored in a shared place. This allow for unsynchronized, concurrent access to shared objects, just as if they were always mapped.</p>
<p>The core data structures include kernel private pointers, such as <code><a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html#a7d5df18770c6217b4d3b797afed955cb">nlx_core_transfer_mc::ctm_kpvt</a></code>. These opaque (to the user space) values are used as parameters to ioctl requests. These pointers cannot be used directly, since it is possible they could be inadvertently corrupted. To address that, when such pointers are passed to ioctl requests, they are first validated using <code>virt_addr_valid()</code> to ensure they can be dereferenced in the kernel and then further validated using the appropriate invariant, <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga530692bcf0e267d1a08e8faced4528a4">nlx_kcore_tm_invariant()</a></code> in the case above. If either validation fails, an error is returned, as discussed in <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-ioctl">Ioctl Request Behavior</a>.</p>
<h2><a class="anchor" id="LNetDRVDLD-lspec-dominit"></a>
Domain Initialization</h2>
<p>The LNet Transport Device Driver is first accessed during domain initialization. The <a class="el" href="../../d8/d7d/_u_l_net_core_d_l_d.html#ULNetCoreDLD-lspec-dominit">user space core</a> opens the device and performs an initial <code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga604193f0a227cfe0ef279f652a513684">M0_LNET_DOM_INIT</a></code> ioctl request.</p>
<p>In the kernel, the <code>open()</code> and <code>ioctl()</code> system calls are handled by the <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#gac97dbd0a0eab9e4fe0bb58122e457c8d">nlx_dev_open()</a></code> and <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> subroutines, respectively.</p>
<p>The <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#gac97dbd0a0eab9e4fe0bb58122e457c8d">nlx_dev_open()</a></code> performs the following sequence.</p><ul>
<li>It allocates a <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html">nlx_kcore_domain</a></code> object, initializes it using <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga00e38a4ba9f087356675ba41a57dc3d7">nlx_kcore_kcore_dom_init()</a></code> and assigns the object to the <code>file-&gt;private_data</code> field.</li>
</ul>
<p>The <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> is described generally <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-ioctl">above</a>. It uses the helper function <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga480a38459177bb04627ce25930245566">nlx_dev_ioctl_dom_init()</a></code> to complete kernel domain initialization. The following tasks are performed.</p><ul>
<li>The <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#a8faa1ac621bb022f0a61900aeed08ab2">nlx_kcore_domain::kd_drv_mutex()</a></code> is locked.</li>
<li>The <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html">nlx_kcore_domain</a></code> is verified to ensure the core domain is not already initialized.</li>
<li>The <code><a class="el" href="../../d8/d81/structnlx__core__domain.html">nlx_core_domain</a></code> object is pinned in kernel memory.</li>
<li>Information required to map the <code><a class="el" href="../../d8/d81/structnlx__core__domain.html">nlx_core_domain</a></code> is saved in the <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#a978a5b6b9b1a3ccc14e97e570dbac597">nlx_kcore_domain::kd_cd_loc</a></code>.</li>
<li>The <code><a class="el" href="../../d8/d81/structnlx__core__domain.html">nlx_core_domain</a></code> is mapped and validated to ensure no assertions will occur.</li>
<li>The <code><a class="el" href="../../d8/d81/structnlx__core__domain.html">nlx_core_domain</a></code> is initialized by <code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html#af00cd26c923dd16dcf36611805168e36">nlx_kcore_ops::ko_dom_init()</a></code>.</li>
<li>The output parameters of the ioctl request, the three buffer size maximum values, are set in the provided <code><a class="el" href="../../dc/dfc/structm0__lnet__dev__dom__init__params.html">m0_lnet_dev_dom_init_params</a></code> object.</li>
<li>The <code><a class="el" href="../../d8/d81/structnlx__core__domain.html">nlx_core_domain</a></code> is unmapped (it remains pinned).</li>
<li>The <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#a8faa1ac621bb022f0a61900aeed08ab2">nlx_kcore_domain::kd_drv_mutex()</a></code> is unlocked.</li>
</ul>
<h2><a class="anchor" id="LNetDRVDLD-lspec-domfini"></a>
Domain Finalization</h2>
<p>During normal domain finalization, the <a class="el" href="../../d8/d7d/_u_l_net_core_d_l_d.html#ULNetCoreDLD-lspec-domfini">user space core</a> closes its file descriptor after the upper layers have already cleaned up other resources (buffers and transfer machines). It is also possible that the user space process closes the file descriptor without first finalizing the associated domain resources, such as in the case that the user space process fails.</p>
<p>In the kernel the <code>close()</code> system call is handled by the <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga120c166ef9fa98855c20aa3b67ff519b">nlx_dev_close()</a></code> subroutine. Technically, <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga120c166ef9fa98855c20aa3b67ff519b">nlx_dev_close()</a></code> is called once by the kernel when the last reference to the file is closed (e.g. if the file descriptor had been duplicated). The subroutine performs the following sequence.</p>
<ul>
<li>It verifies that the domain is ready to be finalized. That is, it checks that the resource lists <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#ad969ec059adf6fa4d19d0b405f387f0d">nlx_kcore_domain::kd_drv_tms</a></code> and <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#a55786452777befef3ae03b20b793e200">nlx_kcore_domain::kd_drv_bufs</a></code> are empty.</li>
<li>If the domain is not ready to be finalized, it releases the remaining domain resources itself.<ul>
<li>Any running transfer machines must be stopped, their pending operations aborted.</li>
<li>Shared <code><a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html">nlx_core_transfer_mc</a></code> objects must be unpinned.</li>
<li>Shared <code><a class="el" href="../../d1/d4b/structnlx__core__buffer__event.html">nlx_core_buffer_event</a></code> objects must be unpinned.</li>
<li>Each corresponding <code><a class="el" href="../../d5/df6/structnlx__kcore__buffer__event.html">nlx_kcore_buffer_event</a></code> object is freed.</li>
<li>Each <code><a class="el" href="../../d5/d0b/structnlx__kcore__transfer__mc.html">nlx_kcore_transfer_mc</a></code> object is freed.</li>
<li>All pinned buffer data pages must be unpinned.</li>
<li>All registered buffers must be deregistered.</li>
<li>Shared <code><a class="el" href="../../d7/df3/structnlx__core__buffer.html">nlx_core_buffer</a></code> objects must be unpinned.</li>
<li>Each corresponding <code><a class="el" href="../../d5/daa/structnlx__kcore__buffer.html">nlx_kcore_buffer</a></code> object is freed.</li>
</ul>
</li>
<li>It calls <code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html#aedbd67e36de8f73540c20b638ced5c88">nlx_kcore_ops::ko_dom_fini()</a></code> to finalize the core domain.</li>
<li>It unpins the shared <code><a class="el" href="../../d8/d81/structnlx__core__domain.html">nlx_core_domain</a></code> object, resetting the the <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#a978a5b6b9b1a3ccc14e97e570dbac597">nlx_kcore_domain::kd_cd_loc</a></code>.</li>
<li>It resets (to NULL) the <code>file-&gt;private_data</code>.</li>
<li>It calls <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#gae1fb86408b29aad8bcb47da62791f168">nlx_kcore_kcore_dom_fini()</a></code> to finalize the <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html">nlx_kcore_domain</a></code> object.</li>
<li>It frees the <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html">nlx_kcore_domain</a></code> object.</li>
</ul>
<h2><a class="anchor" id="LNetDRVDLD-lspec-reg"></a>
Buffer Registration and Deregistration</h2>
<p>While registering a buffer, the user space core performs a <code><a class="el" href="../../df/d9e/group___l_net_dev.html#gab70c3b3e49bd6f3871a12f1e49b2922b">M0_LNET_BUF_REGISTER</a></code> ioctl request.</p>
<p>The <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> subroutine uses the helper function <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#gacd65375ccf4de7d7a7f5f4427aa835e5">nlx_dev_ioctl_buf_register()</a></code> to complete kernel buffer registration. The following tasks are performed.</p><ul>
<li>The parameters are validated to ensure no assertions will occur.</li>
<li>The <code><a class="el" href="../../da/d2c/structm0__bufvec.html#a215401fba52fbf40989f6be1c0925fa4">m0_bufvec::ov_buf</a></code> and <code>m0_bufvec::ov_vec::v_count</code> are copied in, temporarily (to avoid issues of either list crossing page boundaries that might occur by mapping the pages directly), and the corresponding fields of the <code><a class="el" href="../../d8/d18/structm0__lnet__dev__buf__register__params.html#a5551a9d646b8ba48d3a8acd8358eee34">m0_lnet_dev_buf_register_params::dbr_bvec</a></code> is updated to refer to the copies.</li>
<li>The <code><a class="el" href="../../d7/df3/structnlx__core__buffer.html">nlx_core_buffer</a></code>, <code><a class="el" href="../../d8/d18/structm0__lnet__dev__buf__register__params.html#ab263927b6741437ebd89162621c4c2ea">m0_lnet_dev_buf_register_params::dbr_lcbuf</a></code>, is pinned in kernel memory.</li>
<li>Information required to map the <code><a class="el" href="../../d7/df3/structnlx__core__buffer.html">nlx_core_buffer</a></code> is saved in the <code><a class="el" href="../../d5/daa/structnlx__kcore__buffer.html#a0efd87d4754b43fb2e2a9f4b97ce973e">nlx_kcore_buffer::kb_cb_loc</a></code>.</li>
<li>The <code><a class="el" href="../../d7/df3/structnlx__core__buffer.html">nlx_core_buffer</a></code> is mapped and validated to ensure no assertions will occur. It is also checked to ensure it is not already associated with a <code><a class="el" href="../../d5/daa/structnlx__kcore__buffer.html">nlx_kcore_buffer</a></code> object.</li>
<li><code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html#a78e90ef8abc8bbc58068fd54980d5a50">nlx_kcore_ops::ko_buf_register()</a></code> is used to initialize the <code><a class="el" href="../../d7/df3/structnlx__core__buffer.html">nlx_core_buffer</a></code> and <code><a class="el" href="../../d5/daa/structnlx__kcore__buffer.html">nlx_kcore_buffer</a></code> objects.</li>
<li><code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga460e610c0a7b3acefc35a42eb6ebd284">nlx_kcore_buffer_uva_to_kiov()</a></code> is used to pin the pages of the buffer segments and initialize the <code><a class="el" href="../../d5/daa/structnlx__kcore__buffer.html#a4b74b8ac5bcb10e1ba2da04bc98048d0">nlx_kcore_buffer::kb_kiov</a></code>.</li>
<li>The <code><a class="el" href="../../d7/df3/structnlx__core__buffer.html">nlx_core_buffer</a></code> is unmapped (it remains pinned).</li>
<li>The <code><a class="el" href="../../d5/daa/structnlx__kcore__buffer.html">nlx_kcore_buffer</a></code> is added to the <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#a55786452777befef3ae03b20b793e200">nlx_kcore_domain::kd_drv_bufs</a></code> list.</li>
<li>Memory allocated for the temporary copies in the <code><a class="el" href="../../d8/d18/structm0__lnet__dev__buf__register__params.html#a5551a9d646b8ba48d3a8acd8358eee34">m0_lnet_dev_buf_register_params::dbr_bvec</a></code> are freed.</li>
</ul>
<p>While deregistering a buffer, the user space core performs a <code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga38d0ea03383ce6d9bbd2319ece7bf2b7">M0_LNET_BUF_DEREGISTER</a></code> ioctl request.</p>
<p>The <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> subroutine uses the helper function <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga5f0e36315933b6141a761664aeecd3f2">nlx_dev_ioctl_buf_deregister()</a></code> to complete kernel buffer deregistration. The following tasks are performed.</p><ul>
<li>The parameters are validated to ensure no assertions will occur.</li>
<li>The pages associated with the buffer, referenced by <code><a class="el" href="../../d5/daa/structnlx__kcore__buffer.html#a4b74b8ac5bcb10e1ba2da04bc98048d0">nlx_kcore_buffer::kb_kiov</a></code>, are unpinned.</li>
<li>The buffer is removed from the <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#a55786452777befef3ae03b20b793e200">nlx_kcore_domain::kd_drv_bufs</a></code> list.</li>
<li>The <code><a class="el" href="../../d7/df3/structnlx__core__buffer.html">nlx_core_buffer</a></code> is mapped.</li>
<li><code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html#a20bba8b5fe09095c2b6b3970e7a94128">nlx_kcore_ops::ko_buf_deregister()</a></code> is used to deregister the buffer.</li>
<li>The <code><a class="el" href="../../d5/daa/structnlx__kcore__buffer.html">nlx_kcore_buffer</a></code> object is freed.</li>
<li>The <code><a class="el" href="../../d7/df3/structnlx__core__buffer.html">nlx_core_buffer</a></code> is unmapped and unpinned.</li>
</ul>
<h2><a class="anchor" id="LNetDRVDLD-lspec-bev"></a>
Managing the Buffer Event Queue</h2>
<p>The <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga90a62bfb8f2c6418f7f83e0512b25c19">nlx_core_new_blessed_bev()</a></code> helper allocates and blesses buffer event objects. In user space, blessing the object requires interacting with the kernel by way of the <code><a class="el" href="../../df/d9e/group___l_net_dev.html#gae897fa2a1613b644496aa88de0244cf5">M0_LNET_BEV_BLESS</a></code> ioctl request.</p>
<p>The <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> subroutine uses the helper function <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#gaca44147b1297b273d9453735493b2cbf">nlx_dev_ioctl_bev_bless()</a></code> to complete blessing the buffer event object. The following tasks are performed.</p><ul>
<li>The parameters are validated to ensure no assertions will occur.</li>
<li>The <code><a class="el" href="../../d1/d4b/structnlx__core__buffer__event.html">nlx_core_buffer_event</a></code> is pinned in kernel memory.</li>
<li>A <code><a class="el" href="../../d5/df6/structnlx__kcore__buffer__event.html">nlx_kcore_buffer_event</a></code> object is allocated and initialized.</li>
<li>Information required to map the pinned object is saved in the <code><a class="el" href="../../d5/df6/structnlx__kcore__buffer__event.html">nlx_kcore_buffer_event</a></code> object.</li>
<li>The <code><a class="el" href="../../d1/d4b/structnlx__core__buffer__event.html">nlx_core_buffer_event</a></code> is mapped, validated to ensure no assertions will occur, and checked to ensure it is not already associated with a <code><a class="el" href="../../d5/df6/structnlx__kcore__buffer__event.html">nlx_kcore_buffer_event</a></code> object.</li>
<li>The <code><a class="el" href="../../dd/d08/group__bevcqueue.html#gae67d05e9d250b186c38319d87252910d">bev_link_bless()</a></code> function is called to bless the object.</li>
<li>The <code><a class="el" href="../../d1/d4b/structnlx__core__buffer__event.html">nlx_core_buffer_event</a></code> is unmapped (it remains pinned).</li>
<li>The <code><a class="el" href="../../d5/df6/structnlx__kcore__buffer__event.html">nlx_kcore_buffer_event</a></code> object is added to the <code><a class="el" href="../../d5/d0b/structnlx__kcore__transfer__mc.html#a314989a39b362f2852bcb4e4a1255898">nlx_kcore_transfer_mc::ktm_drv_bevs</a></code> list.</li>
</ul>
<p>Buffer event objects are never removed from the buffer event queue until the transfer machine is stopped.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-tmstop">Stopping a Transfer Machine</a></dd></dl>
<h2><a class="anchor" id="LNetDRVDLD-lspec-tmstart"></a>
Starting a Transfer Machine</h2>
<p>While starting a transfer machine, the user space core performs a <code><a class="el" href="../../df/d9e/group___l_net_dev.html#gadb3f78ab30d5ac26541931bf4e5e9516">M0_LNET_TM_START</a></code> ioctl request.</p>
<p>The <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> subroutine uses the helper function <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#gacca7f081b1af30e2331a0617979afc21">nlx_dev_ioctl_tm_start()</a></code> to complete starting the transfer machine. The following tasks are performed.</p><ul>
<li>The parameters are validated to ensure no assertions will occur.</li>
<li>The <code><a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html">nlx_core_transfer_mc</a></code> object is pinned in kernel memory.</li>
<li>A <code><a class="el" href="../../d5/d0b/structnlx__kcore__transfer__mc.html">nlx_kcore_transfer_mc</a></code> is allocated.</li>
<li>Information required to map the pinned object is saved in the <code><a class="el" href="../../d5/d0b/structnlx__kcore__transfer__mc.html">nlx_kcore_transfer_mc</a></code> object.</li>
<li>The <code><a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html">nlx_core_transfer_mc</a></code> is mapped using <code>kmap()</code> because the core operation may sleep.</li>
<li>The <code><a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html">nlx_core_transfer_mc</a></code> is checked to ensure it is not already associated with a <code><a class="el" href="../../d5/d0b/structnlx__kcore__transfer__mc.html">nlx_kcore_transfer_mc</a></code> object and that it will not cause assertions.</li>
<li><code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html#a9d081c6953a712341f2c2cce83032255">nlx_kcore_ops::ko_tm_start()</a></code> is used to complete the kernel TM start.</li>
<li>The <code><a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html">nlx_core_transfer_mc</a></code> is unmapped (it remains pinned).</li>
<li>The <code><a class="el" href="../../d5/d0b/structnlx__kcore__transfer__mc.html">nlx_kcore_transfer_mc</a></code> is added to the <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#ad969ec059adf6fa4d19d0b405f387f0d">nlx_kcore_domain::kd_drv_tms</a></code> list.</li>
</ul>
<h2><a class="anchor" id="LNetDRVDLD-lspec-tmstop"></a>
Stopping a Transfer Machine</h2>
<p>While stopping a transfer machine, the user space core performs a <code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga1cdddba87b15e8f14adaf4c5083e231c">M0_LNET_TM_STOP</a></code> ioctl request.</p>
<p>The <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> subroutine uses the helper function <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga9ec6703f99a0c4e78f53e08cffb9f667">nlx_dev_ioctl_tm_stop()</a></code> to complete stopping the transfer machine. The following tasks are performed.</p><ul>
<li>The parameters are validated to ensure no assertions will occur.</li>
<li>The transfer machine is removed from the <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#ad969ec059adf6fa4d19d0b405f387f0d">nlx_kcore_domain::kd_drv_tms</a></code> list.</li>
<li>The buffer event objects on the <code><a class="el" href="../../d5/d0b/structnlx__kcore__transfer__mc.html#a314989a39b362f2852bcb4e4a1255898">nlx_kcore_transfer_mc::ktm_drv_bevs</a></code> list are unpinned and their corresponding <code><a class="el" href="../../d5/df6/structnlx__kcore__buffer__event.html">nlx_kcore_buffer_event</a></code> objects freed.</li>
<li>The <code><a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html">nlx_core_transfer_mc</a></code> is mapped.</li>
<li><code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html#a0e56f629624474b2e4bbe1840d07319e">nlx_kcore_ops::ko_tm_stop()</a></code> is used to stop the transfer machine.</li>
<li>The <code><a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html">nlx_core_transfer_mc</a></code> is unmapped and unpinned.</li>
</ul>
<h2><a class="anchor" id="LNetDRVDLD-lspec-buf"></a>
Transfer Machine Buffer Queue Operations</h2>
<p>Several LNet core interfaces operate on buffers and transfer machine queues. In all user transport cases, the shared objects, <code><a class="el" href="../../d7/df3/structnlx__core__buffer.html">nlx_core_buffer</a></code> and <code><a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html">nlx_core_transfer_mc</a></code>, must have been previously shared with the kernel, through use of the <code><a class="el" href="../../df/d9e/group___l_net_dev.html#gab70c3b3e49bd6f3871a12f1e49b2922b">M0_LNET_BUF_REGISTER</a></code> and <code><a class="el" href="../../df/d9e/group___l_net_dev.html#gadb3f78ab30d5ac26541931bf4e5e9516">M0_LNET_TM_START</a></code> ioctl requests, respectively.</p>
<p>The ioctl requests available to the user space core for managing buffers and transfer machine buffer queues are as follows.</p><ul>
<li><code><a class="el" href="../../df/d9e/group___l_net_dev.html#gad3a52e7ed4c59376d54738acb99af005">M0_LNET_BUF_MSG_RECV</a></code> </li>
<li><code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga6160a0de3eb8d7dbe8c715cfd3ec5db4">M0_LNET_BUF_MSG_SEND</a></code> </li>
<li><code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga5cfe5d931241ea690c72640ddb877658">M0_LNET_BUF_ACTIVE_RECV</a></code> </li>
<li><code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga89ebe6d201bca9c323a5184a21770bcb">M0_LNET_BUF_ACTIVE_SEND</a></code> </li>
<li><code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga6cb38d6d097b539d7f83e01f9509ecbf">M0_LNET_BUF_PASSIVE_RECV</a></code> </li>
<li><code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga5d4119ae5a0600bf43b8b87a648f8239">M0_LNET_BUF_PASSIVE_SEND</a></code> </li>
<li><code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga949b2c3987936d5cf8238ad7128b305f">M0_LNET_BUF_DEL</a></code> </li>
</ul>
<p>The ioctl requests are handled by the following helper functions, respectively.</p><ul>
<li><code>nlx_dev_ioctl_buf_msg_recv()</code> </li>
<li><code>nlx_dev_ioctl_buf_msg_send()</code> </li>
<li><code>nlx_dev_ioctl_buf_active_recv()</code> </li>
<li><code>nlx_dev_ioctl_buf_active_send()</code> </li>
<li><code>nlx_dev_ioctl_buf_passive_recv()</code> </li>
<li><code>nlx_dev_ioctl_buf_passive_send()</code> </li>
<li><code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#gaf99ebb853d1c76827d899a0da94b5be6">nlx_dev_ioctl_buf_del()</a></code> </li>
</ul>
<p>These helper functions each perform similar tasks.</p><ul>
<li>The parameters are validated to ensure no assertions will occur.</li>
<li>The <code><a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html">nlx_core_transfer_mc</a></code> and <code><a class="el" href="../../d7/df3/structnlx__core__buffer.html">nlx_core_buffer</a></code> are mapped using <code>kmap()</code> because the core operations may sleep.</li>
<li>The corresponding kernel core operation is called.<ul>
<li><code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html#adb7dcbad76ea836e17df25daf60a4d7a">nlx_kcore_ops::ko_buf_msg_recv()</a></code> </li>
<li><code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html#a7725f01fe42f83af6a1e0a4e339ff28d">nlx_kcore_ops::ko_buf_msg_send()</a></code> </li>
<li><code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html#a524b1d4524447db329245b97a8888b98">nlx_kcore_ops::ko_buf_active_recv()</a></code> </li>
<li><code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html#a2633a7c7b0055be0d999e33716d54ba3">nlx_kcore_ops::ko_buf_active_send()</a></code> </li>
<li><code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html#addb4c9682b57c0d84285876b085460a4">nlx_kcore_ops::ko_buf_passive_recv()</a></code> </li>
<li><code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html#ab380d9d895cb8dc3a126dd742f64c0a5">nlx_kcore_ops::ko_buf_passive_send()</a></code> </li>
<li><code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html#a85d94c16b2896d3ae363a3bec52d1c3c">nlx_kcore_ops::ko_buf_del()</a></code> </li>
</ul>
</li>
<li>The <code><a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html">nlx_core_transfer_mc</a></code> and <code><a class="el" href="../../d7/df3/structnlx__core__buffer.html">nlx_core_buffer</a></code> are unmapped.</li>
</ul>
<h2><a class="anchor" id="LNetDRVDLD-lspec-event"></a>
Waiting for Buffer Events</h2>
<p>To wait for buffer events, the user space core performs a <code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga5fec6938ee8c7fd8592b697c634e79f9">M0_LNET_BUF_EVENT_WAIT</a></code> ioctl request.</p>
<p>The <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> subroutine uses the helper function <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga084bef0cb441c5a1d2eb61f194672be4">nlx_dev_ioctl_buf_event_wait()</a></code> to perform the wait operation. The following tasks are performed.</p>
<ul>
<li>The parameters are validated to ensure no assertions will occur.</li>
<li>The <code><a class="el" href="../../d8/df5/structnlx__kcore__ops.html#aed0e8e7c28dea5cb7c65ffe96de98bc5">nlx_kcore_ops::ko_buf_event_wait()</a></code> function is called.</li>
</ul>
<h2><a class="anchor" id="LNetDRVDLD-lspec-nids"></a>
Node Identifier Support</h2>
<p>The user space core uses the <code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga515e54b40a50371b20bc45917888f8fe">M0_LNET_NIDSTR_DECODE</a></code> and <code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga3cec91339bba374817850a2613a0875e">M0_LNET_NIDSTR_ENCODE</a></code> requests to decode and encode NID strings, respectively.</p>
<p>The <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> subroutine uses the helper function <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga6d7cae2c550d0b0931b613556e97ee18">nlx_dev_ioctl_nidstr_decode()</a></code> to decode the string. The following tasks are performed.</p>
<ul>
<li>The parameter is validated to ensure no assertions will occur.</li>
<li>The <code>libcfs_str2nid()</code> function is called to convert the string to a NID.</li>
<li>In the case the result is LNET_NID_ANY, -EINVAL is returned, otherwise the <code>dn_nid</code> field is set.</li>
</ul>
<p>The <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> subroutine uses the helper function <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga1972e47a32dad177812e6871b70ddd7b">nlx_dev_ioctl_nidstr_encode()</a></code> to decode the string. The following tasks are performed.</p>
<ul>
<li>The parameter is validated to ensure no assertions will occur.</li>
<li>The <code>libcfs_nid2str()</code> function is called to convert the string to a NID.</li>
<li>The resulting string is copied to the <code>dn_buf</code> field.</li>
</ul>
<p>The user space core uses the <code><a class="el" href="../../df/d9e/group___l_net_dev.html#gad30e698f8261f6659a86b6038f8c6aa0">M0_LNET_NIDSTRS_GET</a></code> to obtain the list of NID strings for the local LNet interfaces.</p>
<p>The <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> subroutine uses the helper function <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#gae258fed3f042a408c41e81eebdff3ad0">nlx_dev_ioctl_nidstrs_get()</a></code> to decode the string. The following tasks are performed.</p>
<ul>
<li>The parameters are validated to ensure no assertions will occur.</li>
<li>The <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga0436ff7e61bb0ac8404dfb2e842ad57b">nlx_core_nidstrs_get()</a></code> API is called to get the list of NID strings.</li>
<li>The buffer size required to store the strings is computed (sum of the string lengths of the NID strings, plus trailing nuls, plus one).</li>
<li>A temporary buffer of the required size is allocated.</li>
<li>The NID strings are copied consecutively into the buffer. Each NID string is nul terminated and an extra nul is written after the final NID string.</li>
<li>The contents of the buffer is copied to the user space buffer.</li>
<li>The <code><a class="el" href="../../d6/d8a/group___k_l_net_core.html#ga3d185395f4e0f14f6606d18a56ab2b9a">nlx_core_nidstrs_put()</a></code> API is called to release the list of NID strings.</li>
<li>The temporary buffer is freed.</li>
<li>The number of NID strings is returned on success; <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> returns this positive number instead of the typical 0 for success.</li>
<li>The value -EFBIG is returned if the buffer is not big enough.</li>
</ul>
<h2><a class="anchor" id="LNetDRVDLD-lspec-state"></a>
State Specification</h2>
<p>The LNet device driver does not introduce its own state model but operates within the frameworks defined by the Motr Networking Module and the Kernel device driver interface. In general, resources are pinned and allocated when an object is first shared with the kernel by the user space process and are freed and unpinned when the user space requests. To ensure there is no resource leakage, remaining resources are freed when the <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga120c166ef9fa98855c20aa3b67ff519b">nlx_dev_close()</a></code> API is called.</p>
<p>The resources managed by the driver are tracked by the following lists:</p><ul>
<li><code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#a978a5b6b9b1a3ccc14e97e570dbac597">nlx_kcore_domain::kd_cd_loc</a></code> (a single item)</li>
<li><code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#ad969ec059adf6fa4d19d0b405f387f0d">nlx_kcore_domain::kd_drv_tms</a></code> </li>
<li><code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#a55786452777befef3ae03b20b793e200">nlx_kcore_domain::kd_drv_bufs</a></code> </li>
<li><code><a class="el" href="../../d5/d0b/structnlx__kcore__transfer__mc.html#a314989a39b362f2852bcb4e4a1255898">nlx_kcore_transfer_mc::ktm_drv_bevs</a></code> </li>
</ul>
<p>Each <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html">nlx_kcore_domain</a></code> object has 2 valid states which can be determined by inspecting the <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#a978a5b6b9b1a3ccc14e97e570dbac597">nlx_kcore_domain::kd_cd_loc</a></code> field:</p><ul>
<li><code>nlx_core_kmem_loc_is_empty(&amp;kd_cd_loc)</code>: The device is newly opened and the <code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga604193f0a227cfe0ef279f652a513684">M0_LNET_DOM_INIT</a></code> ioctl request has not yet been performed.</li>
<li><code>nlx_core_kmem_loc_invariant(&amp;kd_cd_loc)</code>: The <code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga604193f0a227cfe0ef279f652a513684">M0_LNET_DOM_INIT</a></code> ioctl request has been performed, associating it with a <code><a class="el" href="../../d8/d81/structnlx__core__domain.html">nlx_core_domain</a></code> object. In this state, the <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html">nlx_kcore_domain</a></code> is ready for use and remains in this state until finalized.</li>
</ul>
<h2><a class="anchor" id="LNetDRVDLD-lspec-thread"></a>
Threading and Concurrency Model</h2>
<p>The LNet device driver has no threads of its own. It operates within the context of a user space process and a kernel thread operating on behalf of that process. All operations are invoked through the Linux device driver interface, specifically the operations defined on the <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#gaea258449b1b71d6f31a7d0366d1a7d72">nlx_dev_file_ops</a></code> object. The <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#gac97dbd0a0eab9e4fe0bb58122e457c8d">nlx_dev_open()</a></code> and <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga120c166ef9fa98855c20aa3b67ff519b">nlx_dev_close()</a></code> are guaranteed to be called once each for each kernel <code>file</code> object, and calls to these operations are guaranteed to not overlap with calls to the <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> operation. However, multiple calls to <code><a class="el" href="../../d8/d9e/group___l_net_dev_internal.html#ga00738e2cd72d209874016020f1c629b0">nlx_dev_ioctl()</a></code> may occur simultaneously on different threads.</p>
<p>Synchronization of device driver resources is controlled by a single mutex per domain, the <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#a8faa1ac621bb022f0a61900aeed08ab2">nlx_kcore_domain::kd_drv_mutex</a></code>. This mutex must be held while manipulating the resource lists, <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#ad969ec059adf6fa4d19d0b405f387f0d">nlx_kcore_domain::kd_drv_tms</a></code>, <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#a55786452777befef3ae03b20b793e200">nlx_kcore_domain::kd_drv_bufs</a></code> and <code><a class="el" href="../../d5/d0b/structnlx__kcore__transfer__mc.html#a314989a39b362f2852bcb4e4a1255898">nlx_kcore_transfer_mc::ktm_drv_bevs</a></code>.</p>
<p>The mutex may also be used to serialize driver ioctl requests, such as in the case of <code><a class="el" href="../../df/d9e/group___l_net_dev.html#ga604193f0a227cfe0ef279f652a513684">M0_LNET_DOM_INIT</a></code>.</p>
<p>The driver mutex must be obtained before any other Net or Kernel Core mutex.</p>
<p>Mapping of <code><a class="el" href="../../d4/d08/structnlx__core__kmem__loc.html">nlx_core_kmem_loc</a></code> object references can be performed without synchronization, because the <code><a class="el" href="../../d4/d08/structnlx__core__kmem__loc.html">nlx_core_kmem_loc</a></code> never changes after an object is pinned, and the mapped pointer is specified to never be stored in a shared location, i.e. only on the stack. The functions that unpin shared objects have invariants and pre-conditions to ensure that the objects are no longer in use and can be unpinned without causing a mapping failure.</p>
<p>Cleanup of kernel resources for user domains synchronizes with the Kernel Core LNet EQ callback by use of the <a class="el" href="../../d5/d0b/structnlx__kcore__transfer__mc.html#a5dd563a1e07b32f10185e50a08e4bd41">nlx_kcore_transfer_mc::ktm_bevq_lock</a> and the nlx_kcore_transfer_mc::ktm_sem, as discussed in <a class="el" href="../../db/dd7/_k_l_net_core_d_l_d.html#KLNetCoreDLD-lspec-thread">Threading and Concurrency Model</a>.</p>
<h2><a class="anchor" id="LNetDRVDLD-lspec-numa"></a>
NUMA optimizations</h2>
<p>The LNet device driver does not allocate threads. The user space application can control thread processor affiliation by confining the threads it uses to access the device driver.</p>
<hr/>
 <h1><a class="anchor" id="LNetDRVDLD-conformance"></a>
Conformance</h1>
<ul>
<li><b>i.m0.net.xprt.lnet.user-space</b> The <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec">Logical Specification</a> covers how each LNet Core operation in user space can be implemented using the driver ioctl requests.</li>
<li><b>i.m0.net.xprt.lnet.dev.pin-objects</b> See <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-dominit">Domain Initialization</a>, <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-reg">Buffer Registration and Deregistration</a>, <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-bev">Managing the Buffer Event Queue</a>, <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-tmstart">Starting a Transfer Machine</a>.</li>
<li><b>i.m0.net.xprt.lnet.dev.resource-tracking</b> See <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-domfini">Domain Finalization</a>.</li>
<li><b>i.m0.net.xprt.lnet.dev.safe-sharing</b> See <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-ioctl">Ioctl Request Behavior</a>, specifically the paragraph covering the use of pinned pages.</li>
<li><b>i.m0.net.xprt.lnet.dev.assert-free</b> See <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-ioctl">Ioctl Request Behavior</a>.</li>
<li><b>i.m0.net.xprt.lnet.dev.minimal-mapping</b> None of the work flows in the <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec">Logical Specification</a> require that objects remain mapped across ioctl calls. The <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-ioctl">Ioctl Request Behavior</a> calls for use of <code>kmap_atomic()</code> when possible. <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-domfini">Domain Finalization</a>, <a class="el" href="../../da/d74/_l_net_d_r_v_d_l_d.html#LNetDRVDLD-lspec-ioctl">Ioctl Request Behavior</a>.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="LNetDRVDLD-ut"></a>
Unit Tests</h1>
<p>LNet Device driver unit tests focus on the covering the common code paths. Code paths involving most Kernel LNet Core operations and the device wrappers will be handled as part of testing the user transport. Even so, some tests are most easily performed by coordinating user space code with kernel unit tests. The following strategy will be used:</p><ul>
<li>When the LNet unit test suite is initialized in the kernel, it creates a /proc/m0_lnet_ut file, registering read and write file operations.</li>
<li>The kernel UT waits (e.g. on a condition variable with a timeout) for the user space program to synchronize. It may time out and fail the UT if the user space program does not synchronize quickly enough, e.g. after a few seconds.</li>
<li>A user space program is started concurrently with the kernel unit tests.</li>
<li>The user space program waits for the /proc/m0_lnet_ut to appear.</li>
<li>The user space program writes a message to the /proc/m0_lnet_ut to synchronize with the kernel unit test.</li>
<li>The write system call operation registered for /proc/m0_lnet_ut signals the condition variable that the kernel UT is waiting on.</li>
<li>The user space program loops.<ul>
<li>The user space program reads the /proc/m0_lnet_ut for instructions.</li>
<li>Each instruction tells the user space program which test to perform; there is a special instruction to tell the user space program the unit test is complete.</li>
<li>The user space program writes the test result back.</li>
</ul>
</li>
<li>When the LNet unit test suite is finalized in the kernel, the /proc/m0_lnet_ut file is removed.</li>
</ul>
<p>While ioctl requests on the /dec/m0lnet device could be used for such coordination, this would result in unit test code being mixed into the production code. The use of a /proc file for coordinating unit tests ensures this is not the case.</p>
<p>To enable unit testing of the device layer without requiring full kernel core behavior, the device layer accesses kernel core operations indirectly via the <code><a class="el" href="../../d1/dab/structnlx__kcore__domain.html#aa7a66970686c19e424ee12541e1ba2e8">nlx_kcore_domain::kd_drv_ops</a></code> operation structure. During unit tests, these operations can be changed to call mock operations instead of the real kernel core operations. This allows testing of things such as pinning and mapping pages without causing real core behavior to occur.</p>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000098">Test:</a></b></dt><dd>Initializing the device causes it to be registered and visible in the file system.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000099">Test:</a></b></dt><dd>The device can be opened and closed.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000100">Test:</a></b></dt><dd>Reading or writing the device fails.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000101">Test:</a></b></dt><dd>Unsupported ioctl requests fail.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000102">Test:</a></b></dt><dd>A <a class="el" href="../../d8/d81/structnlx__core__domain.html">nlx_core_domain</a> can be initialized and finalized, testing common code paths and the strategy of pinning and unpinning pages.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000103">Test:</a></b></dt><dd>A <a class="el" href="../../d8/d81/structnlx__core__domain.html">nlx_core_domain</a> is initialized, and several <a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html">nlx_core_transfer_mc</a> objects can be started and then stopped, the domain finalized and the device is closed. No cleanup is necessary.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000104">Test:</a></b></dt><dd>A <a class="el" href="../../d8/d81/structnlx__core__domain.html">nlx_core_domain</a> is initialized, and the same <a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html">nlx_core_transfer_mc</a> object is started twice, the error is detected. The remaining transfer machine is stopped. The device is closed. No cleanup is necessary.</dd></dl>
<dl class="test"><dt><b><a class="el" href="../../d4/df6/test.html#_test000105">Test:</a></b></dt><dd>A <a class="el" href="../../d8/d81/structnlx__core__domain.html">nlx_core_domain</a>, and several <a class="el" href="../../d3/d98/structnlx__core__transfer__mc.html">nlx_core_transfer_mc</a> objects can be registered, then the device is closed, and cleanup occurs.</dd></dl>
<p>Buffer and buffer event management tests and more advanced domain and transfer machine test will be added as part of testing the user space transport.</p>
<hr/>
 <h1><a class="anchor" id="LNetDRVDLD-st"></a>
System Tests</h1>
<p>System testing will be performed as part of the transport operation system test.</p>
<hr/>
 <h1><a class="anchor" id="LNetDRVDLD-O"></a>
Analysis</h1>
<ul>
<li>The algorithmic complexity of ioctl requests is constant, except<ul>
<li>the complexity of pinning a buffer varies with the number of pages in the buffer,</li>
<li>the complexity of stopping a transfer machine is proportional to the number of buffer events pinned.</li>
</ul>
</li>
<li>The time to pin or <code>kmap()</code> a page is unpredictable, and depends, at the minimum, on current system load, memory consumption and other LNet users. For this reason, <code>kmap_atomic()</code> should be used when a shared page can be used without blocking.</li>
<li>The driver layer consumes a small amount of additional memory in the form of additional fields in the various kernel core objects.</li>
<li>The use of stack pointers instead of pointers within kernel core objects while mapping shared objects avoids the need to synchronize the use of pointers within the kernel core objects themselves.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="LNetDRVDLD-ref"></a>
References</h1>
<ul>
<li><a href="http://lwn.net/Kernel/LDD3/">Linux Device Drivers, Third Edition By Jonathan Corbet, Alessandro Rubini, Greg Kroah-Hartman, 2005</a></li>
<li><a href="http://lwn.net/Articles/119652/">The new way of ioctl(), Jonathan Corbet, 2005</a></li>
<li>HLD of Motr LNet Transport : For documentation links, please refer to this file : doc/motr-design-doc-list.rst</li>
<li><a class="el" href="../../d6/de0/_l_net_d_l_d.html">LNet Transport DLD</a></li>
<li><a class="el" href="../../d8/d7d/_u_l_net_core_d_l_d.html">LNet Transport User Space Core DLD</a></li>
<li><a class="el" href="../../db/dd7/_k_l_net_core_d_l_d.html">LNet Transport Kernel Space Core DLD</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d3/dd6/_d_l_d_i_x.html">Detailed Designs</a></li><li class="navelem"><a class="el" href="../../d6/de0/_l_net_d_l_d.html">LNet Transport DLD</a></li>
    <li class="footer">Generated on Fri May 20 2022 10:35:33 for Motr by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
