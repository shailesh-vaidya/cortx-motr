<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Motr: Copy Machine DLD</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Motr
   &#160;<span id="projectnumber">M0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dd/d33/_c_m_d_l_d.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Copy Machine DLD </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-ovw">Overview</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-def">Definitions</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-req">Requirements</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-highlights">Design Highlights</a></li>
<li><a class="el" href="../../d9/d52/_c_m_d_l_d-fspec.html#CMDLD-fspec">Functional Specification</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec">Logical Specification</a><ul>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-state">Copy Machine State diagram</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-setup">Copy machine setup</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-ready">Copy machine ready</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-start">Copy machine operation start</a><ul>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-cp-pump">Copy packet pump</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-active">Copy machine activation</a></li>
</ul>
</li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-sliding-window">Copy machine sliding window</a></li>
<li>CMDLD-lspec-cm-sliding-window-persistance</li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-stop">Copy machine stop</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-fini">Copy machine finalisation</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-thread">Threading and Concurrency Model</a></li>
</ul>
</li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-conformance">Conformance</a></li>
<li>CMDLD-addb</li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-ut">Unit Tests</a></li>
<li><a class="el" href="../../d6/d1f/_d_l_d.html#DLD-O">Analysis</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-ref">References</a></li>
</ul>
<hr/>
 <h1><a class="anchor" id="CMDLD-ovw"></a>
Overview</h1>
<p>This document explains the detailed level design for generic part of the copy machine module.</p>
<hr/>
 <h1><a class="anchor" id="CMDLD-def"></a>
Definitions</h1>
<p>Please refer to "Definitions" section in "HLD of copy machine and agents" in <a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-ref">References</a></p>
<hr/>
 <h1><a class="anchor" id="CMDLD-req"></a>
Requirements</h1>
<p>The requirements below are grouped by various milestones.</p>
<h2><a class="anchor" id="cm-setup-req"></a>
Copy machine Requirements</h2>
<ul>
<li><b>r.cm.generic.invoke</b> Copy machine generic routines should be invoked from copy machine service specific code.</li>
<li><b>r.cm.generic.specific</b> Copy machine generic routines should accordingly invoke copy machine specific operations.</li>
<li><b>r.cm.synchronise</b> Copy machine generic should provide synchronised access to members of cm.</li>
<li><b>r.cm.resource.manage</b> Copy machine specific resources should be managed by copy machine specific implementation, e.g. buffer pool, etc.</li>
<li><b>r.cm.failure</b> Copy machine should handle various types of failures.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="CMDLD-highlights"></a>
Design Highlights</h1>
<ul>
<li>Copy machine is implemented as motr state machine.</li>
<li>All the registered types of copy machines can be initialised using various interfaces and also from motr setup.</li>
<li>Once started, each copy machine type is registered with the request handler as a service.</li>
<li>A copy machine service can be started using "motr setup" utility or separately.</li>
<li>Once started copy machine remains idle until further event happens.</li>
<li>Copy machine copy packets are implemented as foms, and are started by copy machine using request handler.</li>
<li>Copy machine type specific event triggers copy machine operation, (e.g. TRIGGER FOP for SNS Repair). This allocates copy machine specific resources and creates copy packets.</li>
</ul>
<p>The complete data restructuring process of copy machine follows non-blocking processing model of Motr design.</p><ul>
<li><p class="startli">Copy machine maintains the list of aggregation groups being processed and implements a sliding window over this list to keep track of restructuring process and manage resources efficiently.</p>
<hr/>
 </li>
</ul>
<h1><a class="anchor" id="CMDLD-lspec"></a>
Logical Specification</h1>
<p>Please refer to "Logical Specification" section in "HLD of copy machine and
   agents" in <a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-ref">References</a></p><ul>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-state">Copy Machine State diagram</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-setup">Copy machine setup</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-prepare">Copy machine prepare</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-ready">Copy machine ready</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-start">Copy machine operation start</a><ul>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-cp-pump">Copy packet pump</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-active">Copy machine activation</a></li>
</ul>
</li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-sliding-window">Copy machine sliding window</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-sliding-window-persistence">Copy machine sliding window persistence</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-stop">Copy machine stop</a></li>
<li><a class="el" href="../../dd/d33/_c_m_d_l_d.html#CMDLD-lspec-cm-fini">Copy machine finalisation</a></li>
</ul>
<h2><a class="anchor" id="CMDLD-lspec-state"></a>
Copy Machine State diagram</h2>
<div class="dotgraph">
<img src="../../dot_inline_dotgraph_5.png" alt="dot_inline_dotgraph_5.png" border="0" usemap="#dot_inline_dotgraph_5.map"/>
<map name="dot_inline_dotgraph_5.map" id="dot_inline_dotgraph_5.map"></map>
</div>
<h2><a class="anchor" id="CMDLD-lspec-cm-setup"></a>
Copy machine setup</h2>
<p>After copy machine is successfully initialised (<a class="el" href="../../d0/da4/group___c_m.html#ga41cca8107e1f141a2b1ba01c22d6fba9">m0_cm_init()</a>), it is configured as part of the copy machine service startup by invoking <a class="el" href="../../d0/da4/group___c_m.html#ga0c51f2516f9cc778910280cb1193961d">m0_cm_setup()</a>. This performs copy machine specific setup by invoking <a class="el" href="../../dd/d81/structm0__cm__ops.html#a8c72924db9215b8314e7c3b5d2de40f9">m0_cm_ops::cmo_setup()</a>. Once successfully completed the copy machine is transitioned into M0_CMS_IDLE state. In case of setup failure, copy machine is transitioned to M0_CMS_FAIL state, this also fails copy machine service startup, and thus copy machine is finalised during copy machine service finalisation.</p>
<h2><a class="anchor" id="CMDLD-lspec-cm-prepare"></a>
Copy machine prepare</h2>
<p>Initialise local sliding window and sliding window persistent store. Persist sliding window after initialisation and proceed to READY phase.</p>
<h2><a class="anchor" id="CMDLD-lspec-cm-ready"></a>
Copy machine ready</h2>
<p>In case of multiple nodes, every copy machine replica allocates an instance of struct <a class="el" href="../../d6/d1b/structm0__cm__proxy.html">m0_cm_proxy</a> representing a particular remote replica and establishes rpc connection and session with the same. See <a class="el" href="../../dc/d86/group___c_m_p_r_o_x_y.html">Copy machine proxy</a> for more details. After successfully establishing the rpc connections, copy machine specific m0_cm_ops::cmo_ready() operation is invoked to further setup the specific copy machine data structures. After creating proxies representing the remote replicas, for each remote replica the READY FOPs are allocated and initialised with the calculated local sliding window. The copy machine then broadcasts these READY FOPs to every remote replica using the rpc connection in the corresponding <a class="el" href="../../d6/d1b/structm0__cm__proxy.html">m0_cm_proxy</a>. A READY FOP is a one-way fop and thus do not have a reply associated with it. Once every replica receives READY FOPs from all the corresponding remote replicas, the copy machine proceeds to the START phase. </p><dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="../../d0/da4/group___c_m.html#ga0566e55dd53dbe63adedd614096948ea">m0_cm_ready</a></dd></dl>
<h2><a class="anchor" id="CMDLD-lspec-cm-start"></a>
Copy machine operation start</h2>
<p>After copy machine service is successfully started, it is ready to perform its respective tasks (e.g. SNS Repair). On receiving a trigger event (i.e failure in case of sns repair) copy machine transitions into M0_CMS_ACTIVE state once copy machine specific startup tasks are complete (<a class="el" href="../../d0/da4/group___c_m.html#ga9af3ca959e6fbe57f613251d16fe65a6">m0_cm_start()</a>). In case of copy machine startup failure, copy machine transitions into M0_CMS_FAIL state, once failure is handled, copy machine transitions back into M0_CMS_IDLE state and waits for further events.</p>
<h3><a class="anchor" id="CMDLD-lspec-cm-cp-pump"></a>
Copy packet pump</h3>
<p>Copy machine implements a special FOM type, viz. copy packet pump FOM to create copy packets (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/d67/_c_p_d_l_d.html">Copy Packet DLD</a>). Copy <a class="el" href="../../df/de8/structpacket.html">packet</a> pump FOM creates <a class="el" href="../../d8/d6f/ut_2sync_8c.html#a6e096170b1a10d82c6e08fbafaf92355">copy</a> packets until resources permit and goes to sleep <a class="el" href="../../db/dcd/m0t1fs_2linux__kernel_2dir_8c.html#a53627ba6b2fc486e0dfb6b4dd0d55eb1">if</a> no <a class="el" href="../../d0/d5d/ut_2sm_8c.html#a462318a97be8f41d7970bd97f3276852">more</a> packets can <a class="el" href="../../d0/df1/iter__ut_8c.html#aa1e88453a5be7e5aa3334108a15171e8">be</a> created. Using non-blocking FOM infrastructure to <a class="el" href="../../d4/d44/group__cas.html#gad8b4f23dd455dd49c06ff67933b2b18d">create</a> <a class="el" href="../../d8/d6f/ut_2sync_8c.html#a6e096170b1a10d82c6e08fbafaf92355">copy</a> packets enables <a class="el" href="../../d8/d6f/ut_2sync_8c.html#a6e096170b1a10d82c6e08fbafaf92355">copy</a> <a class="el" href="../../d7/d93/mdservice_2ut_2mdstore_8c.html#a31ac5fe4c426986a4a393057ae289040">machine</a> to handle blocking operations performed <a class="el" href="../../db/dcd/m0t1fs_2linux__kernel_2dir_8c.html#a1c12eea8b267b769c535cd875e63b44d">while</a> acquiring various resources efficiently. Copy <a class="el" href="../../df/de8/structpacket.html">packet</a> pump FOM is created when the <a class="el" href="../../d8/d6f/ut_2sync_8c.html#a6e096170b1a10d82c6e08fbafaf92355">copy</a> <a class="el" href="../../d7/d93/mdservice_2ut_2mdstore_8c.html#a31ac5fe4c426986a4a393057ae289040">machine</a> operation starts and is woken up (iff <a class="el" href="../../da/d8d/ut_2extmap_8c.html#a93ac04629f844f68ac58615004a135e7">it</a> was <a class="el" href="../../d1/d59/group__fom.html#gga4077b0ebdee71b348b8c663d9dcc908eafd6a0e4343048b10646dd2976cc5ad18">IDLE</a>) as the required resources become available (e.g. when a <a class="el" href="../../d8/d6f/ut_2sync_8c.html#a6e096170b1a10d82c6e08fbafaf92355">copy</a> <a class="el" href="../../df/de8/structpacket.html">packet</a> is finalised and its corresponding <a class="el" href="../../dd/da2/structbuffer.html">buffer</a> is released to <a class="el" href="../../d8/d6f/ut_2sync_8c.html#a6e096170b1a10d82c6e08fbafaf92355">copy</a> <a class="el" href="../../d7/d93/mdservice_2ut_2mdstore_8c.html#a31ac5fe4c426986a4a393057ae289040">machine</a> specific <a class="el" href="../../dd/da2/structbuffer.html">buffer</a> <a class="el" href="../../d4/d6a/test__pm_8c.html#a8b1bf9675fb77ab02a105e260477a59b">pool</a>). </dd>
<dd>
struct <a class="el" href="../../d8/dda/structm0__cm__cp__pump.html">m0_cm_cp_pump</a></dd></dl>
<h3><a class="anchor" id="CMDLD-lspec-cm-active"></a>
Copy machine activation</h3>
<p>After creating initial number of copy packets, copy machine broadcasts READY FOPs with its corresponding sliding window information to all its replicas in the pool. Every copy machine replica, after receiving READY FOPs from all its replicas in the pool, transitions into M0_CMS_ACTIVE state.</p>
<h2><a class="anchor" id="CMDLD-lspec-cm-sliding-window"></a>
Copy machine sliding window</h2>
<p>Generic copy machine infrastructure provides data structures and interfaces which are used to implement sliding window. Copy machine sliding window is based on aggregation group identifiers. Copy machine maintains two lists of aggregation groups, i) aggregation groups having only outgoing copy packets, viz. <a class="el" href="../../dd/df9/structm0__cm.html">m0_cm</a>:: cm_aggr_grps_out. ii) aggregation groups having only incoming copy packets, viz. <a class="el" href="../../dd/df9/structm0__cm.html">m0_cm</a>:: cm_aggr_grps_in. </p><dl class="section note"><dt>Note</dt><dd>Both the lists are insertion sorted, in ascending order. Copy machine sliding window is mainly implemented on <a class="el" href="../../dd/df9/structm0__cm.html#a950333fb9b8bb352f813d2c517cef904">m0_cm::cm_aggr_grps_in</a> list, i.e. for aggregation groups having incoming copy packets. The idea is that every sender copy machine replica should send copy packet iff the receiving replica is able to receive it. If the receiver is able to receive the copy packet for a particular aggregation group, implies that the corresponding aggregation group is already created, initialised and is present in receiver's <a class="el" href="../../dd/df9/structm0__cm.html#a950333fb9b8bb352f813d2c517cef904">m0_cm::cm_aggr_grps_in</a> list. Generic copy machine infrastructure provides interfaces in-order to query and update the sliding window, viz. m0_cm_ag_hi(), m0_cm_ag_lo(), <a class="el" href="../../d1/dee/structm0__cm__sw__update.html">m0_cm_sw_update()</a> and <a class="el" href="../../d6/db9/group___c_m_a_g.html#ga212ab83fecbbc4ae12137e3023e3c3ad">m0_cm_ag_advance()</a>. In addition to generic interfaces a copy machine specific operation m0_cm::cmo_ag_next() is implemented by the specific types of copy machine in-order to calculate the next aggregation group identifier to be processed. This may involve various parameters e.g. memory, network bandwidth, cpu, etc. Sliding window is typically initialised during copy machine startup i.e. M0_CMS_READY phase and updated during finalisation of a completed aggregation group (i.e. aggregation group for which all the copy packets are processed). Periodically, updated sliding window is communicated to remote replica. m0_cm_proxy_sw_update_ast_post() <a class="el" href="../../dc/d86/group___c_m_p_r_o_x_y.html#gaf5d366e7ee605c9e1b4a5a1b45edb2c5">m0_cm_proxy_remote_update()</a></dd></dl>
<p>Updating the local sliding window and saving it to persistent store is implemented through sliding window update FOM. This helps in performing various tasks asynchronously, viz:- updating the local sliding window and saving it to persistent store. See <a class="el" href="../../db/d70/group___c_m_s_w_f_o_m.html">Sliding window update fom</a>. </p><dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="../../d1/dee/structm0__cm__sw__update.html">m0_cm_sw_update</a> </dd>
<dd>
<a class="el" href="../../d0/db0/group___c_m_s_w.html#gaa3477a7648a138308305b9968acaf96a">m0_cm_sw_update_start()</a></dd></dl>
<h2><a class="anchor" id="CMDLD-lspec-cm-sliding-window-persistence"></a>
Copy machine sliding window persistence</h2>
<p>window persistence Copy machine sliding window is an in-memory data structure to keep track of progress of some operations. When some failure happens, e.g. software or node crash, this in-memory sliding window information is lost. Copy machine has no clue how to resume the operations at the point of failure. To solve this problem, copy machine stores some information about the completed operations onto persistent storage transactionally. So when node and/or copy machine restarts after failure, it reads from persistent storage and resumes its operations.</p>
<p>The following information is to be stored on persistent storage, i) copy machine id. It is struct <a class="el" href="../../dd/df9/structm0__cm.html#a61c69d1493d5039927c9d74152eb2261">m0_cm::cm_id</a>. ii) last completed aggregation group id.</p>
<p>This information is stored in BE. It is also inserted into BE dictionary, with the key "CM ${ID}". Copy machine can find a pointer to this information from BE dictionary with proper key.</p>
<p>The following interfaces are provided to manage this information,</p><ul>
<li>m0_cm_sw_store_init() Init data on persistent storage.</li>
<li>m0_cm_sw_store_load() Load data from persistent storage.</li>
<li>m0_cm_sw_store_update() Update data to the last completed AG.</li>
</ul>
<p>These interfaces will be used in various copy machine operations to manage the persistent information. For example, m0_cm_sw_store_load() will be used in copy machine start routine to check if a previous unfinished operation is in-progress. m0_cm_sw_store_update() will be called when sliding window advances. m0_cm_sw_store_complete() is called when a copy machine operation completes. In this case, the stored AG id will be deleted from storage, to indicate that the operation has already completed successfully. When node failure happens at this time, and then restarts again, it loads from storage, and -ENOENT indicates no pending copy machine operation is progress.</p>
<p>The call sequence of interface and sliding window update FOM execution is as below:</p>
<pre class="fragment">                                        |
                                        |
                                        V
                            ------------------------------------
                            | m0_cm_sw_store_load() |
                            Read sliding window from persistent
                            store to continue from any previously
                            pending repair operation.
                            Also start sliding update FOM.
                            ------------------------------------
                                  /         \
                                 /           \
                 ret == 0       /             \ ret == -ENOENT
        A restart from failure /               \ A fresh new operation
        A valid sw is returned/                 \ No sw info on storage.
                             /                   \
                            V                     V
        -----------------------------     ----------------------------
        | setup sliding window with |     | m0_cm_sw_store_init():   |
        | the returned sw.          |     | Allocate a persistent sw |
        | CM operation will start   |     | and init it to zero. CM  |
        | from this sw.             |     | starts from scratch      |
        -----------------------------     ----------------------------
                           \                        /
                            \                      /
                             \                    /
                              \                  /
                               \                /
                                V  SWU_STORE   V
                           ---------------------------     operation completed
                  -------&gt; | m0_cm_sw_store_update() |-----------------------&gt;
                  |        ---------------------------                       |
                  |                    |                                     |
                  |                    |                                     |
                  |                    |                                     |
                  &lt;--------------------V                                     |
                    operation continue                                       |
                                                       SWU_COMPLETE          V
                                                  ----------------------------
                                                  |m0_cm_sw_store_complete():|
                                                  |delete sw info from       |
                                                  |persistent storage.       |
                                                  |m0_cm_sw_store_load()     |
                                                  |returns -ENOENT after this|
                                                  |call.                     |
                                                  ----------------------------</pre><h2><a class="anchor" id="CMDLD-lspec-cm-stop"></a>
Copy machine stop</h2>
<p>Once operation completes successfully, copy machine performs required tasks, (e.g. updating layouts, etc.) by invoking <a class="el" href="../../d0/da4/group___c_m.html#ga6742b45cf5035c7b129606c5c0fd14c3">m0_cm_stop()</a>, this transitions copy machine back to M0_CMS_IDLE state. Copy machine invokes <a class="el" href="../../d0/da4/group___c_m.html#ga6742b45cf5035c7b129606c5c0fd14c3">m0_cm_stop()</a> also in case of operational failure to broadcast STOP FOPs to its other replicas in the pool, indicating failure. This is handled specific to the copy machine type.</p>
<h2><a class="anchor" id="CMDLD-lspec-cm-fini"></a>
Copy machine finalisation</h2>
<p>As copy machine is implemented as a <a class="el" href="../../da/d3c/structm0__reqh__service.html">m0_reqh_service</a>, the copy machine finalisation path is <a class="el" href="../../da/ddc/group__reqhservice.html#gafc872fa6e0ba5d14b088c02a3b97c512">m0_reqh_service_stop()</a>-&gt;rso_stop()-&gt;<a class="el" href="../../d0/da4/group___c_m.html#ga895d1bfaa0c0fb68ffc2b8a6de9375d9">m0_cm_fini()</a>. Now, before invoking <a class="el" href="../../da/ddc/group__reqhservice.html#gafc872fa6e0ba5d14b088c02a3b97c512">m0_reqh_service_stop()</a>, <a class="el" href="../../d5/d8c/group__reqh.html#gaa9c67851d7304b6289ccc815d3c48264">m0_reqh_shutdown_wait()</a> is called, this returns when all the FOMs in the given reqh are finalised. Although there is a possibilty that the copy machine operation is in-progress while the reqh is being shutdown, this situation is taken care by <a class="el" href="../../d5/d8c/group__reqh.html#ga3843428a9c467d094f042c508a527a96">m0_reqh_shutdown()</a> mechanism as mentioned above. Thus the copy machine pump FOM (<a class="el" href="../../dd/df9/structm0__cm.html#aadf69f922a6affedba552d8972913b9b">m0_cm::cm_cp_pump</a>) is created when copy machine operation starts and destroyed when copy machine operation stops, until then it is alive within the reqh. Thus using <a class="el" href="../../d5/d8c/group__reqh.html#gaa9c67851d7304b6289ccc815d3c48264">m0_reqh_shutdown_wait()</a> mechanism we are sure that copy machine is IDLE and operation is completed before the <a class="el" href="../../d0/da4/group___c_m.html#ga895d1bfaa0c0fb68ffc2b8a6de9375d9">m0_cm_fini()</a> is invoked. </p><dl class="section note"><dt>Note</dt><dd>Presently services are stopped only during reqh shutdown.</dd></dl>
<h2><a class="anchor" id="CMDLD-lspec-thread"></a>
Threading and Concurrency Model</h2>
<ul>
<li>Copy machine is implemented as a state machine, and thus do not have its own thread. It runs in the context of reqh threads.</li>
<li>Copy machine starts as a service and is registered with the request handler.</li>
<li>The cmtype_mutex is used to serialise the operation on cmtypes_list.</li>
<li>Access to the members of struct <a class="el" href="../../dd/df9/structm0__cm.html">m0_cm</a> is serialised using the m0_cm::m0_sm_group::s_mutex.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="CMDLD-conformance"></a>
Conformance</h1>
<p>This section briefly describes interfaces and structures conforming to above mentioned copy machine requirements.</p><ul>
<li><b>i.cm.generic.invoke</b> Copy machine generic routines are invoked from copy machine specific code.</li>
<li><b>i.cm.generic.specific</b> Copy machine generic routines accordingly invoke copy machine specific operations.</li>
<li><b>i.cm.synchronise</b> Copy machine provides synchronised access to its members using m0_cm::cm_sm_group::s_mutex.</li>
<li><b>i.cm.failure</b> Copy machine handles various types of failures through <a class="el" href="../../d0/da4/group___c_m.html#ga68b2932d73eb35e41b83fb578eaadace">m0_cm_fail()</a> interface.</li>
<li><b>i.cm.resource.manage</b> Copy machine specific resources are managed by copy machine specific implementation, e.g. buffer pool, etc.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="CMDLD-ut"></a>
Unit Tests</h1>
<h2><a class="anchor" id="CMSETUP-ut"></a>
CM SETUP Unit Tests</h2>
<ul>
<li>Start copy machine and SNS cm service. Check all the states of copy machine such that they align to the state diagram.</li>
<li>Stop copy machine and check cleanup.</li>
</ul>
<hr/>
 <h1><a class="anchor" id="CMDLD-st"></a>
System Tests</h1>
<p>NA</p>
<hr/>
 <h1><a class="anchor" id="DLD-O"></a>
Analysis</h1>
<p>NA</p>
<hr/>
 <h1><a class="anchor" id="CMDLD-ref"></a>
References</h1>
<p>Following are the references to the documents from which the design is derived. For documentation links, please refer to this file : doc/motr-design-doc-list.rst</p><ul>
<li>Copy Machine redesign</li>
<li>HLD of copy machine and agents</li>
<li>HLD of SNS Repair </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d3/dd6/_d_l_d_i_x.html">Detailed Designs</a></li>
    <li class="footer">Generated on Fri May 20 2022 10:35:29 for Motr by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
